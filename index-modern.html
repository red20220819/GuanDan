<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¼è›‹ - ç°ä»£åŒ–ç•Œé¢ç‰ˆæœ¬</title>

    <!-- å¼•å…¥ç°ä»£åŒ–CSSæ ·å¼ -->
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/responsive.css">
    <link rel="stylesheet" href="css/game-modern.css">

    <style>
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        /* å¼ºåˆ¶ä¿®å¤ç‰Œé¢æ˜¾ç¤ºé—®é¢˜ */
        .player-card.red {
            color: #DC143C !important;
        }
        .player-card.black {
            color: #000 !important;
        }

        /* ç¡®ä¿ç‰Œé¢å†…å®¹å®šä½æ­£ç¡® */
        .player-card .card-top-left,
        .player-card .card-bottom-right {
            position: absolute !important;
        }

        .player-card .card-top-left {
            top: 3px !important;
            left: 3px !important;
        }

        .player-card .card-bottom-right {
            bottom: 3px !important;
            right: 3px !important;
            transform: rotate(180deg) !important;
        }

        /* ç‰Œé¢æ–‡å­—æ ·å¼ */
        .player-card .card-rank {
            font-weight: bold !important;
            font-size: 18px !important; /* ä»14pxå¢åŠ åˆ°18px (1.3å€) */
            line-height: 1 !important;
        }

        .player-card .card-suit {
            font-size: 26px !important; /* ä»20pxå¢åŠ åˆ°26px (1.3å€) */
            line-height: 1 !important;
        }

        /* JOKERç«–å‘æ˜¾ç¤ºæ ·å¼ */
        .player-card .card-rank.joker-text {
            writing-mode: vertical-rl !important;
            text-orientation: upright !important;
            letter-spacing: -3px !important; /* å‡å°‘å­—æ¯é—´è·ï¼Œæ›´ç´§å‡‘ */
            line-height: 0.6 !important; /* å‡å°‘è¡Œé«˜ï¼Œæ›´ç´§å‡‘ */
            font-size: 14px !important; /* æ”¹å›14px */
        }

        .message-bubble {
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- åŠ è½½ç”»é¢ -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-spinner"></div>
        <div class="loading-text">æ­£åœ¨åŠ è½½æ¼è›‹æ¸¸æˆ...</div>
        <div class="loading-progress">
            <div class="loading-progress-bar" id="loadingProgress"></div>
        </div>
        <div id="loadingStatus">åˆå§‹åŒ–ç»„ä»¶ä¸­...</div>
    </div>

    <!-- é”™è¯¯æ¶ˆæ¯ -->
    <div class="error-message" id="errorMessage">
        <h3>åŠ è½½é”™è¯¯</h3>
        <p id="errorText">æ¸¸æˆç»„ä»¶åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•ã€‚</p>
        <button onclick="location.reload()" class="btn btn-secondary">é‡æ–°åŠ è½½</button>
    </div>

    <!-- æ¸¸æˆä¸»å®¹å™¨ -->
    <div class="game-container" id="gameContainer">
        <div class="game-table">
            <!-- é¡¶éƒ¨ä¿¡æ¯æ  -->
            <div class="top-info-bar">
                <div class="info-display coin-display">
                    <span>ğŸ’°</span>
                    <span id="coins">1000</span>
                </div>
                <div class="info-display level-display">
                    <span>â­</span>
                    <span id="level">åˆçº§</span>
                </div>
                <div class="info-display score-display">
                    <span>ğŸ†</span>
                    <span id="score">1250</span>
                </div>
                <button class="settings-btn" onclick="showSettings()">âš™ï¸ è®¾ç½®</button>
            </div>

            <!-- é¡¶éƒ¨å›¢é˜Ÿä¿¡æ¯æ  -->
            <div class="team-info-bar">
                <div class="team-info-item">
                    <div class="team-label">é˜Ÿå‹é˜Ÿ (A)</div>
                    <div class="team-value team-a" id="teamACards">54å¼ </div>
                </div>
                <div class="team-info-item">
                    <div class="team-label">å¯¹æ‰‹é˜Ÿ (B)</div>
                    <div class="team-value team-b" id="teamBCards">54å¼ </div>
                </div>
                <div class="team-info-item">
                    <div class="team-label">å½“å‰çŠ¶æ€</div>
                    <div class="team-value" id="gameStatus">è¿›è¡Œä¸­</div>
                </div>
            </div>

            <!-- åŒ—æ–¹ç©å®¶ï¼ˆå¯¹å®¶ï¼‰ -->
            <div class="player-position player-north">
                <div class="ai-hand-cards" id="northCards">
                    <!-- AIæ‰‹ç‰Œåªæ˜¾ç¤ºç‰ŒèƒŒï¼Œå †å æ•ˆæœ -->
                </div>
                <!-- æ‚¬æµ®ä¿¡æ¯é¢æ¿ -->
                <div class="player-info">
                    <div class="player-avatar">ğŸ¤–</div>
                    <div class="player-details">
                        <div class="player-name-row">
                            <div class="player-name">AIç©å®¶2</div>
                            <div class="team-indicator opponent-indicator" title="å¯¹æ‰‹">ğŸ”´</div>
                        </div>
                        <div class="player-status">
                            <span class="card-count-info">å‰©ä½™: <span id="northCount">27</span>å¼ </span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- è¥¿æ–¹ç©å®¶ï¼ˆé˜Ÿå‹ï¼‰ -->
            <div class="player-position player-west">
                <!-- æ‚¬æµ®ä¿¡æ¯é¢æ¿ - åœ¨æ‰‹ç‰Œå·¦è¾¹ -->
                <div class="player-info">
                    <div class="player-avatar">ğŸ¯</div>
                    <div class="player-details">
                        <div class="player-name-row">
                            <div class="player-name">AIç©å®¶3</div>
                            <div class="team-indicator teammate-indicator" title="é˜Ÿå‹">ğŸ’š</div>
                        </div>
                        <div class="player-status">
                            <span class="card-count-info">å‰©ä½™: <span id="westCount">27</span>å¼ </span>
                        </div>
                    </div>
                </div>
                <!-- æ‰‹ç‰Œ - åœ¨å³è¾¹ -->
                <div class="ai-hand-cards" id="westCards">
                    <!-- AIæ‰‹ç‰Œåªæ˜¾ç¤ºç‰ŒèƒŒï¼Œå †å æ•ˆæœ -->
                </div>
            </div>

            <!-- ä¸œæ–¹ç©å®¶ï¼ˆå¯¹æ‰‹ï¼‰ -->
            <div class="player-position player-east">
                <!-- æ‚¬æµ®ä¿¡æ¯é¢æ¿ - åœ¨æ‰‹ç‰Œå·¦è¾¹ -->
                <div class="player-info">
                    <div class="player-avatar">âš¡</div>
                    <div class="player-details">
                        <div class="player-name-row">
                            <div class="player-name">AIç©å®¶4</div>
                            <div class="team-indicator opponent-indicator" title="å¯¹æ‰‹">ğŸ”´</div>
                        </div>
                        <div class="player-status">
                            <span class="card-count-info">å‰©ä½™: <span id="eastCount">27</span>å¼ </span>
                        </div>
                    </div>
                </div>
                <!-- æ‰‹ç‰Œ - åœ¨å³è¾¹ -->
                <div class="ai-hand-cards" id="eastCards">
                    <!-- AIæ‰‹ç‰Œåªæ˜¾ç¤ºç‰ŒèƒŒï¼Œå †å æ•ˆæœ -->
                </div>
            </div>

            <!-- å—æ–¹ç©å®¶ï¼ˆè‡ªå·±ï¼‰ -->
            <div class="player-position player-south">
                <!-- ä¸»ç©å®¶ä¿¡æ¯é¢æ¿ - æ‰‹ç‰Œå·¦ä¾§ -->
                <div class="player-info main-player-info" id="mainPlayerInfo">
                    <div class="player-avatar">ğŸŒŸ</div>
                    <div class="player-details">
                        <div class="player-name-row">
                            <div class="player-name">å—å®¶(ä½ )</div>
                            <div class="team-indicator teammate-indicator" title="é˜Ÿå‹">ğŸ’š</div>
                        </div>
                        <div class="player-status">
                            <span class="card-count-info">æ‰‹ç‰Œ: <span id="southCardCountDisplay">0</span>å¼ </span>
                        </div>
                        <div class="player-status" id="mainPlayerStatus">å‡†å¤‡ä¸­...</div>
                    </div>
                </div>
                <div class="player-hand-cards" id="southCards">
                    <!-- ç©å®¶æ‰‹ç‰Œå †å æ‘†æ”¾ -->
                </div>
            </div>

            <!-- ä¸­å¤®å‡ºç‰ŒåŒºåŸŸ -->
            <div class="central-play-area" id="centralPlayArea">
                <!-- åŒ—ä½å‡ºç‰Œç»„ - ç‹¬ç«‹åœ¨é¡¶éƒ¨ -->
                <div class="plays-group north-plays" id="northPlays"></div>

                <!-- è¥¿ä½å‡ºç‰Œç»„ - ç‹¬ç«‹åœ¨å·¦ä¾§ -->
                <div class="plays-group west-plays" id="westPlays"></div>

                <!-- ä¸­å¤®çŠ¶æ€æ˜¾ç¤º -->
                <div id="playAreaCenter">
                    <div id="playAreaStatus">ç­‰å¾…å‡ºç‰Œ...</div>
                </div>

                <!-- ä¸œä½å‡ºç‰Œç»„ - ç‹¬ç«‹åœ¨å³ä¾§ -->
                <div class="plays-group east-plays" id="eastPlays"></div>

                <!-- å—ä½å‡ºç‰Œç»„ - ç‹¬ç«‹åœ¨åº•éƒ¨ -->
                <div class="plays-group south-plays" id="southPlays"></div>
            </div>

            <!-- æ§åˆ¶æŒ‰é’®é¢æ¿ -->
            <div class="control-panel">
                <div class="control-buttons">
                    <button class="btn btn-play" id="playBtn" onclick="playCards()" disabled>
                        ğŸš€ å‡ºç‰Œ
                    </button>
                    <button class="btn btn-hint" id="hintBtn" onclick="showHint()">
                        ğŸ’¡ æç¤º
                    </button>
                    <button class="btn btn-pass" id="passBtn" onclick="passTurn()" disabled>
                        âœ‹ ä¸è¦
                    </button>
                    <button class="btn btn-sort" id="sortBtn" onclick="toggleSortMode()" title="åˆ‡æ¢æ’åºæ–¹å¼">
                        ğŸ”€ ç‚¹æ•°
                    </button>
                    <button class="btn btn-report" id="reportBtn" onclick="reportCards()">
                        ğŸ“Š æŠ¥ç‰Œ
                    </button>
                    <button class="btn btn-records" id="recordsBtn" onclick="showRecords()">
                        ğŸ† æˆ˜ç»©
                    </button>
                    <button class="btn btn-restart" id="restartBtn" onclick="restartGame()">
                        ğŸ”„ é‡æ–°å¼€å§‹
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- æ¸¸æˆJavaScript -->
    <!-- å¼•å…¥å¤–éƒ¨JavaScriptç»„ä»¶ -->
    <script src="js/components/RuleEngine.js"></script>
    <script src="js/ui-enhancements.js"></script>

    <!-- å¼•å…¥æµ‹è¯•æ¡†æ¶ -->
    <script src="js/test/TestSuite.js"></script>
    <script src="js/test/TestRunner.js"></script>
    <script src="js/test/tests/CardTypeTests.js"></script>
    <script src="js/test/tests/ComparisonTests.js"></script>
    <script src="js/test/tests/RoundTests.js"></script>
    <script src="js/test/tests/AITests.js"></script>

    <script>
        // æ¸¸æˆçŠ¶æ€ç®¡ç†ï¼ˆä¸åŸç‰ˆä¿æŒä¸€è‡´ï¼‰
        class GuandanGame {
            constructor() {
                this.players = {
                    // æ ‡å‡†æ–¹ä½ï¼šå—-è¥¿-åŒ—-ä¸œï¼ˆé€†æ—¶é’ˆï¼‰
                    east: { id: 'player2', name: 'ä¸œå®¶AI', cards: [], team: 'A', isAI: true },
                    south: { id: 'player1', name: 'å—å®¶(ä½ )', cards: [], team: 'A', isAI: false },
                    west: { id: 'player3', name: 'è¥¿å®¶AI', cards: [], team: 'B', isAI: true },
                    north: { id: 'player4', name: 'åŒ—å®¶AI', cards: [], team: 'B', isAI: true }
                };

                // æ’åºæ¨¡å¼
                this.sortMode = localStorage.getItem('guandan_sortMode') || 'rank'; // 'rank' æˆ– 'pattern'

                // é¦–å±€é€šè¿‡ç¿»ç‰Œå†³å®šé¦–å‡ºç©å®¶
                this.isFirstGame = true;
                this.currentPlayer = null; // å°†åœ¨initializeGameä¸­è®¾ç½®
                this.lastPlayer = null;
                this.currentRoundCards = [];
                this.selectedCards = [];
                this.gameState = 'waiting';
                this.playHistory = [];

                // æ¸¸æˆç»“æœè·Ÿè¸ª
                this.lastGameLoser = null; // ä¸Šå±€æœ«æ¸¸ç©å®¶
                this.gameResults = []; // æ¸¸æˆç»“æœè®°å½•

                // åˆå§‹åŒ–è§„åˆ™å¼•æ“ - ä½¿ç”¨æ–°çš„å®˜æ–¹è§„åˆ™å¼•æ“
                this.ruleEngine = new RuleEngine(this);
                this.rules = this.ruleEngine; // ä¿æŒå…¼å®¹æ€§
                this.lastPlay = null;

                // è½®æ¬¡ç®¡ç†
                this.roundActive = false;
                this.roundPlayers = new Set();
                this.roundStartPlayer = null;
                // è®°å½•æœ¬è½®å·²ç»è¿‡ç‰Œçš„ç©å®¶
                this.roundPassedPlayers = new Set();

                // æ¸¸æˆç»“æŸç›¸å…³
                this.gameRankings = []; // ç©å®¶æ’å [å¤´æ¸¸, äºŒæ¸¸, ä¸‰æ¸¸, æœ«æ¸¸]
                this.gameEnded = false;  // æ¸¸æˆæ˜¯å¦ç»“æŸ
                this.finishedPlayers = []; // å·²å®Œæˆæ¸¸æˆçš„ç©å®¶ï¼ˆæŒ‰å®Œæˆé¡ºåºï¼‰

                // å‡çº§æœºåˆ¶
                this.teamAScore = 0;
                this.teamBScore = 0;
                this.currentLevel = 2;
                this.gameHistory = [];
                this.currentDealer = null;

                // AIè®°ç‰Œç³»ç»Ÿ
                this.playedCards = []; // å·²å‡ºçš„ç‰Œ
                this.cardMemory = {
                    south: [], // è®°å½•å—å®¶å‡ºçš„ç‰Œ
                    west: [],  // è®°å½•è¥¿å®¶å‡ºçš„ç‰Œ
                    north: [], // è®°å½•åŒ—å®¶å‡ºçš„ç‰Œ
                    east: []   // è®°å½•ä¸œå®¶å‡ºçš„ç‰Œ
                };

                // éŸ³é¢‘ç³»ç»Ÿ
                this.audioContext = null;

                // è®¾ç½®è§„åˆ™å¼•æ“çš„åˆå§‹çº§åˆ«
                if (this.ruleEngine) {
                    this.ruleEngine.setLevel(this.currentLevel);
                }

                this.initializeGame();
            }

            // è¾…åŠ©å‡½æ•°ï¼šè·å–ç‰Œé¢æ˜¾ç¤ºå†…å®¹
            getCardDisplay(card) {
                if (card.rank === 'å°ç‹') {
                    return { rank: 'JOKER', suit: '', color: 'black', isJoker: true };
                } else if (card.rank === 'å¤§ç‹') {
                    return { rank: 'JOKER', suit: '', color: 'red', isJoker: true };
                }
                return { rank: card.rank, suit: card.suit, color: card.isRed ? 'red' : 'black', isJoker: false };
            }

            initializeGame() {
                this.dealCards();

                // å†³å®šé¦–å‡ºç©å®¶
                this.currentPlayer = this.determineFirstPlayer();
                console.log(`æ¸¸æˆåˆå§‹åŒ–å®Œæˆï¼Œé¦–å‡ºç©å®¶ï¼š${this.currentPlayer}`);

                // åˆå§‹åŒ–æ’åºæŒ‰é’®æ˜¾ç¤º
                const sortBtn = document.getElementById('sortBtn');
                if (sortBtn) {
                    if (this.sortMode === 'pattern') {
                        sortBtn.innerHTML = 'ğŸ¯ ç‰Œå‹';
                        sortBtn.title = 'åˆ‡æ¢åˆ°ç‚¹æ•°æ’åº';
                    } else {
                        sortBtn.innerHTML = 'ğŸ”€ ç‚¹æ•°';
                        sortBtn.title = 'åˆ‡æ¢åˆ°ç‰Œå‹æ’åº';
                    }
                }

                this.updateUI();
                this.gameState = 'playing';

                // å¦‚æœé¦–å‡ºç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨å‡ºç‰Œ
                if (this.players[this.currentPlayer].isAI) {
                    console.log(`é¦–å‡ºç©å®¶ ${this.currentPlayer} æ˜¯AIï¼Œè‡ªåŠ¨å‡ºç‰Œ`);
                    setTimeout(() => this.aiAutoPlay(), 1500);
                }
            }

            dealCards() {
                // åˆ›å»ºç‰Œç»„å¹¶åˆ†å‘
                const deck = this.createDeck();
                const positions = ['south', 'west', 'north', 'east']; // æŒ‰é€†æ—¶é’ˆé¡ºåºå‘ç‰Œ
                const cardsPerPlayer = Math.floor(deck.length / 4);

                positions.forEach((pos, index) => {
                    this.players[pos].cards = deck.slice(index * cardsPerPlayer, (index + 1) * cardsPerPlayer);
                    console.log(`${pos} ç©å®¶è·å¾— ${this.players[pos].cards.length} å¼ ç‰Œ`);
                });

                // éªŒè¯æ€»ç‰Œæ•°
                const totalCards = Object.values(this.players).reduce((sum, p) => sum + p.cards.length, 0);
                console.log(`æ€»å…±åˆ†é… ${totalCards} å¼ ç‰Œ`);

                // å¯¹æ‰‹ç‰Œè¿›è¡Œæ’åºï¼ˆåªå¯¹äººç±»ç©å®¶ï¼‰
                this.sortPlayerCards('south');
            }

            createDeck() {
                const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
                const ranks = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A', '2'];
                const deck = [];
                let cardIdCounter = 0; // ç”¨äºç”Ÿæˆå”¯ä¸€ID

                // åˆ›å»ºä¸¤å‰¯ç‰Œï¼ˆæ¼è›‹ä½¿ç”¨ä¸¤å‰¯ç‰Œï¼‰
                for (let deckCount = 0; deckCount < 2; deckCount++) {
                    for (let suit = 0; suit < 4; suit++) {
                        for (let rank = 0; rank < 13; rank++) {
                            deck.push({
                                id: `card_${cardIdCounter++}`, // æ·»åŠ å”¯ä¸€ID
                                suit: suits[suit],
                                rank: ranks[rank],
                                value: rank + 3,
                                isRed: suit === 1 || suit === 2,
                                deckId: deckCount + 1 // æ ‡è®°æ¥è‡ªå“ªå‰¯ç‰Œ
                            });
                        }
                    }
                }

                // æ·»åŠ å¤§å°ç‹ï¼ˆä¸¤å‰¯ç‰Œå„2å¼ ï¼Œå…±4å¼ ç‹ç‰Œï¼‰
                deck.push({
                    id: `card_${cardIdCounter++}`,
                    suit: 'joker',
                    rank: 'å°ç‹',
                    value: 16,
                    isRed: true,
                    deckId: 1
                });
                deck.push({
                    id: `card_${cardIdCounter++}`,
                    suit: 'joker',
                    rank: 'å°ç‹',
                    value: 16,
                    isRed: true,
                    deckId: 2
                });
                deck.push({
                    id: `card_${cardIdCounter++}`,
                    suit: 'joker',
                    rank: 'å¤§ç‹',
                    value: 17,
                    isRed: true,
                    deckId: 1
                });
                deck.push({
                    id: `card_${cardIdCounter++}`,
                    suit: 'joker',
                    rank: 'å¤§ç‹',
                    value: 17,
                    isRed: true,
                    deckId: 2
                });

                console.log(`[createDeck] åˆ›å»ºäº† ${deck.length} å¼ ç‰Œï¼Œæ¯å¼ éƒ½æœ‰å”¯ä¸€ID`);
                return this.shuffleArray(deck);
            }

            shuffleArray(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }

            updateUI() {
                this.updatePlayerCards();
                this.updatePlayArea();
                this.updateInfoBars();
                this.updateControlButtons();
            }

            updatePlayerCards() {
                // æ›´æ–°AIç©å®¶æ‰‹ç‰Œæ˜¾ç¤º
                ['north', 'west', 'east'].forEach(pos => {
                    const cardCount = this.players[pos].cards.length;
                    const container = document.getElementById(pos + 'Cards');
                    container.innerHTML = '';

                    // æ˜¾ç¤ºç‰ŒèƒŒï¼Œæ•°é‡ä¸å®é™…æ‰‹ç‰Œæ•°å¯¹åº”
                    const displayCount = Math.min(cardCount, 5);
                    for (let i = 0; i < displayCount; i++) {
                        const cardElement = document.createElement('div');
                        cardElement.className = 'ai-card-back';
                        cardElement.innerHTML = 'ğŸ‚ ';
                        container.appendChild(cardElement);
                    }

                    // æ›´æ–°AIç©å®¶ç‰Œæ•°æ˜¾ç¤º
                    const countElement = document.getElementById(pos + 'Count');
                    if (countElement) {
                        countElement.textContent = cardCount;
                    }
                });

                // æ›´æ–°ç©å®¶æ‰‹ç‰Œæ˜¾ç¤º
                const southCards = this.players.south.cards;
                const southContainer = document.getElementById('southCards');
                southContainer.innerHTML = '';

                southCards.forEach((card, index) => {
                    const cardElement = document.createElement('div');
                    const display = this.getCardDisplay(card);
                    cardElement.className = `player-card ${display.color}`;

                    // ç”Ÿæˆç‰Œçš„HTMLå†…å®¹
                    let cardHTML = '<div class="card-content">';

                    if (display.isJoker) {
                        // å¤§å°ç‹çš„ç‰¹æ®Šæ˜¾ç¤º
                        cardHTML += `
                            <div class="card-top-left">
                                <div class="card-rank joker-text">JOKER</div>
                            </div>
                            <div class="card-bottom-right">
                                <div class="card-rank joker-text">JOKER</div>
                            </div>
                        `;
                    } else {
                        // æ™®é€šç‰Œçš„æ˜¾ç¤º
                        cardHTML += `
                            <div class="card-top-left">
                                <div class="card-rank">${display.rank}</div>
                                <div class="card-suit">${display.suit}</div>
                            </div>
                            <div class="card-bottom-right">
                                <div class="card-rank">${display.rank}</div>
                                <div class="card-suit">${display.suit}</div>
                            </div>
                        `;
                    }

                    cardHTML += '</div>';
                    cardElement.innerHTML = cardHTML;

                    cardElement.style.setProperty('--card-index', index + 1);
                    cardElement.onclick = () => this.selectCard(card, cardElement);
                    southContainer.appendChild(cardElement);
                });

                // æ›´æ–°å—æ–¹ç©å®¶å‰©ä½™ç‰Œæ•°
                const southCountElement = document.getElementById('southCardCountDisplay');
                if (southCountElement) {
                    southCountElement.textContent = southCards.length;
                }
            }

            // ========== æ’åºç›¸å…³æ–¹æ³• ==========

            /**
             * åˆ‡æ¢æ’åºæ¨¡å¼
             */
            toggleSortMode() {
                // åˆ‡æ¢æ’åºæ¨¡å¼
                this.sortMode = this.sortMode === 'rank' ? 'pattern' : 'rank';
                localStorage.setItem('guandan_sortMode', this.sortMode);

                // ä¿å­˜å·²é€‰ä¸­çš„ç‰Œ
                const selectedCards = [...this.selectedCards];
                const selectedCardIds = selectedCards.map(card => card.rank + card.suit);

                // é‡æ–°æ’åºæ‰‹ç‰Œ
                this.sortPlayerCards('south');

                // æ¢å¤é€‰ä¸­çŠ¶æ€
                this.selectedCards = [];
                this.players.south.cards.forEach(card => {
                    const cardId = card.rank + card.suit;
                    if (selectedCardIds.includes(cardId)) {
                        this.selectedCards.push(card);
                    }
                });

                // æ›´æ–°UI
                this.updateUI();

                // æ›´æ–°æŒ‰é’®æ˜¾ç¤º
                const sortBtn = document.getElementById('sortBtn');
                if (sortBtn) {
                    if (this.sortMode === 'pattern') {
                        sortBtn.innerHTML = 'ğŸ¯ ç‰Œå‹';
                        sortBtn.title = 'åˆ‡æ¢åˆ°ç‚¹æ•°æ’åº';
                    } else {
                        sortBtn.innerHTML = 'ğŸ”€ ç‚¹æ•°';
                        sortBtn.title = 'åˆ‡æ¢åˆ°ç‰Œå‹æ’åº';
                    }
                }

                // æ˜¾ç¤ºæç¤º
                const modeText = this.sortMode === 'pattern' ? 'ç‰Œå‹' : 'ç‚¹æ•°';
                this.showMessage(`å·²åˆ‡æ¢åˆ°${modeText}æ’åº`, 'info');
            }

            /**
             * æ’åºç©å®¶æ‰‹ç‰Œ
             * @param {string} playerId - ç©å®¶ID
             */
            sortPlayerCards(playerId) {
                const player = this.players[playerId];
                if (!player || player.isAI) return;

                if (this.sortMode === 'pattern') {
                    // æŒ‰ç‰Œå‹æ’åº
                    player.cards = this.sortCardsByPattern(player.cards);
                } else {
                    // æŒ‰ç‚¹æ•°æ’åºï¼ˆé»˜è®¤ï¼‰
                    player.cards.sort((a, b) => this.getRankValue(b.rank) - this.getRankValue(a.rank));
                }
            }

            /**
             * æŒ‰ç‰Œå‹æ’åºæ‰‹ç‰Œ
             * @param {Array} cards - æ‰‹ç‰Œæ•°ç»„
             * @returns {Array} æ’åºåçš„æ‰‹ç‰Œ
             */
            sortCardsByPattern(cards) {
                // ç‰Œå‹ä¼˜å…ˆçº§ï¼ˆæ•°å€¼è¶Šå¤§ä¼˜å…ˆçº§è¶Šé«˜ï¼‰
                const patternPriority = {
                    'king_bomb': 12,      // å¤©ç‹ç‚¸ï¼ˆ4å¼ ç‹ï¼‰
                    'bomb_8': 11,         // 8ç‚¸
                    'bomb_7': 10,         // 7ç‚¸
                    'bomb_6': 9,          // 6ç‚¸
                    'straight_flush': 8,  // åŒèŠ±é¡º
                    'bomb_5': 7,          // 5ç‚¸
                    'bomb_4': 6,          // 4ç‚¸
                    'airplane': 5,        // é’¢æ¿ï¼ˆè¿ä¸‰ï¼‰
                    'consecutive_pairs': 4, // è¿å¯¹
                    'straight': 3,        // é¡ºå­
                    'three_with_pair': 2, // ä¸‰å¸¦äºŒ
                    'triple': 1,          // ä¸‰å¼ 
                    'pair': 0,            // å¯¹å­
                    'single': -1          // å•å¼ 
                };

                // æŒ‰ç‰Œå€¼åˆ†ç»„
                const rankGroups = {};
                cards.forEach(card => {
                    if (!rankGroups[card.rank]) {
                        rankGroups[card.rank] = [];
                    }
                    rankGroups[card.rank].push(card);
                });

                const groups = {
                    king_bomb: [],
                    bomb_8: [],
                    bomb_7: [],
                    bomb_6: [],
                    straight_flush: [],
                    bomb_5: [],
                    bomb_4: [],
                    airplane: [],
                    consecutive_pairs: [],
                    straight: [],
                    three_with_pair: [],
                    triple: [],
                    pair: [],
                    single: []
                };

                const usedCards = new Set();

                // 1. è¯†åˆ«å¤©ç‹ç‚¸ï¼ˆ4å¼ ç‹ï¼‰
                const jokers = cards.filter(card => card.suit === 'joker');
                if (jokers.length === 4) {
                    groups.king_bomb.push(jokers);
                    jokers.forEach(card => usedCards.add(card));
                }

                // 2. è¯†åˆ«ç‚¸å¼¹ï¼ˆ4å¼ åŠä»¥ä¸ŠåŒç‚¹æ•°ï¼‰
                for (let rank in rankGroups) {
                    const count = rankGroups[rank].length;
                    if (count >= 4 && rank !== 'å°ç‹' && rank !== 'å¤§ç‹') {
                        const bomb = rankGroups[rank].slice(0, count);

                        // æ ¹æ®å¼ æ•°åˆ†ç±»
                        if (count >= 8) {
                            groups.bomb_8.push(bomb);
                        } else if (count >= 7) {
                            groups.bomb_7.push(bomb);
                        } else if (count >= 6) {
                            groups.bomb_6.push(bomb);
                        } else if (count >= 5) {
                            groups.bomb_5.push(bomb);
                        } else {
                            groups.bomb_4.push(bomb);
                        }

                        bomb.forEach(card => usedCards.add(card));
                    }
                }

                // 3. è¯†åˆ«åŒèŠ±é¡ºï¼ˆ5å¼ ä»¥ä¸ŠåŒèŠ±è‰²è¿ç»­ï¼‰
                const suitGroups = {};
                cards.forEach(card => {
                    if (!usedCards.has(card) && card.suit !== 'joker' && card.rank !== '2') {
                        if (!suitGroups[card.suit]) {
                            suitGroups[card.suit] = [];
                        }
                        suitGroups[card.suit].push(card);
                    }
                });

                for (let suit in suitGroups) {
                    const suitCards = suitGroups[suit];
                    suitCards.sort((a, b) => this.getRankValue(a.rank) - this.getRankValue(b.rank));

                    // æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„åŒèŠ±é¡º
                    for (let i = 0; i <= suitCards.length - 5; i++) {
                        for (let length = 5; length <= suitCards.length - i; length++) {
                            const straight = suitCards.slice(i, i + length);
                            let isConsecutive = true;

                            for (let j = 1; j < straight.length; j++) {
                                if (this.getRankValue(straight[j].rank) !== this.getRankValue(straight[j-1].rank) + 1) {
                                    isConsecutive = false;
                                    break;
                                }
                            }

                            if (isConsecutive && !straight.some(card => usedCards.has(card))) {
                                groups.straight_flush.push(straight);
                                straight.forEach(card => usedCards.add(card));
                                break; // åªå–æœ€é•¿çš„åŒèŠ±é¡º
                            }
                        }
                    }
                }

                // 4. è¯†åˆ«è¿å¯¹ï¼ˆ3å¯¹åŠä»¥ä¸Šè¿ç»­å¯¹å­ï¼‰
                const pairs = [];
                for (let rank in rankGroups) {
                    if (rankGroups[rank].length >= 2) {
                        const availableCards = rankGroups[rank].filter(card => !usedCards.has(card));
                        if (availableCards.length >= 2) {
                            pairs.push({
                                rank: rank,
                                value: this.getRankValue(rank),
                                cards: availableCards.slice(0, 2)
                            });
                        }
                    }
                }
                pairs.sort((a, b) => b.value - a.value);

                // æŸ¥æ‰¾è¿ç»­çš„å¯¹å­
                for (let i = 0; i <= pairs.length - 3; i++) {
                    let consecutivePairs = [pairs[i]];
                    let j = i + 1;

                    while (j < pairs.length && pairs[j].value === pairs[j-1].value - 1) {
                        consecutivePairs.push(pairs[j]);
                        j++;
                    }

                    if (consecutivePairs.length >= 3) {
                        const allPairs = consecutivePairs.flatMap(p => p.cards);
                        groups.consecutive_pairs.push(allPairs);
                        allPairs.forEach(card => usedCards.add(card));
                    }
                }

                // 5. è¯†åˆ«é’¢æ¿ï¼ˆè¿ä¸‰/é£æœºï¼‰
                const triples = [];
                for (let rank in rankGroups) {
                    if (rankGroups[rank].length >= 3) {
                        const availableCards = rankGroups[rank].filter(card => !usedCards.has(card));
                        if (availableCards.length >= 3) {
                            triples.push({
                                rank: rank,
                                value: this.getRankValue(rank),
                                cards: availableCards.slice(0, 3)
                            });
                        }
                    }
                }
                triples.sort((a, b) => b.value - a.value);

                // æŸ¥æ‰¾è¿ç»­çš„ä¸‰å¼ 
                for (let i = 0; i <= triples.length - 2; i++) {
                    let consecutiveTriples = [triples[i]];
                    let j = i + 1;

                    while (j < triples.length && triples[j].value === triples[j-1].value - 1) {
                        consecutiveTriples.push(triples[j]);
                        j++;
                    }

                    if (consecutiveTriples.length >= 2) {
                        const allTriples = consecutiveTriples.flatMap(t => t.cards);
                        groups.airplane.push(allTriples);
                        allTriples.forEach(card => usedCards.add(card));
                    }
                }

                // 6. è¯†åˆ«é¡ºå­ï¼ˆ5å¼ åŠä»¥ä¸Šè¿ç»­å•ç‰Œï¼‰
                const nonJokerCards = cards.filter(card =>
                    !usedCards.has(card) &&
                    card.suit !== 'joker' &&
                    card.rank !== '2'
                );
                nonJokerCards.sort((a, b) => this.getRankValue(a.rank) - this.getRankValue(b.rank));

                for (let i = 0; i <= nonJokerCards.length - 5; i++) {
                    for (let length = 5; length <= nonJokerCards.length - i; length++) {
                        const straight = nonJokerCards.slice(i, i + length);
                        let isConsecutive = true;

                        for (let j = 1; j < straight.length; j++) {
                            if (this.getRankValue(straight[j].rank) !== this.getRankValue(straight[j-1].rank) + 1) {
                                isConsecutive = false;
                                break;
                            }
                        }

                        if (isConsecutive && !straight.some(card => usedCards.has(card))) {
                            groups.straight.push(straight);
                            straight.forEach(card => usedCards.add(card));
                            break;
                        }
                    }
                }

                // 7. è¯†åˆ«å‰©ä½™çš„ç‰Œå‹
                for (let rank in rankGroups) {
                    const cards = rankGroups[rank];
                    const availableCards = cards.filter(card => !usedCards.has(card));

                    // ä¸‰å¸¦äºŒ
                    if (availableCards.length >= 3) {
                        const triple = availableCards.slice(0, 3);

                        // æŸ¥æ‰¾å…¶ä»–ç‰Œä½œä¸ºå¸¦ç‰Œ
                        const otherCards = availableCards.slice(3);
                        if (otherCards.length >= 2) {
                            const threeWithPair = [...triple, ...otherCards.slice(0, 2)];
                            groups.three_with_pair.push(threeWithPair);
                            triple.forEach(card => usedCards.add(card));
                            otherCards.slice(0, 2).forEach(card => usedCards.add(card));
                            continue;
                        }
                    }

                    // ä¸‰å¼ 
                    if (availableCards.length >= 3) {
                        groups.triple.push(availableCards.slice(0, 3));
                        availableCards.slice(0, 3).forEach(card => usedCards.add(card));
                    } else if (availableCards.length >= 2) {
                        groups.pair.push(availableCards.slice(0, 2));
                        availableCards.slice(0, 2).forEach(card => usedCards.add(card));
                    } else if (availableCards.length >= 1) {
                        groups.single.push(availableCards[0]);
                        usedCards.add(availableCards[0]);
                    }
                }

                // æŒ‰ä¼˜å…ˆçº§æ’åºå¹¶ä»å¤§åˆ°å°æ’åˆ—
                const sortedCards = [];
                const sortedTypes = Object.keys(groups).sort((a, b) => patternPriority[b] - patternPriority[a]);

                sortedTypes.forEach(type => {
                    // åŒç‰Œå‹å†…æŒ‰ç‚¹æ•°ä»å¤§åˆ°å°æ’åº
                    groups[type].sort((a, b) => {
                        const aValue = Array.isArray(a) ? this.getRankValue(a[0].rank) : this.getRankValue(a.rank);
                        const bValue = Array.isArray(b) ? this.getRankValue(b[0].rank) : this.getRankValue(b.rank);
                        return bValue - aValue;
                    });

                    // å±•å¼€æ‰€æœ‰ç‰Œ
                    groups[type].forEach(cards => {
                        if (Array.isArray(cards)) {
                            sortedCards.push(...cards);
                        } else {
                            sortedCards.push(cards);
                        }
                    });
                });

                return sortedCards;
            }

            updatePlayArea() {
                // æ¸…ç©ºä¸­å¤®åŒºåŸŸ
                ['northPlays', 'southPlays', 'westPlays', 'eastPlays'].forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.innerHTML = '';
                        element.classList.remove('latest-group');
                    }
                });

                // æ›´æ–°ä¸­å¤®çŠ¶æ€
                const centerArea = document.getElementById('playAreaCenter');
                if (this.currentRoundCards.length === 0) {
                    centerArea.innerHTML = '<div id="playAreaStatus">ç­‰å¾…å‡ºç‰Œ...</div>';
                    centerArea.style.display = 'block';
                    return;
                }

                // éšè—ä¸­å¤®çŠ¶æ€
                centerArea.style.display = 'none';

                // æŒ‰å‡ºç‰Œä½ç½®åˆ†é…åˆ°ä¸­å¤®åŒºåŸŸçš„å„ä½ç½®
                // ç¡®ä¿åå‡ºç‰Œçš„ç©å®¶è¦†ç›–å…ˆå‡ºç‰Œçš„ç©å®¶
                this.currentRoundCards.forEach((play, index) => {
                    if (play.cards.length === 0 || play.action === 'pass') {
                        return;
                    }

                    const positionElement = document.getElementById(play.player + 'Plays');
                    if (!positionElement) return;

                    // æœ€æ–°å‡ºç‰Œçªå‡ºæ˜¾ç¤º
                    if (index === this.currentRoundCards.length - 1) {
                        positionElement.classList.add('latest-group');
                    }

                    // ä½¿ç”¨æ—¶é—´æˆ³ç¡®ä¿åå‡ºç‰Œçš„z-indexæ›´é«˜
                    const playTime = play.timestamp || Date.now();
                    const baseZIndex = 1000 + playTime;

                    // åˆ›å»ºç‰Œå…ƒç´ 
                    play.cards.forEach((card, cardIndex) => {
                        const cardElement = document.createElement('div');
                        const display = this.getCardDisplay(card);
                        cardElement.className = `player-card ${display.color}`;

                        // ç”Ÿæˆç‰Œçš„HTMLå†…å®¹
                        let cardHTML = '<div class="card-content">';

                        if (display.isJoker) {
                            // å¤§å°ç‹çš„ç‰¹æ®Šæ˜¾ç¤º
                            cardHTML += `
                                <div class="card-top-left">
                                    <div class="card-rank joker-text">JOKER</div>
                                </div>
                                <div class="card-bottom-right">
                                    <div class="card-rank joker-text">JOKER</div>
                                </div>
                            `;
                        } else {
                            // æ™®é€šç‰Œçš„æ˜¾ç¤º
                            cardHTML += `
                                <div class="card-top-left">
                                    <div class="card-rank">${display.rank}</div>
                                    <div class="card-suit">${display.suit}</div>
                                </div>
                                <div class="card-bottom-right">
                                    <div class="card-rank">${display.rank}</div>
                                    <div class="card-suit">${display.suit}</div>
                                </div>
                            `;
                        }

                        cardHTML += '</div>';
                        cardElement.innerHTML = cardHTML;

                        // è®¾ç½®åŸºäºæ—¶é—´å’Œç‰Œåºçš„z-indexï¼Œç¡®ä¿åå‡ºç‰Œè¦†ç›–å…ˆå‡ºç‰Œ
                        cardElement.style.zIndex = baseZIndex + cardIndex;
                        positionElement.appendChild(cardElement);
                    });
                });
            }

            updateInfoBars() {
                // æ›´æ–°æ¸¸æˆçŠ¶æ€
                const statusElement = document.getElementById('gameStatus');
                if (statusElement) {
                    statusElement.textContent = this.gameState === 'playing' ? 'è¿›è¡Œä¸­' : 'ç­‰å¾…';
                }
            }

            updateControlButtons() {
                const isPlayerTurn = this.currentPlayer === 'south' && this.gameState === 'playing';

                // ä¸»è¦æ¸¸æˆæŒ‰é’®
                const playBtn = document.getElementById('playBtn');
                const passBtn = document.getElementById('passBtn');
                const hintBtn = document.getElementById('hintBtn');
                const reportBtn = document.getElementById('reportBtn');

                playBtn.disabled = !isPlayerTurn || this.selectedCards.length === 0;
                passBtn.disabled = !isPlayerTurn;
                hintBtn.disabled = !isPlayerTurn;
                reportBtn.disabled = !isPlayerTurn;

                // æ›´æ–°æŒ‰é’®è§†è§‰çŠ¶æ€
                if (window.uiEnhancements) {
                    [playBtn, passBtn, hintBtn, reportBtn].forEach(btn => {
                        window.uiEnhancements.updateButtonState(btn);
                    });
                }

                // é«˜äº®å½“å‰ç©å®¶
                if (window.uiEnhancements && window.uiEnhancements.highlightCurrentPlayer) {
                    window.uiEnhancements.highlightCurrentPlayer(this.currentPlayer);
                }
            }

            selectCard(card, element) {
                if (this.currentPlayer !== 'south') return;

                // é¦–æ¬¡ç‚¹å‡»æ—¶åˆå§‹åŒ–éŸ³é¢‘
                this.initAudio();

                // ä½¿ç”¨å”¯ä¸€IDæ¥æŸ¥æ‰¾ï¼Œç¡®ä¿èƒ½æ­£ç¡®è¯†åˆ«é‡å¤çš„ç‰Œ
                let index = -1;
                if (card.id) {
                    // ä¼˜å…ˆä½¿ç”¨IDæŸ¥æ‰¾
                    index = this.selectedCards.findIndex(c => c.id === card.id);
                } else {
                    // å…¼å®¹æ—§æ•°æ®ï¼Œä½¿ç”¨suitå’Œrank
                    index = this.selectedCards.findIndex(c =>
                        c.suit === card.suit && c.rank === card.rank
                    );
                }

                if (index === -1) {
                    // é€‰ä¸­ç‰Œ
                    this.selectedCards.push(card);
                    element.classList.add('selected');
                    console.log(`[é€‰æ‹©ç‰Œ] æ·»åŠ : ${card.rank}${card.suit} (ID: ${card.id || 'æœªçŸ¥'})`);
                } else {
                    // å–æ¶ˆé€‰ä¸­
                    this.selectedCards.splice(index, 1);
                    element.classList.remove('selected');
                    console.log(`[é€‰æ‹©ç‰Œ] ç§»é™¤: ${card.rank}${card.suit} (ID: ${card.id || 'æœªçŸ¥'})`);
                }

                this.updateControlButtons();
            }

            playCards() {
                if (this.selectedCards.length === 0) return;

                // è·å–ä¸Šä¸€æ‰‹ç‰Œ
                let lastPlay = null;
                if (this.currentRoundCards.length > 0) {
                    // æ‰¾åˆ°æœ€åä¸€æ¬¡æœ‰æ•ˆå‡ºç‰Œï¼ˆépassï¼‰
                    for (let i = this.currentRoundCards.length - 1; i >= 0; i--) {
                        const play = this.currentRoundCards[i];
                        if (play.cards && play.cards.length > 0) {
                            lastPlay = {
                                cards: play.cards,
                                type: play.cardType || this.getCardType(play.cards)
                            };
                            break;
                        }
                    }
                }

                // ä½¿ç”¨è§„åˆ™å¼•æ“éªŒè¯å‡ºç‰Œ
                const validation = this.rules.validatePlay(
                    this.selectedCards,
                    lastPlay,
                    this.players.south.cards
                );

                if (!validation.valid) {
                    this.showMessage(validation.message, 'error');
                    return;
                }

                // ç§»é™¤æ‰‹ç‰Œ - ä½¿ç”¨å”¯ä¸€IDæ¥ç¡®ä¿ç§»é™¤æ­£ç¡®çš„ç‰Œ
                this.selectedCards.forEach(card => {
                    // ä¼˜å…ˆä½¿ç”¨å”¯ä¸€IDæŸ¥æ‰¾
                    let index = -1;
                    if (card.id) {
                        index = this.players.south.cards.findIndex(c => c.id === card.id);
                    }

                    // å¦‚æœæ²¡æœ‰IDï¼ˆå…¼å®¹æ—§æ•°æ®ï¼‰ï¼Œä½¿ç”¨suitå’Œrank
                    if (index === -1) {
                        index = this.players.south.cards.findIndex(c =>
                            c.suit === card.suit && c.rank === card.rank
                        );
                    }

                    if (index !== -1) {
                        console.log(`[å‡ºç‰Œ] ç§»é™¤ç‰Œ: ${card.rank}${card.suit} (ID: ${card.id || 'æœªçŸ¥'})`);
                        this.players.south.cards.splice(index, 1);
                    } else {
                        console.error(`[å‡ºç‰Œé”™è¯¯] æ‰¾ä¸åˆ°è¦ç§»é™¤çš„ç‰Œ: ${card.rank}${card.suit}`);
                    }
                });

                // æ›´æ–°è®°ç‰Œç³»ç»Ÿ
                this.updateCardMemory('south', [...this.selectedCards]);

                // æ·»åŠ åˆ°å½“å‰è½®æ¬¡
                this.currentRoundCards.push({
                    player: 'south',
                    cards: [...this.selectedCards],
                    cardType: validation.type,
                    timestamp: Date.now()
                });

                // è®°å½•æœ¬è½®å‡ºç‰Œçš„ç©å®¶
                this.roundPlayers.add('south');

                // æ’­æ”¾éŸ³æ•ˆ
                const cardType = validation.type;
                if (cardType && cardType.type === 'bomb') {
                    this.playSound('bomb');
                } else {
                    this.playSound('play');
                }

                this.selectedCards = [];

                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                if (this.checkGameEnd()) {
                    return;
                }

                // åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªç©å®¶
                this.switchToNextPlayer();
            }

            passTurn() {
                this.selectedCards = [];

                // è®°å½•passæ“ä½œ
                this.currentRoundCards.push({
                    player: this.currentPlayer,
                    cards: [],
                    timestamp: Date.now(),
                    action: 'pass'
                });

                // æ·»åŠ åˆ°å·²è¿‡ç‰Œç©å®¶é›†åˆ
                this.roundPassedPlayers.add(this.currentPlayer);
                console.log(`[è½®æ¬¡] ${this.currentPlayer} è¿‡ç‰Œï¼Œæœ¬å›åˆæ°¸ä¹…å¤±å»å‡ºç‰Œæƒ`);

                // æ’­æ”¾è¿‡ç‰ŒéŸ³æ•ˆ
                this.playSound('pass');

                this.switchToNextPlayer();
            }

            switchToNextPlayer() {
                // é€†æ—¶é’ˆé¡ºåºï¼šå— â†’ è¥¿ â†’ åŒ— â†’ ä¸œ
                const order = ['south', 'west', 'north', 'east'];
                const currentIndex = order.indexOf(this.currentPlayer);

                // æ£€æŸ¥å½“å‰ç©å®¶æ˜¯å¦æ‰‹ç‰Œä¸º0ï¼Œå¦‚æœæ˜¯åˆ™è‡ªåŠ¨è¿‡ç‰Œ
                if (this.players[this.currentPlayer].cards.length === 0) {
                    console.log(`[switchToNextPlayer] ${this.currentPlayer} æ‰‹ç‰Œä¸º0ï¼Œè‡ªåŠ¨è¿‡ç‰Œ`);
                    this.roundPassedPlayers.add(this.currentPlayer);
                }

                // å¦‚æœæ‰€æœ‰å…¶ä»–ç©å®¶éƒ½è¿‡ç‰Œäº†ï¼Œæ¸…ç†æ¡Œé¢
                const activePlayers = order.filter(p => this.players[p].cards.length > 0);
                const passedActivePlayers = activePlayers.filter(p => this.roundPassedPlayers.has(p));

                if (passedActivePlayers.length >= activePlayers.length - 1 && activePlayers.length > 0) {
                    console.log('[è½®æ¬¡ç»“æŸ] æ‰€æœ‰å…¶ä»–æ´»è·ƒç©å®¶éƒ½è¿‡ç‰Œï¼Œè½®æ¬¡ç»“æŸ');
                    this.processRoundEnd();
                    return;
                }

                // æ‰¾åˆ°ä¸‹ä¸€ä¸ªå¯ä»¥å‡ºç‰Œçš„ç©å®¶
                let nextPlayer = null;
                for (let i = 1; i <= 4; i++) {
                    const candidate = order[(currentIndex + i) % 4];
                    // å¦‚æœè¯¥ç©å®¶æ²¡æœ‰è¿‡ç‰Œä¸”è¿˜æœ‰æ‰‹ç‰Œï¼Œåˆ™å¯ä»¥ä½œä¸ºä¸‹ä¸€ä¸ªç©å®¶
                    if (!this.roundPassedPlayers.has(candidate) && this.players[candidate].cards.length > 0) {
                        nextPlayer = candidate;
                        break;
                    }
                }

                // é˜²æ­¢æ­»å¾ªç¯
                if (!nextPlayer) {
                    console.error('[switchToNextPlayer] é”™è¯¯ï¼šæ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªç©å®¶ï¼Œå¼ºåˆ¶æ¸…ç†æ¡Œé¢');
                    this.processRoundEnd();
                    return;
                }

                // æ­£å¸¸è½®è½¬åˆ°ä¸‹ä¸€ä¸ªç©å®¶
                this.currentPlayer = nextPlayer;
                console.log(`\n[è½®è½¬] ${order[currentIndex]} â†’ ${nextPlayer}`);

                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                if (this.checkGameEnd()) {
                    return;
                }

                this.updateUI();

                // åªæœ‰AIç©å®¶æ‰è‡ªåŠ¨å‡ºç‰Œ
                if (this.players[this.currentPlayer].isAI) {
                    // éšæœºæ€è€ƒæ—¶é—´ï¼Œè®©AIæ›´åƒçœŸäºº
                    const thinkingTime = this.getRandomThinkingTime();
                    this.showAIThinking(this.currentPlayer);
                    setTimeout(() => this.aiAutoPlay(), thinkingTime);
                }
            }

            // æ£€æŸ¥æ˜¯å¦åº”è¯¥æ¸…ç†æ¡Œé¢
            shouldClearTable() {
                // å¿…é¡»æœ‰å‡ºç‰Œè®°å½•
                if (this.currentRoundCards.length === 0) return false;

                // å¿…é¡»æœ‰è‡³å°‘ä¸€æ¬¡æœ‰æ•ˆå‡ºç‰Œ
                const hasValidPlay = this.currentRoundCards.some(play =>
                    play.cards && play.cards.length > 0
                );
                if (!hasValidPlay) return false;

                console.log(`[shouldClearTable] å½“å‰è½®æ¬¡è®°å½•: ${this.currentRoundCards.map(p => `${p.player}: ${p.cards && p.cards.length > 0 ? p.cards.map(c => c.rank).join(',') : 'pass'}`).join(' | ')}`);

                // æ£€æŸ¥æœ€è¿‘çš„ç©å®¶æ˜¯å¦éƒ½passäº†
                // æ‰¾åˆ°æœ€åä¸€æ¬¡æœ‰æ•ˆå‡ºç‰Œ
                let lastValidPlayIndex = -1;
                for (let i = this.currentRoundCards.length - 1; i >= 0; i--) {
                    if (this.currentRoundCards[i].cards && this.currentRoundCards[i].cards.length > 0) {
                        lastValidPlayIndex = i;
                        break;
                    }
                }

                if (lastValidPlayIndex === -1) return false;

                const lastPlayPlayer = this.currentRoundCards[lastValidPlayIndex].player;
                console.log(`[shouldClearTable] æœ€åå‡ºç‰Œç©å®¶: ${lastPlayPlayer}, ç´¢å¼•: ${lastValidPlayIndex}`);

                // æ£€æŸ¥æœ€åå‡ºç‰Œä¹‹åæ˜¯å¦æ‰€æœ‰å…¶ä»–ç©å®¶éƒ½passäº†
                const playersAfter = this.currentRoundCards.slice(lastValidPlayIndex + 1);
                console.log(`[shouldClearTable] ä¹‹åçš„æ“ä½œ: ${playersAfter.map(p => p.player).join(', ')}`);

                const order = ['south', 'west', 'north', 'east'];
                const lastPlayerIndex = order.indexOf(lastPlayPlayer);

                // å…¶ä»–3ä¸ªç©å®¶éƒ½å¿…é¡»pass
                for (let i = 1; i <= 3; i++) {
                    const nextPlayerIndex = (lastPlayerIndex + i) % 4;
                    const nextPlayer = order[nextPlayerIndex];
                    console.log(`[shouldClearTable] æ£€æŸ¥ç©å®¶ ${nextPlayer}...`);

                    // æ£€æŸ¥è¯¥ç©å®¶æ˜¯å¦pass
                    const playerPlay = playersAfter.find(p => p.player === nextPlayer);
                    // ä¿®å¤ï¼šæ£€æŸ¥actionæ˜¯å¦ä¸ºpassï¼Œæˆ–è€…cardsä¸ºç©ºæ•°ç»„
                    if (!playerPlay || (!playerPlay.action && playerPlay.cards && playerPlay.cards.length > 0)) {
                        console.log(`[shouldClearTable] ç©å®¶ ${nextPlayer} æ²¡æœ‰passæˆ–å‡ºäº†ç‰Œï¼Œä¸æ¸…æ¡Œ`);
                        return false; // è¯¥ç©å®¶æ²¡æœ‰passæˆ–å‡ºäº†ç‰Œ
                    } else {
                        console.log(`[shouldClearTable] ç©å®¶ ${nextPlayer} å·²pass`);
                    }
                }

                console.log(`[shouldClearTable] æ‰€æœ‰ç©å®¶éƒ½passï¼Œæ¸…ç†æ¡Œé¢`);
                return true;
            }

            // è·å–æœ€åå‡ºç‰Œçš„ç©å®¶
            getLastPlayPlayer() {
                for (let i = this.currentRoundCards.length - 1; i >= 0; i--) {
                    const play = this.currentRoundCards[i];
                    if (play.cards && play.cards.length > 0) {
                        return play.player;
                    }
                }
                return null;
            }

            aiAutoPlay() {
                if (this.gameState !== 'playing') return;

                // æ¸…é™¤æ€è€ƒçŠ¶æ€
                this.clearAIThinking(this.currentPlayer);

                const aiPlayer = this.players[this.currentPlayer];
                console.log(`\n[AIå†³ç­–] === ${this.currentPlayer} è½®åˆ°æˆ‘ ===`);
                console.log(`æ‰‹ç‰Œ: ${aiPlayer.cards.length}å¼ `);

                // è·å–å½“å‰æ¡Œé¢ä¸Šæœ€å¤§çš„ç‰Œï¼ˆä¸æ˜¯ä¸Šä¸€æ‰‹ç‰Œï¼‰
                let currentMaxPlay = null;
                if (this.currentRoundCards.length > 0) {
                    // éå†æ‰€æœ‰å‡ºç‰Œï¼Œæ‰¾åˆ°æœ€å¤§çš„
                    let maxPlay = null;
                    let maxWeight = -1;

                    for (let play of this.currentRoundCards) {
                        if (play.cards && play.cards.length > 0) {
                            const playType = play.cardType || this.getCardType(play.cards);
                            if (playType && playType.weight > maxWeight) {
                                maxWeight = playType.weight;
                                maxPlay = {
                                    cards: play.cards,
                                    type: playType,
                                    player: play.player
                                };
                            }
                        }
                    }
                    currentMaxPlay = maxPlay;

                    if (currentMaxPlay) {
                        console.log(`[AI] å½“å‰æ¡Œé¢æœ€å¤§ç‰Œ: ${currentMaxPlay.player}çš„${currentMaxPlay.cards.map(c => c.rank + c.suit).join(',')}, æƒé‡: ${currentMaxPlay.type.weight}`);
                    }
                }

                // å¦‚æœæ²¡æœ‰æ¡Œé¢ä¸Šçš„ç‰Œï¼ŒAIå¯ä»¥ä¸»åŠ¨å‡ºç‰Œ
                if (!currentMaxPlay) {
                    // ä¼˜å…ˆé€‰æ‹©å•ç‰Œ
                    if (aiPlayer.cards.length > 0) {
                        // é€‰æ‹©æœ€å°çš„å•ç‰Œ
                        const minCard = aiPlayer.cards.reduce((min, card) => {
                            return this.getRankValue(card.rank) < this.getRankValue(min.rank) ? card : min;
                        });

                        // å‡ºå•ç‰Œ
                        aiPlayer.cards.splice(aiPlayer.cards.indexOf(minCard), 1);

                        // éªŒè¯å‡ºç‰Œåˆæ³•æ€§
                        const validation = this.rules.validatePlay([minCard], null, aiPlayer.cards);
                        if (validation.valid) {
                            // æ›´æ–°è®°ç‰Œç³»ç»Ÿ
                            this.updateCardMemory(this.currentPlayer, [minCard]);

                            // æ·»åŠ åˆ°å½“å‰è½®æ¬¡
                            this.currentRoundCards.push({
                                player: this.currentPlayer,
                                cards: [minCard],
                                cardType: validation.type,
                                timestamp: Date.now()
                            });

                            // è®°å½•æœ¬è½®å‡ºç‰Œçš„ç©å®¶
                            this.roundPlayers.add(this.currentPlayer);

                            // æ’­æ”¾éŸ³æ•ˆ
                            const cardType = validation.type;
                            if (cardType && cardType.type === 'bomb') {
                                this.playSound('bomb');
                            } else {
                                this.playSound('play');
                            }
                        }
                    }
                } else {
                    // éœ€è¦æ ¹æ®ä¸Šä¸€æ‰‹ç‰Œå‡ºç‰Œ - ä½¿ç”¨æ›´æ™ºèƒ½çš„é€»è¾‘
                    let canPlay = false;

                    // é¦–å…ˆå°è¯•æ‰¾åˆ°æ‰€æœ‰å¯èƒ½çš„å‡ºç‰Œ
                    const possiblePlays = this.findAllPossiblePlays(aiPlayer.cards, currentMaxPlay);

                    console.log(`AI ${this.currentPlayer} è°ƒè¯•ä¿¡æ¯:`);
                    console.log(`  - æ‰‹ç‰Œ: ${aiPlayer.cards.map(c => c.rank).join(', ')}`);
                    console.log(`  - å½“å‰æœ€å¤§ç‰Œ: ${currentMaxPlay ? currentMaxPlay.cards.map(c => c.rank).join(', ') : 'æ— '} (æ¥è‡ª${currentMaxPlay ? currentMaxPlay.player : 'æ— '})`);
                    console.log(`  - æ‰¾åˆ°å¯èƒ½çš„å‡ºç‰Œ: ${possiblePlays.length} ä¸ª`);

                    if (possiblePlays.length > 0) {
                        // é€‰æ‹©æœ€å°çš„åˆæ³•å‡ºç‰Œï¼ˆèŠ‚çœå¤§ç‰Œï¼‰
                        const selectedPlay = possiblePlays[0];

                        // ç§»é™¤å‡ºçš„ç‰Œ - ä½¿ç”¨å”¯ä¸€IDæ¥ç¡®ä¿ç§»é™¤æ­£ç¡®çš„ç‰Œ
                        selectedPlay.cards.forEach(card => {
                            // ä¼˜å…ˆä½¿ç”¨å”¯ä¸€IDæŸ¥æ‰¾
                            let index = -1;
                            if (card.id) {
                                index = aiPlayer.cards.findIndex(c => c.id === card.id);
                            }

                            // å¦‚æœæ²¡æœ‰IDï¼ˆå…¼å®¹æ—§æ•°æ®ï¼‰ï¼Œä½¿ç”¨suitå’Œrank
                            if (index === -1) {
                                index = aiPlayer.cards.findIndex(c =>
                                    c.suit === card.suit && c.rank === card.rank
                                );
                            }

                            if (index !== -1) {
                                console.log(`[AIå‡ºç‰Œ] ç§»é™¤ç‰Œ: ${card.rank}${card.suit} (ID: ${card.id || 'æœªçŸ¥'})`);
                                aiPlayer.cards.splice(index, 1);
                            } else {
                                console.error(`[AIå‡ºç‰Œé”™è¯¯] æ‰¾ä¸åˆ°è¦ç§»é™¤çš„ç‰Œ: ${card.rank}${card.suit}`);
                            }
                        });

                        // æ›´æ–°è®°ç‰Œç³»ç»Ÿ
                        this.updateCardMemory(this.currentPlayer, selectedPlay.cards);

                        // æ·»åŠ åˆ°å½“å‰è½®æ¬¡
                        this.currentRoundCards.push({
                            player: this.currentPlayer,
                            cards: selectedPlay.cards,
                            cardType: selectedPlay.type,
                            timestamp: Date.now()
                        });

                        // è®°å½•æœ¬è½®å‡ºç‰Œçš„ç©å®¶
                        this.roundPlayers.add(this.currentPlayer);

                        // æ’­æ”¾éŸ³æ•ˆ
                        if (selectedPlay.type && selectedPlay.type.type === 'bomb') {
                            this.playSound('bomb');
                        } else {
                            this.playSound('play');
                        }

                        canPlay = true;
                        console.log(`AI ${this.currentPlayer} å‡ºç‰Œ: ${selectedPlay.cards.map(c => c.rank + c.suit).join(', ')}`);
                    }

                    if (!canPlay) {
                        // AIé€‰æ‹©ä¸è¦
                        this.currentRoundCards.push({
                            player: this.currentPlayer,
                            cards: [],
                            timestamp: Date.now(),
                            action: 'pass'
                        });

                        // æ·»åŠ åˆ°å·²è¿‡ç‰Œç©å®¶é›†åˆ
                        this.roundPassedPlayers.add(this.currentPlayer);
                        console.log(`[è½®æ¬¡] AI ${this.currentPlayer} è¿‡ç‰Œï¼Œæœ¬å›åˆæ°¸ä¹…å¤±å»å‡ºç‰Œæƒ`);

                        // æ’­æ”¾è¿‡ç‰ŒéŸ³æ•ˆ
                        this.playSound('pass');

                        console.log(`AI ${this.currentPlayer} é€‰æ‹©è¿‡ç‰Œ`);
                    }
                }

                this.switchToNextPlayer();
                this.updateUI();
                console.log(`${this.currentPlayer} è½®è½¬å®Œæˆ`);

                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                if (this.checkGameEnd()) {
                    return;
                }

              }

            // ç»Ÿä¸€å¤„ç†è½®æ¬¡ç»“æŸé€»è¾‘
            processRoundEnd() {
                console.log('[è½®æ¬¡ç»“æŸ] æ¸…ç†æ¡Œé¢');

                // è·å–æœ€åå‡ºç‰Œçš„ç©å®¶ï¼Œä»–å°†è·å¾—ä¸‹ä¸€è½®çš„é¦–å‡ºæƒ
                const lastPlayer = this.getLastPlayPlayer();

                // æ¸…ç†æ¡Œé¢
                this.currentRoundCards = [];
                this.lastPlayer = null;

                // æ¸…ç†è¿‡ç‰Œè®°å½•ï¼Œå¼€å§‹æ–°ä¸€è½®
                this.roundPassedPlayers.clear();
                this.roundPlayers.clear();

                // æ›´æ–°å‡ºç‰ŒåŒºåŸŸæ˜¾ç¤º
                const plays = ['northPlays', 'eastPlays', 'southPlays', 'westPlays'];
                plays.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) element.innerHTML = '';
                });

                // è®¾ç½®ä¸‹ä¸€è½®çš„é¦–å‡ºç©å®¶
                if (lastPlayer) {
                    this.currentPlayer = lastPlayer;
                    console.log(`[æ–°è½®] ${lastPlayer} è·å¾—é¦–å‡ºæƒ`);

                    // å¦‚æœæ˜¯AIç©å®¶ï¼Œç»™æ€è€ƒæ—¶é—´åè‡ªåŠ¨å‡ºç‰Œ
                    if (this.players[this.currentPlayer].isAI) {
                        const thinkingTime = this.getRandomThinkingTime();
                        this.showAIThinking(this.currentPlayer);
                        setTimeout(() => this.aiAutoPlay(), thinkingTime);
                    }
                } else {
                    // å¦‚æœæ‰¾ä¸åˆ°æœ€åå‡ºç‰Œçš„ç©å®¶ï¼Œä¿æŒå½“å‰ç©å®¶
                    console.log(`[æ–°è½®] ä¿æŒå½“å‰ç©å®¶: ${this.currentPlayer}`);
                }
            }

            // æ£€æŸ¥æ˜¯å¦æœ‰ç©å®¶å®Œæˆæ¸¸æˆï¼ˆæ‰‹ç‰Œä¸º0ï¼‰
            checkGameEnd() {
                // æ£€æŸ¥æ˜¯å¦æœ‰ç©å®¶æ‰‹ç‰Œä¸º0
                for (let position in this.players) {
                    if (this.players[position].cards.length === 0) {
                        // è®°å½•å®Œæˆæ¸¸æˆçš„ç©å®¶
                        if (!this.finishedPlayers.includes(position)) {
                            this.finishedPlayers.push(position);
                            console.log(`${position} å®Œæˆæ¸¸æˆï¼Œå½“å‰æ’å: ${this.finishedPlayers.join(', ')}`);
                        }
                    }
                }

                // æ£€æŸ¥æ˜¯å¦å¤´æ¸¸äº§ç”Ÿï¼ˆç¬¬ä¸€ä¸ªå®Œæˆçš„äººï¼‰
                if (this.finishedPlayers.length === 1 && !this.gameEnded) {
                    const firstPlace = this.finishedPlayers[0];
                    console.log(`${firstPlace} è·å¾—å¤´æ¸¸ï¼`);
                    this.showMessage(`${this.players[firstPlace].name} è·å¾—å¤´æ¸¸ï¼`, 'info');

                    // å¤´æ¸¸äº§ç”Ÿåï¼Œç»§ç»­æ¸¸æˆç›´åˆ°ç¡®å®šäºŒæ¸¸
                    return false;
                }

                // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ç©å®¶éƒ½å®Œæˆæ¸¸æˆ
                if (this.finishedPlayers.length === 4) {
                    console.log('æ‰€æœ‰ç©å®¶å®Œæˆæ¸¸æˆï¼Œæ¸¸æˆç»“æŸï¼');
                    this.gameEnded = true;
                    this.endGame();
                    return true;
                }

                return false;
            }

            // æ¸¸æˆç»“æŸå¤„ç†
            endGame() {
                this.gameState = 'ended';

                // ç¡®å®šæœ€ç»ˆæ’å
                this.gameRankings = [...this.finishedPlayers]; // [å¤´æ¸¸, äºŒæ¸¸, ä¸‰æ¸¸, æœ«æ¸¸]

                // åˆ¤å®šèƒœè´Ÿ
                const result = this.determineGameResult();

                // æ˜¾ç¤ºç»“æœ
                this.showGameResult(result);

                // è¯¢é—®æ˜¯å¦å¼€å§‹æ–°æ¸¸æˆ
                setTimeout(() => {
                    if (confirm(`æ¸¸æˆç»“æŸï¼\n${result.description}\næ˜¯å¦å¼€å§‹æ–°çš„ä¸€å±€ï¼Ÿ`)) {
                        this.startNewGame();
                    }
                }, 2000);
            }

            // åˆ¤å®šæ¸¸æˆç»“æœ
            determineGameResult() {
                const [first, second, third, fourth] = this.gameRankings;

                // ç¡®å®šé˜Ÿä¼
                const firstTeam = this.players[first].team;
                const secondTeam = this.players[second].team;

                // åˆ¤å®šèƒœè´Ÿ
                if (firstTeam === secondTeam) {
                    // å¤´æ¸¸å’ŒäºŒæ¸¸åŒé˜Ÿ
                    const winnerTeam = firstTeam === 'A' ? 'å·±æ–¹ï¼ˆAé˜Ÿï¼‰' : 'å¯¹æ–¹ï¼ˆBé˜Ÿï¼‰';
                    const levelsUp = 3;
                    return {
                        winner: winnerTeam,
                        type: 'å¤´æ¸¸+äºŒæ¸¸',
                        levelsUp: levelsUp,
                        description: `${winnerTeam}è·èƒœï¼\nå¤´æ¸¸+äºŒæ¸¸ï¼Œå‡${levelsUp}çº§`,
                        rankings: this.gameRankings
                    };
                } else {
                    // æ‰¾å‡ºä¸‰æ¸¸çš„é˜Ÿä¼
                    const thirdTeam = this.players[third].team;
                    if (firstTeam === thirdTeam) {
                        // å¤´æ¸¸å’Œä¸‰æ¸¸åŒé˜Ÿ
                        const winnerTeam = firstTeam === 'A' ? 'å·±æ–¹ï¼ˆAé˜Ÿï¼‰' : 'å¯¹æ–¹ï¼ˆBé˜Ÿï¼‰';
                        const levelsUp = 2;
                        return {
                            winner: winnerTeam,
                            type: 'å¤´æ¸¸+ä¸‰æ¸¸',
                            levelsUp: levelsUp,
                            description: `${winnerTeam}è·èƒœï¼\nå¤´æ¸¸+ä¸‰æ¸¸ï¼Œå‡${levelsUp}çº§`,
                            rankings: this.gameRankings
                        };
                    } else {
                        // å¤´æ¸¸å’Œæœ«æ¸¸åŒé˜Ÿ
                        const winnerTeam = firstTeam === 'A' ? 'å·±æ–¹ï¼ˆAé˜Ÿï¼‰' : 'å¯¹æ–¹ï¼ˆBé˜Ÿï¼‰';
                        const levelsUp = 1;
                        return {
                            winner: winnerTeam,
                            type: 'å¤´æ¸¸+æœ«æ¸¸',
                            levelsUp: levelsUp,
                            description: `${winnerTeam}è·èƒœï¼\nå¤´æ¸¸+æœ«æ¸¸ï¼Œå‡${levelsUp}çº§`,
                            rankings: this.gameRankings
                        };
                    }
                }
            }

            // æ˜¾ç¤ºæ¸¸æˆç»“æœ
            showGameResult(result) {
                const rankings = result.rankings.map((pos, index) => {
                    const rankNames = ['å¤´æ¸¸', 'äºŒæ¸¸', 'ä¸‰æ¸¸', 'æœ«æ¸¸'];
                    return `${rankNames[index]}: ${this.players[pos].name}`;
                }).join('\n');

                console.log('=== æ¸¸æˆç»“æœ ===');
                console.log(rankings);
                console.log(result.description);
                console.log('================');

                // åº”ç”¨å‡çº§ç»“æœ
                this.applyLevelChange(result);
            }

            // åº”ç”¨å‡çº§ç»“æœ
            applyLevelChange(result) {
                // æ ¹æ®èƒœè´Ÿç»“æœæ›´æ–°å½“å‰çº§æ•°
                const winnerTeam = result.winner.includes('å·±æ–¹') ? 'A' : 'B';

                // è·å–èƒœæ–¹çš„å½“å‰çº§æ•°
                const currentTeamLevel = winnerTeam === 'A' ? this.teamAScore : this.teamBScore;
                const newLevel = currentTeamLevel + result.levelsUp;

                // æ›´æ–°èƒœæ–¹çº§æ•°
                if (winnerTeam === 'A') {
                    this.teamAScore = newLevel;
                } else {
                    this.teamBScore = newLevel;
                }

                // å…¨å±€å½“å‰çº§æ•°å–ä¸¤ä¸ªé˜Ÿä¼çº§æ•°çš„è¾ƒå¤§å€¼
                this.currentLevel = Math.max(this.teamAScore, this.teamBScore);

                // æ›´æ–°è§„åˆ™å¼•æ“çš„çº§æ•°
                if (this.ruleEngine) {
                    this.ruleEngine.setLevel(this.currentLevel);
                }

                // ä¸‹ä¸€å±€é¦–å‡ºç©å®¶æ˜¯æœ«æ¸¸
                this.lastGameLoser = this.gameRankings[3]; // æœ«æ¸¸

                console.log(`[å‡çº§] ${result.winner}ä»${currentTeamLevel}çº§å‡åˆ°${newLevel}çº§`);
                console.log(`[é¦–å‡º] ä¸‹ä¸€å±€ç”±${this.players[this.lastGameLoser].name}å…ˆå‡ºç‰Œ`);
            }

            // æ£€æŸ¥æ˜¯å¦å¼€å§‹æ–°è½®æ¬¡
            checkNewRound() {
                if (this.currentRoundCards.length === 0) return false;

                // åªè€ƒè™‘æœ€è¿‘çš„æ“ä½œï¼ˆé¿å…æ•°ç»„è¿‡é•¿ï¼‰
                const recentCards = this.currentRoundCards.slice(-8);
                const currentRoundPlays = recentCards.filter(play => play.action !== 'pass');
                const passActions = recentCards.filter(play => play.action === 'pass');

                // æƒ…å†µ1ï¼šè¿ç»­ä¸‰å®¶pass
                if (passActions.length >= 3) {
                    return true;
                }

                // æƒ…å†µ2ï¼šä¸€è½®ç»“æŸï¼ˆå››å®¶éƒ½å‡ºè¿‡ç‰Œï¼Œä¸”æœ€åä¸€å®¶æ˜¯èµ¢å®¶ï¼‰
                const uniquePlayers = new Set(recentCards.map(play => play.player));
                if (uniquePlayers.size === 4) {
                    // æ£€æŸ¥æ˜¯å¦å›åˆ°èµ·å§‹ç©å®¶æˆ–æœ€åå‡ºç‰Œè€…
                    const lastPlay = recentCards[recentCards.length - 1];
                    if (lastPlay && lastPlay.cards.length > 0) {
                        return true;
                    }
                }

                // æƒ…å†µ3ï¼šå½“å‰è½®æ¬¡æœ‰æœ‰æ•ˆå‡ºç‰Œï¼Œä¸”è½®åˆ°èµ·å§‹ç©å®¶
                if (currentRoundPlays.length > 0 && this.currentPlayer === this.getFirstPlayerOfRound()) {
                    return true;
                }

                return false;
            }

            // è·å–å½“å‰è½®æ¬¡çš„èµ·å§‹ç©å®¶
            getFirstPlayerOfRound() {
                if (this.currentRoundCards.length === 0) return this.currentPlayer;

                // æ‰¾åˆ°ç¬¬ä¸€ä¸ªépassçš„ç©å®¶
                for (let play of this.currentRoundCards) {
                    if (play.action !== 'pass' && play.cards.length > 0) {
                        return play.player;
                    }
                }
                return this.currentPlayer;
            }

            // å¼€å§‹æ–°ä¸€è½®ï¼ˆæ¸…é™¤ä¹‹å‰çš„å‡ºç‰Œï¼Œå¹¶æ£€æŸ¥AIç»§ç»­ï¼‰
            startNewRound() {
                this.currentRoundCards = [];
                this.lastPlayer = null;
                this.updatePlayArea();
            }

            // å¼€å§‹æ–°æ¸¸æˆ
            startNewGame() {
                this.isFirstGame = false;
                this.currentRoundCards = [];
                this.lastPlayer = null;
                this.selectedCards = [];
                this.lastPlay = null;

                // é‡ç½®æ¸¸æˆç»“æŸç›¸å…³å˜é‡
                this.gameRankings = [];
                this.gameEnded = false;
                this.finishedPlayers = [];

                // æ¸…ç©ºæ‰€æœ‰ç©å®¶æ‰‹ç‰Œ
                for (let pos in this.players) {
                    this.players[pos].cards = [];
                }

                // é‡æ–°åˆå§‹åŒ–æ¸¸æˆ
                this.initializeGame();
            }

            // è¾…åŠ©å‡½æ•°ï¼šæŒ‰ç‚¹æ•°åˆ†ç»„
            groupCardsByRank(cards) {
                const groups = {};
                cards.forEach(card => {
                    if (!groups[card.rank]) {
                        groups[card.rank] = [];
                    }
                    groups[card.rank].push(card);
                });
                return groups;
            }

            // è¾…åŠ©å‡½æ•°ï¼šè·å–ç‰Œé¢å€¼å¤§å°
            getRankValue(rank) {
                // æ¼è›‹è§„åˆ™ï¼šA > K > Q > J > 10 > 9 > 8 > 7 > 6 > 5 > 4 > 3 > 2
                const rankOrder = {
                    '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
                    'J': 11, 'Q': 12, 'K': 13, 'A': 14, 'å°ç‹': 102, 'å¤§ç‹': 103
                };
                return rankOrder[rank] || 0;
            }

            // æ›´æ–°è®°ç‰Œç³»ç»Ÿ
            updateCardMemory(player, cards) {
                // è®°å½•æ¯ä¸ªç©å®¶å‡ºçš„ç‰Œ
                this.cardMemory[player].push(...cards);

                // è®°å½•æ‰€æœ‰å·²å‡ºçš„ç‰Œ
                this.playedCards.push(...cards);
            }

            // AIæ™ºèƒ½åˆ†æå‰©ä½™ç‰Œ
            analyzeRemainingCards(player) {
                const remainingCards = this.players[player].cards;
                const analysis = {
                    singles: [],
                    pairs: [],
                    triples: [],
                    bombs: [],
                    totalCards: remainingCards.length
                };

                // æŒ‰ç‚¹æ•°åˆ†ç»„
                const rankGroups = {};
                remainingCards.forEach(card => {
                    if (!rankGroups[card.rank]) {
                        rankGroups[card.rank] = [];
                    }
                    rankGroups[card.rank].push(card);
                });

                // åˆ†æç‰Œå‹
                for (let rank in rankGroups) {
                    const group = rankGroups[rank];
                    if (group.length === 1) {
                        analysis.singles.push(group[0]);
                    } else if (group.length === 2) {
                        analysis.pairs.push(group);
                    } else if (group.length === 3) {
                        analysis.triples.push(group);
                    } else if (group.length >= 4) {
                        analysis.bombs.push(group);
                    }
                }

                return analysis;
            }

            // AIæ™ºèƒ½å†³ç­–
            makeAIDecision(player) {
                const analysis = this.analyzeRemainingCards(this.currentPlayer);
                const partner = this.getPartner(this.currentPlayer);

                // ç®€å•ç­–ç•¥1ï¼šå¦‚æœåªå‰©ä¸€å¼ ç‰Œï¼Œç›´æ¥å‡º
                if (analysis.totalCards === 1) {
                    return {
                        action: 'play',
                        cards: [analysis.singles[0]]
                    };
                }

                // ç®€å•ç­–ç•¥2ï¼šå¦‚æœæ˜¯è‡ªç”±å‡ºç‰Œï¼Œå‡ºæœ€å°çš„å•å¼ 
                if (!this.roundActive || !this.lastPlay) {
                    if (analysis.singles.length > 0) {
                        // æ‰¾æœ€å°çš„å•å¼ 
                        analysis.singles.sort((a, b) => this.getRankValue(a.rank) - this.getRankValue(b.rank));
                        return {
                            action: 'play',
                            cards: [analysis.singles[0]]
                        };
                    }
                }

                // ç®€å•ç­–ç•¥3ï¼šå°è¯•æ‰“è¿‡å¯¹æ‰‹
                const validPlay = this.findValidPlay(this.players[player].cards, this.lastPlay);
                if (validPlay) {
                    return {
                        action: 'play',
                        cards: validPlay
                    };
                }

                // é»˜è®¤ç­–ç•¥ï¼šè¿‡ç‰Œ
                return {
                    action: 'pass'
                };
            }

            // è·å–é˜Ÿå‹
            getPartner(player) {
                const partnerships = {
                    'south': 'north',
                    'north': 'south',
                    'east': 'west',
                    'west': 'east'
                };
                return partnerships[player];
            }

            // æŸ¥æ‰¾åˆæ³•å‡ºç‰Œ
            findValidPlay(handCards, lastPlay) {
                if (!lastPlay || !lastPlay.cards) return null;

                const possiblePlays = [];

                // å°è¯•æ‰€æœ‰å¯èƒ½çš„å‡ºç‰Œç»„åˆ
                // 1. å•å¼ 
                for (let card of handCards) {
                    if (this.ruleEngine.canBeat([card], lastPlay.cards)) {
                        possiblePlays.push([card]);
                    }
                }

                // 2. å¯¹å­
                const pairs = this.findPairs(handCards);
                for (let pair of pairs) {
                    if (this.ruleEngine.canBeat(pair, lastPlay.cards)) {
                        possiblePlays.push(pair);
                    }
                }

                // 3. ä¸‰å¼ 
                const triples = this.findTriples(handCards);
                for (let triple of triples) {
                    if (this.ruleEngine.canBeat(triple, lastPlay.cards)) {
                        possiblePlays.push(triple);
                    }
                }

                // 4. ç‚¸å¼¹
                const bombs = this.findBombs(handCards);
                for (let bomb of bombs) {
                    if (this.ruleEngine.canBeat(bomb, lastPlay.cards)) {
                        possiblePlays.push(bomb);
                    }
                }

                // è¿”å›æœ€å°çš„åˆæ³•å‡ºç‰Œ
                if (possiblePlays.length > 0) {
                    // ç®€å•é€‰æ‹©ç¬¬ä¸€ä¸ªï¼Œå®é™…åº”è¯¥é€‰æ‹©æœ€ä¼˜ç­–ç•¥
                    return possiblePlays[0];
                }

                return null;
            }

            // æŸ¥æ‰¾å¯¹å­
            findPairs(cards) {
                const rankGroups = {};
                const pairs = [];

                // æŒ‰ç‚¹æ•°åˆ†ç»„
                cards.forEach(card => {
                    if (!rankGroups[card.rank]) {
                        rankGroups[card.rank] = [];
                    }
                    rankGroups[card.rank].push(card);
                });

                // æå–å¯¹å­
                for (let rank in rankGroups) {
                    const group = rankGroups[rank];
                    if (group.length >= 2) {
                        pairs.push([group[0], group[1]]);
                    }
                }

                return pairs;
            }

            // æŸ¥æ‰¾ä¸‰å¼ 
            findTriples(cards) {
                const rankGroups = {};
                const triples = [];

                // æŒ‰ç‚¹æ•°åˆ†ç»„
                cards.forEach(card => {
                    if (!rankGroups[card.rank]) {
                        rankGroups[card.rank] = [];
                    }
                    rankGroups[card.rank].push(card);
                });

                // æå–ä¸‰å¼ 
                for (let rank in rankGroups) {
                    const group = rankGroups[rank];
                    if (group.length >= 3) {
                        triples.push([group[0], group[1], group[2]]);
                    }
                }

                return triples;
            }

            // æŸ¥æ‰¾ç‚¸å¼¹
            findBombs(cards) {
                const rankGroups = {};
                const bombs = [];

                // æŒ‰ç‚¹æ•°åˆ†ç»„
                cards.forEach(card => {
                    if (!rankGroups[card.rank]) {
                        rankGroups[card.rank] = [];
                    }
                    rankGroups[card.rank].push(card);
                });

                // æå–ç‚¸å¼¹ï¼ˆ4å¼ åŠä»¥ä¸Šï¼‰
                for (let rank in rankGroups) {
                    const group = rankGroups[rank];
                    if (group.length >= 4) {
                        bombs.push(group);
                    }
                }

                // æ£€æŸ¥å¤©ç‹ç‚¸å¼¹
                const jokers = cards.filter(c => c.suit === 'joker');
                if (jokers.length === 4) {
                    bombs.push(jokers);
                }

                return bombs;
            }

            // åˆå§‹åŒ–éŸ³é¢‘ï¼ˆåœ¨ç”¨æˆ·é¦–æ¬¡äº¤äº’æ—¶è°ƒç”¨ï¼‰
            initAudio() {
                if (!this.audioContext) {
                    try {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        if (this.audioContext.state === 'suspended') {
                            this.audioContext.resume();
                        }
                    } catch (error) {
                        console.log('éŸ³é¢‘åˆå§‹åŒ–å¤±è´¥');
                    }
                }
            }

            // è·å–éšæœºæ€è€ƒæ—¶é—´
            getRandomThinkingTime() {
                // ä¸åŒçš„æ€è€ƒæ—¶é—´èŒƒå›´
                const baseTime = 1500; // åŸºç¡€æ€è€ƒæ—¶é—´1.5ç§’
                const variation = Math.random() * 2000; // éšæœºå˜åŒ–0-2ç§’

                // ç¬¬ä¸€æ¬¡å‡ºç‰Œæ—¶æ€è€ƒæ›´ä¹…
                const isFirstPlay = this.currentRoundCards.length === 0 ||
                    this.currentRoundCards.every(play => play.cards.length === 0);
                const extraTime = isFirstPlay ? 1000 : 0;

                return baseTime + variation + extraTime;
            }

            // æ˜¾ç¤ºAIæ€è€ƒçŠ¶æ€
            showAIThinking(player) {
                const positions = {
                    'west': 'è¥¿å®¶AI',
                    'north': 'åŒ—å®¶AI',
                    'east': 'ä¸œå®¶AI'
                };

                // åœ¨å¯¹åº”ç©å®¶ä½ç½®æ˜¾ç¤ºæ€è€ƒåŠ¨ç”»
                const positionElement = document.getElementById(player + 'Hand');
                if (positionElement) {
                    positionElement.classList.add('thinking');
                }

                // æ˜¾ç¤ºæ€è€ƒæç¤º
                this.showMessage(`${positions[player]}æ­£åœ¨æ€è€ƒ...`, 'info');
            }

            // æ¸…é™¤AIæ€è€ƒçŠ¶æ€
            clearAIThinking(player) {
                const positionElement = document.getElementById(player + 'Hand');
                if (positionElement) {
                    positionElement.classList.remove('thinking');
                }
            }

            // æ’­æ”¾éŸ³æ•ˆ
            playSound(soundType) {
                // å¦‚æœéŸ³é¢‘ä¸Šä¸‹æ–‡æœªå¯åŠ¨ï¼Œåˆ™ä¸æ’­æ”¾
                if (!this.audioContext) {
                    this.initAudio();
                    if (!this.audioContext || this.audioContext.state === 'suspended') {
                        return;
                    }
                }

                // æ’­æ”¾ç®€å•çš„éŸ³æ•ˆ
                try {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);

                    // æ ¹æ®éŸ³æ•ˆç±»å‹è®¾ç½®ä¸åŒçš„é¢‘ç‡å’Œæ¨¡å¼
                    switch(soundType) {
                        case 'play':
                            oscillator.frequency.value = 800;
                            gainNode.gain.value = 0.1;
                            oscillator.start();
                            oscillator.stop(this.audioContext.currentTime + 0.1);
                            break;
                        case 'pass':
                            oscillator.frequency.value = 300;
                            gainNode.gain.value = 0.05;
                            oscillator.start();
                            oscillator.stop(this.audioContext.currentTime + 0.2);
                            break;
                        case 'bomb':
                            oscillator.frequency.value = 1200;
                            gainNode.gain.value = 0.2;
                            oscillator.start();
                            oscillator.stop(this.audioContext.currentTime + 0.3);
                            break;
                        case 'win':
                            // æ’­æ”¾ä¸Šå‡éŸ³è°ƒ
                            oscillator.frequency.setValueAtTime(400, this.audioContext.currentTime);
                            oscillator.frequency.exponentialRampToValueAtTime(1600, this.audioContext.currentTime + 0.5);
                            gainNode.gain.value = 0.15;
                            oscillator.start();
                            oscillator.stop(this.audioContext.currentTime + 0.5);
                            break;
                        case 'levelup':
                            // æ’­æ”¾è¿ç»­çš„éŸ³è°ƒ
                            for (let i = 0; i < 3; i++) {
                                const osc = this.audioContext.createOscillator();
                                const gain = this.audioContext.createGain();
                                osc.connect(gain);
                                gain.connect(this.audioContext.destination);
                                osc.frequency.value = 600 + i * 200;
                                gain.gain.value = 0.1;
                                osc.start(this.audioContext.currentTime + i * 0.1);
                                osc.stop(this.audioContext.currentTime + i * 0.1 + 0.1);
                            }
                            break;
                    }
                } catch (error) {
                    // é™é»˜å¤„ç†éŸ³æ•ˆé”™è¯¯
                    console.log('éŸ³æ•ˆæ’­æ”¾å¤±è´¥:', error);
                }
            }

            showHint() {
                this.showMessage('å»ºè®®ï¼šå‡ºå°ç‰Œæˆ–ä¿ç•™ç‚¸å¼¹åˆ°åæœŸä½¿ç”¨', 'info');
            }

            reportCards() {
                const southCards = this.players.south.cards;
                const message = `ä½ çš„æ‰‹ç‰Œï¼š${southCards.length}å¼ `;
                this.showMessage(message, 'info');
            }

            // æ‰¾åˆ°æ‰€æœ‰å¯èƒ½çš„å‡ºç‰Œ
            findAllPossiblePlays(handCards, lastPlay) {
                const possiblePlays = [];

                // å¦‚æœæ²¡æœ‰lastPlayæˆ–æ²¡æœ‰cardsï¼Œè¯´æ˜æ˜¯é¦–å‡º
                if (!lastPlay || !lastPlay.cards) {
                    // é¦–å‡ºæ—¶ï¼Œä¼˜å…ˆå‡ºå•å¼ å°ç‰Œ
                    // æ‰¾å‡ºæ‰€æœ‰å•å¼ 
                    const singles = [];
                    for (let card of handCards) {
                        const type = this.rules.getCardType([card]);
                        if (type) {
                            singles.push({
                                cards: [card],
                                type: type,
                                score: this.getRankValue(card.rank)
                            });
                        }
                    }
                    // æŒ‰ä»å°åˆ°å¤§æ’åº
                    singles.sort((a, b) => a.score - b.score);
                    return singles;
                }

                // è·å–ä¸Šå®¶ç‰Œå‹
                const lastType = this.rules.getCardType(lastPlay.cards);
                if (!lastType) return [];

                // ä½¿ç”¨è§„åˆ™å¼•æ“éªŒè¯å‡ºç‰Œ
                for (let card of handCards) {
                    const validation = this.rules.validatePlay([card], lastPlay, handCards);
                    if (validation.valid) {
                        possiblePlays.push({
                            cards: [card],
                            type: validation.type
                        });
                    }
                }

                // å°è¯•å¯¹å­ - è‡ªå·±æŸ¥æ‰¾
                const rankGroups = {};
                handCards.forEach(card => {
                    if (!rankGroups[card.rank]) {
                        rankGroups[card.rank] = [];
                    }
                    rankGroups[card.rank].push(card);
                });

                // æå–å¯¹å­
                for (let rank in rankGroups) {
                    const group = rankGroups[rank];
                    if (group.length >= 2) {
                        const pair = [group[0], group[1]];
                        const validation = this.rules.validatePlay(pair, lastPlay, handCards);
                        if (validation.valid) {
                            possiblePlays.push({
                                cards: pair,
                                type: validation.type
                            });
                        }
                    }
                }

                // å°è¯•ä¸‰å¼  - è‡ªå·±æŸ¥æ‰¾
                for (let rank in rankGroups) {
                    const group = rankGroups[rank];
                    if (group.length >= 3) {
                        const triple = [group[0], group[1], group[2]];
                        const validation = this.rules.validatePlay(triple, lastPlay, handCards);
                        if (validation.valid) {
                            possiblePlays.push({
                                cards: triple,
                                type: validation.type
                            });
                        }
                    }
                }

                // å°è¯•ä¸‰å¸¦äºŒ - è‡ªå·±æŸ¥æ‰¾
                for (let tripleRank in rankGroups) {
                    const tripleGroup = rankGroups[tripleRank];
                    if (tripleGroup.length >= 3) {
                        const triple = [tripleGroup[0], tripleGroup[1], tripleGroup[2]];

                        // æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„å¯¹å­
                        for (let pairRank in rankGroups) {
                            if (pairRank !== tripleRank && rankGroups[pairRank].length >= 2) {
                                const pairGroup = rankGroups[pairRank];
                                const pair = [pairGroup[0], pairGroup[1]];

                                // ç»„åˆæˆä¸‰å¸¦äºŒ
                                const tripleWithPair = [...triple, ...pair];
                                const validation = this.rules.validatePlay(tripleWithPair, lastPlay, handCards);
                                if (validation.valid) {
                                    possiblePlays.push({
                                        cards: tripleWithPair,
                                        type: validation.type
                                    });
                                }
                            }
                        }
                    }
                }

                // å°è¯•é¡ºå­ - è‡ªå·±æŸ¥æ‰¾ï¼ˆ5å¼ åŠä»¥ä¸Šè¿ç»­å•ç‰Œï¼‰
                // é¦–å…ˆæ”¶é›†æ‰€æœ‰éç‹ç‰Œå’Œé2çš„ç‰Œ
                const nonJokerCards = handCards.filter(c =>
                    c.suit !== 'joker' &&
                    c.rank !== '2' &&
                    c.rank !== 'å°ç‹' &&
                    c.rank !== 'å¤§ç‹'
                );

                // æŒ‰ç‚¹æ•°æ’åº
                nonJokerCards.sort((a, b) => this.getRankValue(a.rank) - this.getRankValue(b.rank));

                // æŸ¥æ‰¾å¯èƒ½çš„é¡ºå­
                for (let startIdx = 0; startIdx <= nonJokerCards.length - 5; startIdx++) {
                    for (let length = 5; length <= Math.min(nonJokerCards.length - startIdx, 12); length++) {
                        const straightCards = nonJokerCards.slice(startIdx, startIdx + length);

                        // æ£€æŸ¥æ˜¯å¦è¿ç»­
                        let isConsecutive = true;
                        for (let i = 1; i < straightCards.length; i++) {
                            const prevValue = this.getRankValue(straightCards[i-1].rank);
                            const currValue = this.getRankValue(straightCards[i].rank);
                            if (currValue !== prevValue + 1) {
                                isConsecutive = false;
                                break;
                            }
                        }

                        if (isConsecutive) {
                            const validation = this.rules.validatePlay(straightCards, lastPlay, handCards);
                            if (validation.valid) {
                                possiblePlays.push({
                                    cards: straightCards,
                                    type: validation.type
                                });
                            }
                        }
                    }
                }

                // å°è¯•è¿å¯¹ - è‡ªå·±æŸ¥æ‰¾ï¼ˆ3å¯¹åŠä»¥ä¸Šè¿ç»­å¯¹å­ï¼‰
                // é¦–å…ˆæ”¶é›†æ‰€æœ‰å¯ç”¨çš„å¯¹å­
                const availablePairs = [];
                for (let rank in rankGroups) {
                    if (rankGroups[rank].length >= 2) {
                        availablePairs.push({
                            rank: rank,
                            value: this.getRankValue(rank),
                            cards: [rankGroups[rank][0], rankGroups[rank][1]]
                        });
                    }
                }

                // æŒ‰ç‚¹æ•°æ’åº
                availablePairs.sort((a, b) => a.value - b.value);

                // æŸ¥æ‰¾è¿ç»­çš„å¯¹å­ç»„åˆ
                for (let startIdx = 0; startIdx <= availablePairs.length - 3; startIdx++) {
                    for (let length = 3; length <= availablePairs.length - startIdx; length++) {
                        const selectedPairs = availablePairs.slice(startIdx, startIdx + length);

                        // æ£€æŸ¥æ˜¯å¦è¿ç»­
                        let isConsecutive = true;
                        for (let i = 1; i < selectedPairs.length; i++) {
                            if (selectedPairs[i].value !== selectedPairs[i-1].value + 1) {
                                isConsecutive = false;
                                break;
                            }
                        }

                        if (isConsecutive) {
                            // ç»„åˆæ‰€æœ‰å¯¹å­çš„ç‰Œ
                            const pairStraightCards = [];
                            selectedPairs.forEach(pair => {
                                pairStraightCards.push(...pair.cards);
                            });

                            const validation = this.rules.validatePlay(pairStraightCards, lastPlay, handCards);
                            if (validation.valid) {
                                possiblePlays.push({
                                    cards: pairStraightCards,
                                    type: validation.type
                                });
                            }
                        }
                    }
                }

                // å°è¯•é’¢æ¿ - è‡ªå·±æŸ¥æ‰¾ï¼ˆ2ä¸ªåŠä»¥ä¸Šè¿ç»­ä¸‰å¼ ï¼‰
                // é¦–å…ˆæ”¶é›†æ‰€æœ‰å¯ç”¨çš„ä¸‰å¼ 
                const availableTriples = [];
                for (let rank in rankGroups) {
                    if (rankGroups[rank].length >= 3) {
                        availableTriples.push({
                            rank: rank,
                            value: this.getRankValue(rank),
                            cards: [rankGroups[rank][0], rankGroups[rank][1], rankGroups[rank][2]]
                        });
                    }
                }

                // æŒ‰ç‚¹æ•°æ’åº
                availableTriples.sort((a, b) => a.value - b.value);

                // æŸ¥æ‰¾è¿ç»­çš„ä¸‰å¼ ç»„åˆ
                for (let startIdx = 0; startIdx <= availableTriples.length - 2; startIdx++) {
                    for (let length = 2; length <= availableTriples.length - startIdx; length++) {
                        const selectedTriples = availableTriples.slice(startIdx, startIdx + length);

                        // æ£€æŸ¥æ˜¯å¦è¿ç»­
                        let isConsecutive = true;
                        for (let i = 1; i < selectedTriples.length; i++) {
                            if (selectedTriples[i].value !== selectedTriples[i-1].value + 1) {
                                isConsecutive = false;
                                break;
                            }
                        }

                        if (isConsecutive) {
                            // ç»„åˆæ‰€æœ‰ä¸‰å¼ çš„ç‰Œ
                            const tripleStraightCards = [];
                            selectedTriples.forEach(triple => {
                                tripleStraightCards.push(...triple.cards);
                            });

                            const validation = this.rules.validatePlay(tripleStraightCards, lastPlay, handCards);
                            if (validation.valid) {
                                possiblePlays.push({
                                    cards: tripleStraightCards,
                                    type: validation.type
                                });
                            }
                        }
                    }
                }

                // å°è¯•ç‚¸å¼¹ - è‡ªå·±æŸ¥æ‰¾
                for (let rank in rankGroups) {
                    const group = rankGroups[rank];
                    // å°è¯•4å¼ åˆ°8å¼ ç‚¸å¼¹
                    for (let bombCount = 4; bombCount <= Math.min(group.length, 8); bombCount++) {
                        const bomb = group.slice(0, bombCount);
                        console.log(`[AIç‚¸å¼¹] å°è¯•${bombCount}å¼ ${rank}: ${bomb.map(c => c.rank + c.suit).join(', ')}`);
                        const validation = this.rules.validatePlay(bomb, lastPlay, handCards);
                        if (validation.valid) {
                            possiblePlays.push({
                                cards: bomb,
                                type: validation.type
                            });
                            console.log(`[AIç‚¸å¼¹] âœ“ ${bombCount}å¼ ${rank}å¯ä»¥å‡º`);
                        } else {
                            console.log(`[AIç‚¸å¼¹] âœ— ${bombCount}å¼ ${rank}ä¸èƒ½å‡º: ${validation.message}`);
                        }
                    }
                }

                // å°è¯•åŒèŠ±é¡º - è‡ªå·±æŸ¥æ‰¾ï¼ˆ5å¼ ä»¥ä¸ŠåŒèŠ±è‰²è¿ç»­ç‰Œï¼‰
                // æŒ‰èŠ±è‰²åˆ†ç»„
                const suitGroups = {};
                handCards.forEach(card => {
                    if (card.suit !== 'joker' && card.rank !== '2' &&
                        card.rank !== 'å°ç‹' && card.rank !== 'å¤§ç‹') {
                        if (!suitGroups[card.suit]) {
                            suitGroups[card.suit] = [];
                        }
                        suitGroups[card.suit].push(card);
                    }
                });

                // æ¯ä¸ªèŠ±è‰²æŸ¥æ‰¾åŒèŠ±é¡º
                for (let suit in suitGroups) {
                    const suitCards = suitGroups[suit];
                    // æŒ‰ç‚¹æ•°æ’åº
                    suitCards.sort((a, b) => this.getRankValue(a.rank) - this.getRankValue(b.rank));

                    // æŸ¥æ‰¾å¯èƒ½çš„åŒèŠ±é¡º
                    for (let startIdx = 0; startIdx <= suitCards.length - 5; startIdx++) {
                        for (let length = 5; length <= Math.min(suitCards.length - startIdx, 12); length++) {
                            const straightFlushCards = suitCards.slice(startIdx, startIdx + length);

                            // æ£€æŸ¥æ˜¯å¦è¿ç»­
                            let isConsecutive = true;
                            for (let i = 1; i < straightFlushCards.length; i++) {
                                const prevValue = this.getRankValue(straightFlushCards[i-1].rank);
                                const currValue = this.getRankValue(straightFlushCards[i].rank);
                                if (currValue !== prevValue + 1) {
                                    isConsecutive = false;
                                    break;
                                }
                            }

                            if (isConsecutive) {
                                const validation = this.rules.validatePlay(straightFlushCards, lastPlay, handCards);
                                if (validation.valid) {
                                    possiblePlays.push({
                                        cards: straightFlushCards,
                                        type: validation.type
                                    });
                                }
                            }
                        }
                    }
                }

                // æ£€æŸ¥å¤©ç‹ç‚¸å¼¹
                const jokers = handCards.filter(c => c.suit === 'joker');
                if (jokers.length === 4) {
                    const validation = this.rules.validatePlay(jokers, lastPlay, handCards);
                    if (validation.valid) {
                        possiblePlays.push({
                            cards: jokers,
                            type: validation.type
                        });
                    }
                }

                // è¿‡æ»¤ï¼šåªä¿ç•™èƒ½æ‰“è¿‡ä¸Šå®¶çš„ç‰Œ
                const filteredPlays = possiblePlays.filter(play => {
                    // ç¡®ä¿typeå­˜åœ¨
                    if (!play || !play.type) {
                        return false;
                    }
                    const playType = play.type;

                    // ä½¿ç”¨è§„åˆ™å¼•æ“ç›´æ¥éªŒè¯
                    const validation = this.rules.validatePlay(play.cards, lastPlay, handCards);
                    return validation.valid;
                });

                // æ’åºï¼šä¼˜å…ˆçº§å°çš„åœ¨å‰ï¼ˆç‚¸å¼¹ä¼˜å…ˆçº§é«˜ä½†æœ€åç”¨ï¼‰
                const sortedPlays = filteredPlays.sort((a, b) => {
                    // ç¡®ä¿aå’Œbå­˜åœ¨
                    if (!a || !b) return 0;

                    // ç¡®ä¿typeå­˜åœ¨
                    const aType = a.type || {};
                    const bType = b.type || {};

                    // ç‚¸å¼¹ä¼˜å…ˆçº§ä½ï¼ˆå°½é‡ä¸ç”¨ï¼‰
                    if (aType.type === 'bomb' && bType.type !== 'bomb') return 1;
                    if (bType.type === 'bomb' && aType.type !== 'bomb') return -1;

                    // æ™®é€šç‰Œå‹æŒ‰å¤§å°æ’åº
                    return this.comparePlayValues(a, b);
                });

                // å¦‚æœæ˜¯é¦–å‡ºï¼Œè¿”å›æ‰€æœ‰å¯èƒ½ï¼›å¦‚æœæœ‰ä¸Šå®¶ä¸”filteredPlaysä¸ºç©ºï¼Œè¯´æ˜è¿‡ç‰Œ
                return sortedPlays;
            }

            // å°è¯•ç‚¸å¼¹
            tryBombs(handCards, possiblePlays, lastType, lastPlay) {
                const rankGroups = this.groupCardsByRank(handCards);

                // æ£€æŸ¥4å¼ ç‚¸å¼¹
                for (let [rank, cards] of Object.entries(rankGroups)) {
                    if (cards.length >= 4) {
                        const bombCards = cards.slice(0, 4);
                        // ä½¿ç”¨è§„åˆ™å¼•æ“è¯†åˆ«ç‚¸å¼¹
                        let bombType = null;
                        if (this.useAdvancedEngine && this.ruleEngine) {
                            bombType = this.ruleEngine.getCardType(bombCards);
                        } else {
                            bombType = this.getCardType(bombCards);
                        }

                        if (bombType && bombType.type === 'bomb') {
                            // å¦‚æœä¸Šå®¶ä¸æ˜¯ç‚¸å¼¹ï¼Œç‚¸å¼¹å¯ä»¥æ‰“ä»»ä½•ç‰Œ
                            if (lastType.type !== 'bomb') {
                                possiblePlays.push({
                                    cards: bombCards,
                                    type: bombType
                                });
                            } else {
                                // å¦‚æœä¸Šå®¶ä¹Ÿæ˜¯ç‚¸å¼¹ï¼Œæ¯”è¾ƒå¤§å°
                                let canBeat = false;
                                if (this.ruleEngine) {
                                    canBeat = this.ruleEngine.compareCardTypes(bombType, lastType) > 0;
                                } else {
                                    // ç®€å•æ¯”è¾ƒï¼šæ¯”è¾ƒç‚¸å¼¹çš„ä¸»ç‰Œå€¼
                                    canBeat = this.getRankValue(bombCards[0].rank) > this.getRankValue(lastPlay.cards[0].rank);
                                }

                                if (canBeat) {
                                    possiblePlays.push({
                                        cards: bombCards,
                                        type: bombType
                                    });
                                }
                            }
                        }
                    }
                }

                // æ£€æŸ¥ç«ç®­ï¼ˆå¤§å°ç‹ï¼‰
                const jokers = handCards.filter(card => card.suit === 'joker');
                if (jokers.length >= 2) {
                    const hasBig = jokers.some(j => j.rank === 'big');
                    const hasSmall = jokers.some(j => j.rank === 'small');
                    if (hasBig && hasSmall) {
                        const rocketCards = jokers.filter(j => j.rank === 'big' || j.rank === 'small').slice(0, 2);
                        possiblePlays.push({
                            cards: rocketCards,
                            type: { type: 'rocket', subtype: 'kingRocket' }
                        });
                    }
                }
            }

            // æ‰¾å•ç‰Œ
            findSingles(handCards, possiblePlays, lastType, lastPlay) {
                // å¦‚æœä¸Šå®¶å‡ºçš„æ˜¯ç‚¸å¼¹æˆ–ç«ç®­ï¼Œä¸èƒ½ç”¨å•ç‰Œæ‰“
                if (lastType.type === 'bomb' || lastType.type === 'rocket') {
                    return;
                }

                const lastCards = lastType.cards || [];
                const lastValue = lastCards.length > 0 ? this.getRankValue(lastCards[0].rank) : (lastType.rank || lastType.highCard || 0);

                for (let card of handCards) {
                    const cardValue = this.getRankValue(card.rank);
                    if (cardValue > lastValue) {
                        const lastPlayForValidation = {
                            cards: lastCards,
                            type: lastType
                        };
                        const validation = this.rules.validatePlay([card], lastPlayForValidation, handCards);
                        if (validation.valid) {
                            possiblePlays.push({
                                cards: [card],
                                type: validation.type
                            });
                        }
                    }
                }
            }

            // æ‰¾å¯¹å­
            findPairs(handCards, possiblePlays, lastType) {
                // å¦‚æœä¸Šå®¶å‡ºçš„æ˜¯ç‚¸å¼¹æˆ–ç«ç®­ï¼Œä¸èƒ½ç”¨å¯¹å­æ‰“
                if (lastType.type === 'bomb' || lastType.type === 'rocket') {
                    return;
                }

                const rankGroups = this.groupCardsByRank(handCards);
                // ä»lastTypeä¸­è·å–ä¸Šå®¶ç‰Œçš„ä¿¡æ¯
                const lastRank = lastType.rank || lastType.highPair || 0;
                const lastCards = lastType.cards || [];

                for (let [rank, cards] of Object.entries(rankGroups)) {
                    if (cards.length >= 2) {
                        const rankValue = this.getRankValue(rank);
                        if (rankValue > lastRank) {
                            const pairCards = cards.slice(0, 2);
                            // æ„é€ lastPlayå¯¹è±¡è¿›è¡ŒéªŒè¯
                            const lastPlayForValidation = {
                                cards: lastCards,
                                type: lastType
                            };
                            const validation = this.rules.validatePlay(pairCards, lastPlayForValidation, handCards);
                            if (validation.valid) {
                                possiblePlays.push({
                                    cards: pairCards,
                                    type: validation.type
                                });
                            }
                        }
                    }
                }
            }

            // æ‰¾ä¸‰å¼ 
            findTriples(handCards, possiblePlays, lastType) {
                // å¦‚æœä¸Šå®¶å‡ºçš„æ˜¯ç‚¸å¼¹æˆ–ç«ç®­ï¼Œä¸èƒ½ç”¨ä¸‰å¼ æ‰“
                if (lastType.type === 'bomb' || lastType.type === 'rocket') {
                    return;
                }

                const rankGroups = this.groupCardsByRank(handCards);
                // ä»lastTypeä¸­è·å–ä¸Šå®¶ç‰Œçš„ä¿¡æ¯
                const lastRank = lastType.rank || lastType.highTriple || 0;
                const lastCards = lastType.cards || [];

                for (let [rank, cards] of Object.entries(rankGroups)) {
                    if (cards.length >= 3) {
                        const rankValue = this.getRankValue(rank);
                        if (rankValue > lastRank) {
                            const tripleCards = cards.slice(0, 3);
                            // æ„é€ lastPlayå¯¹è±¡è¿›è¡ŒéªŒè¯
                            const lastPlayForValidation = {
                                cards: lastCards,
                                type: lastType
                            };
                            const validation = this.rules.validatePlay(tripleCards, lastPlayForValidation, handCards);
                            if (validation.valid) {
                                possiblePlays.push({
                                    cards: tripleCards,
                                    type: validation.type
                                });
                            }
                        }
                    }
                }
            }

            // æ¯”è¾ƒå‡ºç‰Œå¤§å°
            comparePlayValues(play1, play2) {
                if (!play1 || !play2 || !play1.type || !play2.type) return 0;

                // ç›´æ¥æ¯”è¾ƒæƒé‡
                const weight1 = play1.type.weight || 0;
                const weight2 = play2.type.weight || 0;

                return weight1 - weight2;
            }

            // æ˜¾ç¤ºæ¸¸æˆå†…æ¶ˆæ¯
            showMessage(message, type = 'info') {
                const messageBubble = document.getElementById('messageBubble');
                if (messageBubble) {
                    messageBubble.textContent = message;
                    messageBubble.className = 'message-bubble';

                    // æ ¹æ®æ¶ˆæ¯ç±»å‹æ·»åŠ æ ·å¼
                    if (type === 'error') {
                        messageBubble.style.background = '#ff4444';
                        messageBubble.style.animation = 'shake 0.5s';
                    } else if (type === 'success') {
                        messageBubble.style.background = '#4CAF50';
                    } else {
                        messageBubble.style.background = '#2196F3';
                    }

                    // 3ç§’åæ¢å¤é»˜è®¤æ ·å¼
                    setTimeout(() => {
                        messageBubble.style.background = '#2196F3';
                        messageBubble.style.animation = '';
                    }, 3000);
                }
            }

            // å†³å®šé¦–å±€é¦–å‡ºç©å®¶ï¼ˆéšæœºå†³å®šï¼‰
            determineFirstPlayer() {
                // éé¦–å±€ï¼Œç”±ä¸Šå±€æœ«æ¸¸å…ˆå‡º
                if (!this.isFirstGame && this.lastGameLoser) {
                    this.showMessage(`${this.players[this.lastGameLoser].name}æ˜¯ä¸Šå±€æœ«æ¸¸ï¼Œä¼˜å…ˆå‡ºç‰Œ`, 'info');
                    return this.lastGameLoser;
                }

                // é¦–å±€éšæœºå†³å®šé¦–å‡ºç©å®¶
                const order = ['south', 'west', 'north', 'east'];
                const firstPlayer = order[Math.floor(Math.random() * 4)];

                this.showMessage(`${this.players[firstPlayer].name}éšæœºè·å¾—é¦–å‡ºæƒ`, 'info');
                return firstPlayer;
            }

            // è·å–æ‰€æœ‰ç‰Œ
            getAllCards() {
                const allCards = [];
                const suits = ['â™ ', 'â™¥', 'â™£', 'â™¦'];
                const ranks = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A', '2'];

                // æ¯ç§ç‰Œå‹4å¼ 
                for (let suit of suits) {
                    for (let rank of ranks) {
                        for (let i = 0; i < 4; i++) {
                            allCards.push({ suit, rank });
                        }
                    }
                }

                // å¤§å°ç‹
                allCards.push({ suit: 'joker', rank: 'small' });
                allCards.push({ suit: 'joker', rank: 'big' });

                return allCards;
            }

  
            showRecords() {
                this.showMessage('æˆ˜ç»©åŠŸèƒ½å¼€å‘ä¸­...', 'info');
            }

            restartGame() {
                if (confirm('ç¡®å®šè¦é‡æ–°å¼€å§‹æ¸¸æˆå—ï¼Ÿ')) {
                    this.currentRoundCards = [];
                    this.lastPlayer = null;
                    this.selectedCards = [];
                    this.gameState = 'waiting';
                    this.initializeGame();
                }
            }

            showSettings() {
                alert('è®¾ç½®åŠŸèƒ½å¼€å‘ä¸­...');
            }

            getCardType(cards) {
                if (!cards || cards.length === 0) return null;

                // æ£€æŸ¥å¤§å°ç‹ï¼ˆç‚¸å¼¹ï¼‰
                if (cards.length === 1) {
                    if (cards[0].suit === 'joker') {
                        return { type: 'bomb', subtype: 'singleJoker' };
                    }
                    return { type: 'single' };
                } else if (cards.length === 2) {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç«ç®­ï¼ˆå¤§å°ç‹ï¼‰
                    if (cards[0].suit === 'joker' && cards[1].suit === 'joker') {
                        return { type: 'rocket', subtype: 'kingRocket' };
                    }
                    // æ£€æŸ¥æ˜¯å¦æ˜¯å¯¹å­
                    if (cards[0].rank === cards[1].rank) {
                        return { type: 'pair' };
                    }
                    return { type: 'invalid' };
                } else if (cards.length === 3) {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ä¸‰å¼ 
                    if (cards[0].rank === cards[1].rank && cards[1].rank === cards[2].rank) {
                        return { type: 'triple' };
                    }
                    return { type: 'invalid' };
                } else if (cards.length === 4) {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç‚¸å¼¹ï¼ˆ4å¼ åŒç‚¹æ•°ï¼‰
                    const firstRank = cards[0].rank;
                    if (cards.every(card => card.rank === firstRank)) {
                        return { type: 'bomb', subtype: '4bomb' };
                    }
                    // æ£€æŸ¥ä¸‰å¸¦ä¸€
                    const rankCounts = {};
                    cards.forEach(card => {
                        rankCounts[card.rank] = (rankCounts[card.rank] || 0) + 1;
                    });
                    const counts = Object.values(rankCounts);
                    if (counts.includes(3) && counts.includes(1)) {
                        const mainRank = Object.keys(rankCounts).find(rank => rankCounts[rank] === 3);
                        return { type: 'tripleWithOne', mainRank: this.getRankValue(mainRank) };
                    }
                    return { type: 'invalid' };
                } else if (cards.length === 5) {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç‚¸å¼¹ï¼ˆ5å¼ åŒç‚¹æ•°ï¼‰
                    const firstRank = cards[0].rank;
                    if (cards.every(card => card.rank === firstRank)) {
                        return { type: 'bomb', subtype: '5bomb' };
                    }
                    // æ£€æŸ¥ä¸‰å¸¦äºŒ
                    const rankCounts = {};
                    cards.forEach(card => {
                        rankCounts[card.rank] = (rankCounts[card.rank] || 0) + 1;
                    });
                    const counts = Object.values(rankCounts);
                    if (counts.includes(3) && counts.includes(2)) {
                        const mainRank = Object.keys(rankCounts).find(rank => rankCounts[rank] === 3);
                        return { type: 'tripleWithPair', mainRank: this.getRankValue(mainRank) };
                    }
                    return { type: 'invalid' };
                } else if (cards.length >= 6) {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç‚¸å¼¹ï¼ˆ6å¼ æˆ–æ›´å¤šåŒç‚¹æ•°ï¼‰
                    const firstRank = cards[0].rank;
                    if (cards.every(card => card.rank === firstRank)) {
                        return { type: 'bomb', subtype: `${cards.length}bomb` };
                    }
                }

                return { type: 'basic' };
            }

            // éªŒè¯ç‰Œå‹æ˜¯å¦æœ‰æ•ˆ
            isValidPlayType(cardType, expectedCount) {
                if (!cardType || expectedCount <= 0) return false;

                switch (expectedCount) {
                    case 1:
                        return cardType.type === 'single';
                    case 2:
                        return cardType.type === 'pair';
                    case 3:
                        return cardType.type === 'triple';
                    default:
                        // å¯¹äºæ›´å¤šå¼ çš„ç‰Œï¼Œè¿™é‡Œå¯ä»¥æ‰©å±•è§„åˆ™ï¼ˆå¦‚é¡ºå­ã€è¿å¯¹ç­‰ï¼‰
                        return cardType.type !== 'invalid';
                }
            }
        }

        // æ¼è›‹è§„åˆ™å¼•æ“
        class GuandanRules {
            constructor() {
                this.cardOrder = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A', '2', 'å°ç‹', 'å¤§ç‹'];
                this.currentLevel = 2;
                this.jokerCard = null;
                this.initializeLevel();

                // ä½¿ç”¨æ–°å®Œå–„çš„è§„åˆ™å¼•æ“
                try {
                    if (typeof RuleEngine !== 'undefined') {
                        this.ruleEngine = new RuleEngine(null);
                        this.ruleEngine.setLevel(this.currentLevel);
                        this.useAdvancedEngine = true;
                        console.log('[è§„åˆ™å¼•æ“] å·²å¯ç”¨é«˜çº§è§„åˆ™å¼•æ“');
                    }
                } catch (error) {
                    console.warn('[è§„åˆ™å¼•æ“] é«˜çº§å¼•æ“åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨åŸºç¡€å¼•æ“');
                }
            }

            initializeLevel() {
                this.jokerCard = this.currentLevel === 14 ? 'A' : this.currentLevel.toString();
            }

            getCardValue(rank) {
                return this.cardOrder.indexOf(rank);
            }

            validatePlay(cards, lastPlay, playerHand) {
                try {
                    // è°ƒè¯•è¾“å‡º
                    console.log('[validatePlay] å‡ºç‰Œ:', cards.map(c => c.rank + (c.suit === 'joker' ? '' : c.suit)).join(', '));
                    if (lastPlay) {
                        console.log('[validatePlay] ä¸Šå®¶ç‰Œ:', lastPlay.cards ? lastPlay.cards.map(c => c.rank + (c.suit === 'joker' ? '' : c.suit)).join(', ') : 'æœªçŸ¥');
                    }

                    // ä½¿ç”¨æ–°çš„å®˜æ–¹è§„åˆ™å¼•æ“
                    if (this.ruleEngine) {
                        let lastPlayCards = null;
                        if (lastPlay && lastPlay.cards) {
                            lastPlayCards = lastPlay.cards;
                        } else if (lastPlay && Array.isArray(lastPlay)) {
                            lastPlayCards = lastPlay;
                        }

                        const result = this.ruleEngine.validatePlay(cards, lastPlayCards, playerHand);
                        console.log('[validatePlay] è§„åˆ™å¼•æ“ç»“æœ:', result);

                        return result;
                    }
                } catch (error) {
                    console.error('[å‡ºç‰ŒéªŒè¯é”™è¯¯]', error);
                }

                // ç®€å•éªŒè¯
                if (cards.length === 0) {
                    return { valid: false, message: 'æ²¡æœ‰é€‰æ‹©ç‰Œ' };
                }

                return { valid: true, message: 'å‡ºç‰Œåˆæ³•', cardType: { type: 'basic' } };
            }

            getCardType(cards) {
                if (!cards || cards.length === 0) return null;

                // ä½¿ç”¨æ–°çš„å®˜æ–¹è§„åˆ™å¼•æ“
                if (this.ruleEngine) {
                    try {
                        return this.ruleEngine.getCardType(cards);
                    } catch (error) {
                        console.warn('[è§„åˆ™å¼•æ“] ç‰Œå‹è¯†åˆ«å¤±è´¥');
                    }
                }

                // åŸºç¡€ç‰Œå‹è¯†åˆ«
                if (cards.length === 1) {
                    return { type: 'single' };
                }

                return null;
            }
        }

        // å…¨å±€æ¸¸æˆå®ä¾‹
        let game;

        // å…¨å±€å‡½æ•°
        function playCards() {
            if (game) game.playCards();
        }

        function passTurn() {
            if (game) game.passTurn();
        }

        function showHint() {
            if (game) game.showHint();
        }

        function reportCards() {
            if (game) game.reportCards();
        }

        function showRecords() {
            if (game) game.showRecords();
        }

        function restartGame() {
            if (game) game.restartGame();
        }

        function showSettings() {
            if (game) game.showSettings();
        }

        function toggleSortMode() {
            if (game) game.toggleSortMode();
        }

        // æ¨¡å—åŒ–åŠ è½½ç®¡ç†å™¨
        class ModuleLoader {
            constructor() {
                this.modules = new Map();
                this.loadProgress = 0;
                this.totalModules = 3;
            }

            updateProgress(moduleName, status, progress = null) {
                this.loadProgress = Math.min(100, this.loadProgress + (100 / this.totalModules));

                document.getElementById('loadingProgress').style.width = this.loadProgress + '%';
                document.getElementById('loadingStatus').textContent = `æ­£åœ¨åŠ è½½ ${moduleName}...`;

                this.log(`[æ¨¡å—åŠ è½½] ${moduleName}: ${status}`);
            }

            log(message) {
                console.log(message);
            }

            handleError(error, moduleName) {
                this.log(`[é”™è¯¯] ${moduleName}: ${error.message}`);
                document.getElementById('errorText').textContent = `${moduleName} åŠ è½½å¤±è´¥: ${error.message}`;
                document.getElementById('errorMessage').classList.add('show');
            }

            async loadAllModules() {
                try {
                    // æ¨¡æ‹ŸåŠ è½½æ¨¡å—
                    this.updateProgress('æ¸¸æˆå¼•æ“', 'loading');
                    await new Promise(resolve => setTimeout(resolve, 500));

                    this.updateProgress('ç•Œé¢ç»„ä»¶', 'loading');
                    await new Promise(resolve => setTimeout(resolve, 500));

                    // åˆå§‹åŒ–æ¸¸æˆ
                    await this.initializeGame();

                    // éšè—åŠ è½½ç”»é¢ï¼Œæ˜¾ç¤ºæ¸¸æˆ
                    setTimeout(() => {
                        document.getElementById('loadingScreen').style.display = 'none';
                        document.getElementById('gameContainer').classList.add('loaded');
                    }, 500);

                    this.log('[ç³»ç»Ÿ] æ‰€æœ‰æ¨¡å—åŠ è½½å®Œæˆï¼Œæ¸¸æˆåˆå§‹åŒ–æˆåŠŸ');

                } catch (error) {
                    this.handleError(error, 'æ¨¡å—åŠ è½½å™¨');
                }
            }

            async initializeGame() {
                try {
                    game = new GuandanGame();
                    this.log('[æ¸¸æˆå¼•æ“] åˆå§‹åŒ–å®Œæˆ');
                } catch (error) {
                    this.handleError(error, 'æ¸¸æˆåˆå§‹åŒ–');
                    throw error;
                }
            }
        }

        // æµ‹è¯•è¿è¡Œå™¨
        let testRunner = null;

        // è¿è¡Œæ‰€æœ‰æµ‹è¯•
        async function runTests() {
            if (!testRunner) {
                testRunner = new TestRunner();

                // åˆ›å»ºè§„åˆ™å¼•æ“å®ä¾‹ç”¨äºæµ‹è¯•
                const testRuleEngine = new RuleEngine(null);

                // æ·»åŠ æ‰€æœ‰æµ‹è¯•å¥—ä»¶
                testRunner.addSuite(createCardTypeTests(testRuleEngine));
                testRunner.addSuite(createComparisonTests(testRuleEngine));
                testRunner.addSuite(createRoundTests());
                testRunner.addSuite(createAITests(testRuleEngine));
            }

            // è¿è¡Œæµ‹è¯•
            console.log('\nğŸ§ª å¼€å§‹è¿è¡Œæ¼è›‹æ¸¸æˆæµ‹è¯•å¥—ä»¶...');
            const results = await testRunner.runAllTests();

            // æ˜¾ç¤ºæµ‹è¯•ç»“æœ
            const summary = testRunner.getResultsSummary();
            if (summary.allPassed) {
                console.log('âœ… æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼');
                showTestNotification('æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼', 'success');
            } else {
                console.log('âŒ å­˜åœ¨æµ‹è¯•å¤±è´¥');
                showTestNotification(`æµ‹è¯•å¤±è´¥ï¼š${summary.totalFailed}/${summary.totalTests}`, 'error');
            }

            return results;
        }

        // è¿è¡Œç‰¹å®šæµ‹è¯•å¥—ä»¶
        async function runSpecificSuite(suiteName) {
            if (!testRunner) {
                await runTests();  // å…ˆåˆå§‹åŒ–
                return;
            }

            try {
                const results = await testRunner.runSpecificSuite(suiteName);
                return results;
            } catch (error) {
                console.error(`è¿è¡Œæµ‹è¯•å¥—ä»¶ "${suiteName}" å¤±è´¥:`, error);
                showTestNotification(`è¿è¡Œæµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æ˜¾ç¤ºæµ‹è¯•é€šçŸ¥
        function showTestNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `test-notification ${type}`;
            notification.innerHTML = `
                <span class="test-icon">${type === 'success' ? 'âœ…' : type === 'error' ? 'âŒ' : 'â„¹ï¸'}</span>
                <span class="test-message">${message}</span>
                <button class="test-close" onclick="this.parentElement.remove()">Ã—</button>
            `;

            // æ·»åŠ æ ·å¼
            if (!document.querySelector('#test-notification-style')) {
                const style = document.createElement('style');
                style.id = 'test-notification-style';
                style.textContent = `
                    .test-notification {
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: white;
                        padding: 15px 20px;
                        border-radius: 8px;
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                        display: flex;
                        align-items: center;
                        gap: 10px;
                        z-index: 10000;
                        max-width: 400px;
                        animation: slideIn 0.3s ease;
                    }
                    .test-notification.success {
                        border-left: 4px solid #4CAF50;
                    }
                    .test-notification.error {
                        border-left: 4px solid #f44336;
                    }
                    .test-notification.info {
                        border-left: 4px solid #2196F3;
                    }
                    .test-icon {
                        font-size: 20px;
                    }
                    .test-message {
                        flex: 1;
                        font-family: monospace;
                    }
                    .test-close {
                        background: none;
                        border: none;
                        font-size: 20px;
                        cursor: pointer;
                        color: #999;
                    }
                    .test-close:hover {
                        color: #333;
                    }
                    @keyframes slideIn {
                        from {
                            transform: translateX(100%);
                            opacity: 0;
                        }
                        to {
                            transform: translateX(0);
                            opacity: 1;
                        }
                    }
                `;
                document.head.appendChild(style);
            }

            document.body.appendChild(notification);

            // è‡ªåŠ¨ç§»é™¤é€šçŸ¥
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 5000);
        }

        // ä¿å­˜æµ‹è¯•æŠ¥å‘Š
        function saveTestReport() {
            if (testRunner) {
                testRunner.saveHTMLReport('guandan-test-report.html');
                showTestNotification('æµ‹è¯•æŠ¥å‘Šå·²ä¿å­˜', 'success');
            } else {
                showTestNotification('è¯·å…ˆè¿è¡Œæµ‹è¯•', 'error');
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆåå¼€å§‹åŠ è½½æ¨¡å—
        document.addEventListener('DOMContentLoaded', () => {
            console.log('é¡µé¢åŠ è½½å®Œæˆï¼Œå¼€å§‹æ¨¡å—åŠ è½½æµç¨‹');
            const loader = new ModuleLoader();

            setTimeout(() => {
                loader.loadAllModules();
            }, 100);

            // æ·»åŠ æµ‹è¯•å¿«æ·é”®æ”¯æŒ
            document.addEventListener('keydown', (e) => {
                // Ctrl+T: è¿è¡Œæ‰€æœ‰æµ‹è¯•
                if (e.ctrlKey && e.key === 't') {
                    e.preventDefault();
                    runTests();
                }
                // Ctrl+Shift+T: è¿è¡Œç‰¹å®šæµ‹è¯•
                else if (e.ctrlKey && e.shiftKey && e.key === 'T') {
                    e.preventDefault();
                    const suiteNames = ['ç‰Œå‹è¯†åˆ«æµ‹è¯•', 'æ¯”å¤§å°è§„åˆ™æµ‹è¯•', 'è½®æ¬¡ç®¡ç†æµ‹è¯•', 'AIå‡ºç‰Œé€»è¾‘æµ‹è¯•'];
                    const suiteName = prompt(`è¯·é€‰æ‹©æµ‹è¯•å¥—ä»¶:\n${suiteNames.map((n, i) => `${i + 1}. ${n}`).join('\n')}\n\nè¾“å…¥æ•°å­— (1-${suiteNames.length})`);
                    if (suiteName && !isNaN(suiteName)) {
                        const index = parseInt(suiteName) - 1;
                        if (index >= 0 && index < suiteNames.length) {
                            runSpecificSuite(suiteNames[index]);
                        }
                    }
                }
                // Ctrl+S: ä¿å­˜æµ‹è¯•æŠ¥å‘Š
                else if (e.ctrlKey && e.key === 's' && !e.shiftKey) {
                    e.preventDefault();
                    saveTestReport();
                }
            });

            // å°†æµ‹è¯•å‡½æ•°æ·»åŠ åˆ°å…¨å±€ä½œç”¨åŸŸï¼Œæ–¹ä¾¿è°ƒè¯•
            window.runTests = runTests;
            window.runSpecificSuite = runSpecificSuite;
            window.saveTestReport = saveTestReport;
            window.testRunner = testRunner;

            console.log('\nğŸ® æ¼è›‹æ¸¸æˆæµ‹è¯•æ¡†æ¶å·²åŠ è½½');
            console.log('å¿«æ·é”®:');
            console.log('  Ctrl+T    - è¿è¡Œæ‰€æœ‰æµ‹è¯•');
            console.log('  Ctrl+Shift+T - é€‰æ‹©è¿è¡Œç‰¹å®šæµ‹è¯•å¥—ä»¶');
            console.log('  Ctrl+S    - ä¿å­˜æµ‹è¯•æŠ¥å‘Š');
            console.log('  runTests() - åœ¨æ§åˆ¶å°è¿è¡Œæµ‹è¯•');
        });

        // å…¨å±€é”™è¯¯å¤„ç†
        window.addEventListener('error', (event) => {
            console.error('[å…¨å±€é”™è¯¯]', event.error);
        });
    </script>
</body>
</html>