<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¼è›‹ - ç°ä»£åŒ–ç•Œé¢ç‰ˆæœ¬</title>

    <!-- å¼•å…¥ç°ä»£åŒ–CSSæ ·å¼ -->
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/responsive.css">
    <link rel="stylesheet" href="css/game-modern.css">

    <style>
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        /* å¼ºåˆ¶ä¿®å¤ç‰Œé¢æ˜¾ç¤ºé—®é¢˜ */
        .player-card.red {
            color: #DC143C !important;
        }
        .player-card.black {
            color: #000 !important;
        }

        /* ç¡®ä¿ç‰Œé¢å†…å®¹å®šä½æ­£ç¡® */
        .player-card .card-top-left,
        .player-card .card-bottom-right {
            position: absolute !important;
        }

        .player-card .card-top-left {
            top: 3px !important;
            left: 3px !important;
        }

        .player-card .card-bottom-right {
            bottom: 3px !important;
            right: 3px !important;
            transform: rotate(180deg) !important;
        }

        /* ç‰Œé¢æ–‡å­—æ ·å¼ */
        .player-card .card-rank {
            font-weight: bold !important;
            font-size: 18px !important; /* ä»14pxå¢åŠ åˆ°18px (1.3å€) */
            line-height: 1 !important;
        }

        .player-card .card-suit {
            font-size: 26px !important; /* ä»20pxå¢åŠ åˆ°26px (1.3å€) */
            line-height: 1 !important;
        }

        /* JOKERç«–å‘æ˜¾ç¤ºæ ·å¼ */
        .player-card .card-rank.joker-text {
            writing-mode: vertical-rl !important;
            text-orientation: upright !important;
            letter-spacing: -3px !important; /* å‡å°‘å­—æ¯é—´è·ï¼Œæ›´ç´§å‡‘ */
            line-height: 0.6 !important; /* å‡å°‘è¡Œé«˜ï¼Œæ›´ç´§å‡‘ */
            font-size: 14px !important; /* æ”¹å›14px */
        }

        .message-bubble {
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- åŠ è½½ç”»é¢ -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-spinner"></div>
        <div class="loading-text">æ­£åœ¨åŠ è½½æ¼è›‹æ¸¸æˆ...</div>
        <div class="loading-progress">
            <div class="loading-progress-bar" id="loadingProgress"></div>
        </div>
        <div id="loadingStatus">åˆå§‹åŒ–ç»„ä»¶ä¸­...</div>
    </div>

    <!-- é”™è¯¯æ¶ˆæ¯ -->
    <div class="error-message" id="errorMessage">
        <h3>åŠ è½½é”™è¯¯</h3>
        <p id="errorText">æ¸¸æˆç»„ä»¶åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•ã€‚</p>
        <button onclick="location.reload()" class="btn btn-secondary">é‡æ–°åŠ è½½</button>
    </div>

    <!-- æ¸¸æˆä¸»å®¹å™¨ -->
    <div class="game-container" id="gameContainer">
        <div class="game-table">
            <!-- é¡¶éƒ¨ä¿¡æ¯æ  -->
            <div class="top-info-bar">
                <div class="info-display coin-display">
                    <span>ğŸ’°</span>
                    <span id="coins">1000</span>
                </div>
                <div class="info-display level-display">
                    <span>â­</span>
                    <span id="level">åˆçº§</span>
                </div>
                <div class="info-display score-display">
                    <span>ğŸ†</span>
                    <span id="score">1250</span>
                </div>
                <button class="settings-btn" onclick="showSettings()">âš™ï¸ è®¾ç½®</button>
            </div>

            <!-- é¡¶éƒ¨å›¢é˜Ÿä¿¡æ¯æ  -->
            <div class="team-info-bar">
                <div class="team-info-item">
                    <div class="team-label">é˜Ÿå‹é˜Ÿ (A)</div>
                    <div class="team-value team-a" id="teamACards">54å¼ </div>
                </div>
                <div class="team-info-item">
                    <div class="team-label">å¯¹æ‰‹é˜Ÿ (B)</div>
                    <div class="team-value team-b" id="teamBCards">54å¼ </div>
                </div>
                <div class="team-info-item">
                    <div class="team-label">å½“å‰çŠ¶æ€</div>
                    <div class="team-value" id="gameStatus">è¿›è¡Œä¸­</div>
                </div>
            </div>

            <!-- åŒ—æ–¹ç©å®¶ï¼ˆå¯¹å®¶ï¼‰ -->
            <div class="player-position player-north">
                <div class="ai-hand-cards" id="northCards">
                    <!-- AIæ‰‹ç‰Œåªæ˜¾ç¤ºç‰ŒèƒŒï¼Œå †å æ•ˆæœ -->
                </div>
                <!-- æ‚¬æµ®ä¿¡æ¯é¢æ¿ -->
                <div class="player-info">
                    <div class="player-avatar">ğŸ¤–</div>
                    <div class="player-details">
                        <div class="player-name-row">
                            <div class="player-name">AIç©å®¶2</div>
                            <div class="team-indicator opponent-indicator" title="å¯¹æ‰‹">ğŸ”´</div>
                        </div>
                        <div class="player-status">
                            <span class="card-count-info">å‰©ä½™: <span id="northCount">27</span>å¼ </span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- è¥¿æ–¹ç©å®¶ï¼ˆé˜Ÿå‹ï¼‰ -->
            <div class="player-position player-west">
                <!-- æ‚¬æµ®ä¿¡æ¯é¢æ¿ - åœ¨æ‰‹ç‰Œå·¦è¾¹ -->
                <div class="player-info">
                    <div class="player-avatar">ğŸ¯</div>
                    <div class="player-details">
                        <div class="player-name-row">
                            <div class="player-name">AIç©å®¶3</div>
                            <div class="team-indicator teammate-indicator" title="é˜Ÿå‹">ğŸ’š</div>
                        </div>
                        <div class="player-status">
                            <span class="card-count-info">å‰©ä½™: <span id="westCount">27</span>å¼ </span>
                        </div>
                    </div>
                </div>
                <!-- æ‰‹ç‰Œ - åœ¨å³è¾¹ -->
                <div class="ai-hand-cards" id="westCards">
                    <!-- AIæ‰‹ç‰Œåªæ˜¾ç¤ºç‰ŒèƒŒï¼Œå †å æ•ˆæœ -->
                </div>
            </div>

            <!-- ä¸œæ–¹ç©å®¶ï¼ˆå¯¹æ‰‹ï¼‰ -->
            <div class="player-position player-east">
                <!-- æ‚¬æµ®ä¿¡æ¯é¢æ¿ - åœ¨æ‰‹ç‰Œå·¦è¾¹ -->
                <div class="player-info">
                    <div class="player-avatar">âš¡</div>
                    <div class="player-details">
                        <div class="player-name-row">
                            <div class="player-name">AIç©å®¶4</div>
                            <div class="team-indicator opponent-indicator" title="å¯¹æ‰‹">ğŸ”´</div>
                        </div>
                        <div class="player-status">
                            <span class="card-count-info">å‰©ä½™: <span id="eastCount">27</span>å¼ </span>
                        </div>
                    </div>
                </div>
                <!-- æ‰‹ç‰Œ - åœ¨å³è¾¹ -->
                <div class="ai-hand-cards" id="eastCards">
                    <!-- AIæ‰‹ç‰Œåªæ˜¾ç¤ºç‰ŒèƒŒï¼Œå †å æ•ˆæœ -->
                </div>
            </div>

            <!-- å—æ–¹ç©å®¶ï¼ˆè‡ªå·±ï¼‰ -->
            <div class="player-position player-south">
                <!-- ä¸»ç©å®¶ä¿¡æ¯é¢æ¿ - æ‰‹ç‰Œå·¦ä¾§ -->
                <div class="player-info main-player-info" id="mainPlayerInfo">
                    <div class="player-avatar">ğŸŒŸ</div>
                    <div class="player-details">
                        <div class="player-name-row">
                            <div class="player-name">å—å®¶(ä½ )</div>
                            <div class="team-indicator teammate-indicator" title="é˜Ÿå‹">ğŸ’š</div>
                        </div>
                        <div class="player-status">
                            <span class="card-count-info">æ‰‹ç‰Œ: <span id="southCardCountDisplay">0</span>å¼ </span>
                        </div>
                        <div class="player-status" id="mainPlayerStatus">å‡†å¤‡ä¸­...</div>
                    </div>
                </div>
                <div class="player-hand-cards" id="southCards">
                    <!-- ç©å®¶æ‰‹ç‰Œå †å æ‘†æ”¾ -->
                </div>
            </div>

            <!-- ä¸­å¤®å‡ºç‰ŒåŒºåŸŸ -->
            <div class="central-play-area" id="centralPlayArea">
                <!-- åŒ—ä½å‡ºç‰Œç»„ - ç‹¬ç«‹åœ¨é¡¶éƒ¨ -->
                <div class="plays-group north-plays" id="northPlays"></div>

                <!-- è¥¿ä½å‡ºç‰Œç»„ - ç‹¬ç«‹åœ¨å·¦ä¾§ -->
                <div class="plays-group west-plays" id="westPlays"></div>

                <!-- ä¸­å¤®çŠ¶æ€æ˜¾ç¤º -->
                <div id="playAreaCenter">
                    <div id="playAreaStatus">ç­‰å¾…å‡ºç‰Œ...</div>
                </div>

                <!-- ä¸œä½å‡ºç‰Œç»„ - ç‹¬ç«‹åœ¨å³ä¾§ -->
                <div class="plays-group east-plays" id="eastPlays"></div>

                <!-- å—ä½å‡ºç‰Œç»„ - ç‹¬ç«‹åœ¨åº•éƒ¨ -->
                <div class="plays-group south-plays" id="southPlays"></div>
            </div>

            <!-- æ§åˆ¶æŒ‰é’®é¢æ¿ -->
            <div class="control-panel">
                <div class="control-buttons">
                    <button class="btn btn-play" id="playBtn" onclick="playCards()" disabled>
                        ğŸš€ å‡ºç‰Œ
                    </button>
                    <button class="btn btn-hint" id="hintBtn" onclick="showHint()">
                        ğŸ’¡ æç¤º
                    </button>
                    <button class="btn btn-pass" id="passBtn" onclick="passTurn()" disabled>
                        âœ‹ ä¸è¦
                    </button>
                    <button class="btn btn-report" id="reportBtn" onclick="reportCards()">
                        ğŸ“Š æŠ¥ç‰Œ
                    </button>
                    <button class="btn btn-records" id="recordsBtn" onclick="showRecords()">
                        ğŸ† æˆ˜ç»©
                    </button>
                    <button class="btn btn-restart" id="restartBtn" onclick="restartGame()">
                        ğŸ”„ é‡æ–°å¼€å§‹
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- æ¸¸æˆJavaScript -->
    <!-- å¼•å…¥å¤–éƒ¨JavaScriptç»„ä»¶ -->
    <script src="js/components/RuleEngine.js"></script>
    <script src="js/ui-enhancements.js"></script>

    <script>
        // æ¸¸æˆçŠ¶æ€ç®¡ç†ï¼ˆä¸åŸç‰ˆä¿æŒä¸€è‡´ï¼‰
        class GuandanGame {
            constructor() {
                this.players = {
                    // æ ‡å‡†æ–¹ä½ï¼šå—-è¥¿-åŒ—-ä¸œï¼ˆé€†æ—¶é’ˆï¼‰
                    east: { id: 'player2', name: 'ä¸œå®¶AI', cards: [], team: 'A', isAI: true },
                    south: { id: 'player1', name: 'å—å®¶(ä½ )', cards: [], team: 'A', isAI: false },
                    west: { id: 'player3', name: 'è¥¿å®¶AI', cards: [], team: 'B', isAI: true },
                    north: { id: 'player4', name: 'åŒ—å®¶AI', cards: [], team: 'B', isAI: true }
                };

                // é¦–å±€é€šè¿‡ç¿»ç‰Œå†³å®šé¦–å‡ºç©å®¶
                this.isFirstGame = true;
                this.currentPlayer = null; // å°†åœ¨initializeGameä¸­è®¾ç½®
                this.lastPlayer = null;
                this.currentRoundCards = [];
                this.selectedCards = [];
                this.gameState = 'waiting';
                this.playHistory = [];

                // æ¸¸æˆç»“æœè·Ÿè¸ª
                this.lastGameLoser = null; // ä¸Šå±€æœ«æ¸¸ç©å®¶
                this.gameResults = []; // æ¸¸æˆç»“æœè®°å½•

                // åˆå§‹åŒ–è§„åˆ™å¼•æ“ - ä½¿ç”¨æ–°çš„å®˜æ–¹è§„åˆ™å¼•æ“
                this.ruleEngine = new RuleEngine(this);
                this.rules = this.ruleEngine; // ä¿æŒå…¼å®¹æ€§
                this.lastPlay = null;

                // è½®æ¬¡ç®¡ç†
                this.roundActive = false;
                this.roundPlayers = new Set();
                this.roundStartPlayer = null;

                // å‡çº§æœºåˆ¶
                this.teamAScore = 0;
                this.teamBScore = 0;
                this.currentLevel = 2;
                this.gameHistory = [];

                // è®¾ç½®è§„åˆ™å¼•æ“çš„åˆå§‹çº§åˆ«
                if (this.ruleEngine) {
                    this.ruleEngine.setLevel(this.currentLevel);
                }

                this.initializeGame();
            }

            // è¾…åŠ©å‡½æ•°ï¼šè·å–ç‰Œé¢æ˜¾ç¤ºå†…å®¹
            getCardDisplay(card) {
                if (card.rank === 'å°ç‹') {
                    return { rank: 'JOKER', suit: '', color: 'black', isJoker: true };
                } else if (card.rank === 'å¤§ç‹') {
                    return { rank: 'JOKER', suit: '', color: 'red', isJoker: true };
                }
                return { rank: card.rank, suit: card.suit, color: card.isRed ? 'red' : 'black', isJoker: false };
            }

            initializeGame() {
                this.dealCards();

                // å†³å®šé¦–å‡ºç©å®¶
                this.currentPlayer = this.determineFirstPlayer();
                console.log(`æ¸¸æˆåˆå§‹åŒ–å®Œæˆï¼Œé¦–å‡ºç©å®¶ï¼š${this.currentPlayer}`);

                this.updateUI();
                this.gameState = 'playing';

                // å¦‚æœé¦–å‡ºç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨å‡ºç‰Œ
                if (this.players[this.currentPlayer].isAI) {
                    console.log(`é¦–å‡ºç©å®¶ ${this.currentPlayer} æ˜¯AIï¼Œè‡ªåŠ¨å‡ºç‰Œ`);
                    setTimeout(() => this.aiAutoPlay(), 1500);
                }
            }

            dealCards() {
                // åˆ›å»ºç‰Œç»„å¹¶åˆ†å‘
                const deck = this.createDeck();
                const positions = ['south', 'west', 'north', 'east']; // æŒ‰é€†æ—¶é’ˆé¡ºåºå‘ç‰Œ
                const cardsPerPlayer = Math.floor(deck.length / 4);

                positions.forEach((pos, index) => {
                    this.players[pos].cards = deck.slice(index * cardsPerPlayer, (index + 1) * cardsPerPlayer);
                    console.log(`${pos} ç©å®¶è·å¾— ${this.players[pos].cards.length} å¼ ç‰Œ`);
                });

                // éªŒè¯æ€»ç‰Œæ•°
                const totalCards = Object.values(this.players).reduce((sum, p) => sum + p.cards.length, 0);
                console.log(`æ€»å…±åˆ†é… ${totalCards} å¼ ç‰Œ`);
            }

            createDeck() {
                const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
                const ranks = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A', '2'];
                const deck = [];

                // åˆ›å»ºä¸¤å‰¯ç‰Œï¼ˆæ¼è›‹ä½¿ç”¨ä¸¤å‰¯ç‰Œï¼‰
                for (let deckCount = 0; deckCount < 2; deckCount++) {
                    for (let suit = 0; suit < 4; suit++) {
                        for (let rank = 0; rank < 13; rank++) {
                            deck.push({
                                suit: suits[suit],
                                rank: ranks[rank],
                                value: rank + 3,
                                isRed: suit === 1 || suit === 2
                            });
                        }
                    }
                }

                // æ·»åŠ å¤§å°ç‹ï¼ˆä¸¤å‰¯ç‰Œå„2å¼ ï¼Œå…±4å¼ ç‹ç‰Œï¼‰
                deck.push({ suit: 'JOKER', rank: 'å°ç‹', value: 16, isRed: true });
                deck.push({ suit: 'JOKER', rank: 'å°ç‹', value: 16, isRed: true });
                deck.push({ suit: 'JOKER', rank: 'å¤§ç‹', value: 17, isRed: true });
                deck.push({ suit: 'JOKER', rank: 'å¤§ç‹', value: 17, isRed: true });

                return this.shuffleArray(deck);
            }

            shuffleArray(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }

            updateUI() {
                this.updatePlayerCards();
                this.updatePlayArea();
                this.updateInfoBars();
                this.updateControlButtons();
            }

            updatePlayerCards() {
                // æ›´æ–°AIç©å®¶æ‰‹ç‰Œæ˜¾ç¤º
                ['north', 'west', 'east'].forEach(pos => {
                    const cardCount = this.players[pos].cards.length;
                    const container = document.getElementById(pos + 'Cards');
                    container.innerHTML = '';

                    // æ˜¾ç¤ºç‰ŒèƒŒï¼Œæ•°é‡ä¸å®é™…æ‰‹ç‰Œæ•°å¯¹åº”
                    const displayCount = Math.min(cardCount, 5);
                    for (let i = 0; i < displayCount; i++) {
                        const cardElement = document.createElement('div');
                        cardElement.className = 'ai-card-back';
                        cardElement.innerHTML = 'ğŸ‚ ';
                        container.appendChild(cardElement);
                    }

                    // æ›´æ–°AIç©å®¶ç‰Œæ•°æ˜¾ç¤º
                    const countElement = document.getElementById(pos + 'Count');
                    if (countElement) {
                        countElement.textContent = cardCount;
                    }
                });

                // æ›´æ–°ç©å®¶æ‰‹ç‰Œæ˜¾ç¤º
                const southCards = this.players.south.cards;
                const southContainer = document.getElementById('southCards');
                southContainer.innerHTML = '';

                southCards.forEach((card, index) => {
                    const cardElement = document.createElement('div');
                    const display = this.getCardDisplay(card);
                    cardElement.className = `player-card ${display.color}`;

                    // ç”Ÿæˆç‰Œçš„HTMLå†…å®¹
                    let cardHTML = '<div class="card-content">';

                    if (display.isJoker) {
                        // å¤§å°ç‹çš„ç‰¹æ®Šæ˜¾ç¤º
                        cardHTML += `
                            <div class="card-top-left">
                                <div class="card-rank joker-text">JOKER</div>
                            </div>
                            <div class="card-bottom-right">
                                <div class="card-rank joker-text">JOKER</div>
                            </div>
                        `;
                    } else {
                        // æ™®é€šç‰Œçš„æ˜¾ç¤º
                        cardHTML += `
                            <div class="card-top-left">
                                <div class="card-rank">${display.rank}</div>
                                <div class="card-suit">${display.suit}</div>
                            </div>
                            <div class="card-bottom-right">
                                <div class="card-rank">${display.rank}</div>
                                <div class="card-suit">${display.suit}</div>
                            </div>
                        `;
                    }

                    cardHTML += '</div>';
                    cardElement.innerHTML = cardHTML;

                    cardElement.style.setProperty('--card-index', index + 1);
                    cardElement.onclick = () => this.selectCard(card, cardElement);
                    southContainer.appendChild(cardElement);
                });

                // æ›´æ–°å—æ–¹ç©å®¶å‰©ä½™ç‰Œæ•°
                const southCountElement = document.getElementById('southCardCountDisplay');
                if (southCountElement) {
                    southCountElement.textContent = southCards.length;
                }
            }

            updatePlayArea() {
                // æ¸…ç©ºä¸­å¤®åŒºåŸŸ
                ['northPlays', 'southPlays', 'westPlays', 'eastPlays'].forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.innerHTML = '';
                        element.classList.remove('latest-group');
                    }
                });

                // æ›´æ–°ä¸­å¤®çŠ¶æ€
                const centerArea = document.getElementById('playAreaCenter');
                if (this.currentRoundCards.length === 0) {
                    centerArea.innerHTML = '<div id="playAreaStatus">ç­‰å¾…å‡ºç‰Œ...</div>';
                    centerArea.style.display = 'block';
                    return;
                }

                // éšè—ä¸­å¤®çŠ¶æ€
                centerArea.style.display = 'none';

                // æŒ‰å‡ºç‰Œä½ç½®åˆ†é…åˆ°ä¸­å¤®åŒºåŸŸçš„å„ä½ç½®
                // ç¡®ä¿åå‡ºç‰Œçš„ç©å®¶è¦†ç›–å…ˆå‡ºç‰Œçš„ç©å®¶
                this.currentRoundCards.forEach((play, index) => {
                    if (play.cards.length === 0 || play.action === 'pass') {
                        return;
                    }

                    const positionElement = document.getElementById(play.player + 'Plays');
                    if (!positionElement) return;

                    // æœ€æ–°å‡ºç‰Œçªå‡ºæ˜¾ç¤º
                    if (index === this.currentRoundCards.length - 1) {
                        positionElement.classList.add('latest-group');
                    }

                    // ä½¿ç”¨æ—¶é—´æˆ³ç¡®ä¿åå‡ºç‰Œçš„z-indexæ›´é«˜
                    const playTime = play.timestamp || Date.now();
                    const baseZIndex = 1000 + playTime;

                    // åˆ›å»ºç‰Œå…ƒç´ 
                    play.cards.forEach((card, cardIndex) => {
                        const cardElement = document.createElement('div');
                        const display = this.getCardDisplay(card);
                        cardElement.className = `player-card ${display.color}`;

                        // ç”Ÿæˆç‰Œçš„HTMLå†…å®¹
                        let cardHTML = '<div class="card-content">';

                        if (display.isJoker) {
                            // å¤§å°ç‹çš„ç‰¹æ®Šæ˜¾ç¤º
                            cardHTML += `
                                <div class="card-top-left">
                                    <div class="card-rank joker-text">JOKER</div>
                                </div>
                                <div class="card-bottom-right">
                                    <div class="card-rank joker-text">JOKER</div>
                                </div>
                            `;
                        } else {
                            // æ™®é€šç‰Œçš„æ˜¾ç¤º
                            cardHTML += `
                                <div class="card-top-left">
                                    <div class="card-rank">${display.rank}</div>
                                    <div class="card-suit">${display.suit}</div>
                                </div>
                                <div class="card-bottom-right">
                                    <div class="card-rank">${display.rank}</div>
                                    <div class="card-suit">${display.suit}</div>
                                </div>
                            `;
                        }

                        cardHTML += '</div>';
                        cardElement.innerHTML = cardHTML;

                        // è®¾ç½®åŸºäºæ—¶é—´å’Œç‰Œåºçš„z-indexï¼Œç¡®ä¿åå‡ºç‰Œè¦†ç›–å…ˆå‡ºç‰Œ
                        cardElement.style.zIndex = baseZIndex + cardIndex;
                        positionElement.appendChild(cardElement);
                    });
                });
            }

            updateInfoBars() {
                // æ›´æ–°æ¸¸æˆçŠ¶æ€
                const statusElement = document.getElementById('gameStatus');
                if (statusElement) {
                    statusElement.textContent = this.gameState === 'playing' ? 'è¿›è¡Œä¸­' : 'ç­‰å¾…';
                }
            }

            updateControlButtons() {
                const isPlayerTurn = this.currentPlayer === 'south' && this.gameState === 'playing';

                // ä¸»è¦æ¸¸æˆæŒ‰é’®
                const playBtn = document.getElementById('playBtn');
                const passBtn = document.getElementById('passBtn');
                const hintBtn = document.getElementById('hintBtn');
                const reportBtn = document.getElementById('reportBtn');

                playBtn.disabled = !isPlayerTurn || this.selectedCards.length === 0;
                passBtn.disabled = !isPlayerTurn;
                hintBtn.disabled = !isPlayerTurn;
                reportBtn.disabled = !isPlayerTurn;

                // æ›´æ–°æŒ‰é’®è§†è§‰çŠ¶æ€
                if (window.uiEnhancements) {
                    [playBtn, passBtn, hintBtn, reportBtn].forEach(btn => {
                        window.uiEnhancements.updateButtonState(btn);
                    });
                }

                // é«˜äº®å½“å‰ç©å®¶
                if (window.uiEnhancements && window.uiEnhancements.highlightCurrentPlayer) {
                    window.uiEnhancements.highlightCurrentPlayer(this.currentPlayer);
                }
            }

            selectCard(card, element) {
                if (this.currentPlayer !== 'south') return;

                const index = this.selectedCards.findIndex(c =>
                    c.suit === card.suit && c.rank === card.rank
                );
                if (index === -1) {
                    this.selectedCards.push(card);
                    element.classList.add('selected');
                } else {
                    this.selectedCards.splice(index, 1);
                    element.classList.remove('selected');
                }

                this.updateControlButtons();
            }

            playCards() {
                if (this.selectedCards.length === 0) return;

                // è·å–ä¸Šä¸€æ‰‹ç‰Œ
                let lastPlay = null;
                if (this.currentRoundCards.length > 0) {
                    // æ‰¾åˆ°æœ€åä¸€æ¬¡æœ‰æ•ˆå‡ºç‰Œï¼ˆépassï¼‰
                    for (let i = this.currentRoundCards.length - 1; i >= 0; i--) {
                        const play = this.currentRoundCards[i];
                        if (play.cards && play.cards.length > 0) {
                            lastPlay = {
                                cards: play.cards,
                                type: play.cardType || this.getCardType(play.cards)
                            };
                            break;
                        }
                    }
                }

                // ä½¿ç”¨è§„åˆ™å¼•æ“éªŒè¯å‡ºç‰Œ
                const validation = this.rules.validatePlay(
                    this.selectedCards,
                    lastPlay,
                    this.players.south.cards
                );

                if (!validation.valid) {
                    this.showMessage(validation.message, 'error');
                    return;
                }

                // ç§»é™¤æ‰‹ç‰Œ
                this.selectedCards.forEach(card => {
                    const index = this.players.south.cards.findIndex(c =>
                        c.suit === card.suit && c.rank === card.rank
                    );
                    if (index !== -1) {
                        this.players.south.cards.splice(index, 1);
                    }
                });

                // æ·»åŠ åˆ°å½“å‰è½®æ¬¡
                this.currentRoundCards.push({
                    player: 'south',
                    cards: [...this.selectedCards],
                    cardType: validation.cardType,
                    timestamp: Date.now()
                });

                this.selectedCards = [];

                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                if (this.checkGameEnd()) {
                    return;
                }

                // åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªç©å®¶
                this.switchToNextPlayer();
            }

            passTurn() {
                this.selectedCards = [];

                // è®°å½•passæ“ä½œ
                this.currentRoundCards.push({
                    player: this.currentPlayer,
                    cards: [],
                    timestamp: Date.now(),
                    action: 'pass'
                });

                this.switchToNextPlayer();
            }

            switchToNextPlayer() {
                // é€†æ—¶é’ˆé¡ºåºï¼šå— â†’ è¥¿ â†’ åŒ— â†’ ä¸œ
                const order = ['south', 'west', 'north', 'east'];
                const currentIndex = order.indexOf(this.currentPlayer);
                let nextPlayer = order[(currentIndex + 1) % 4];

                // æ­£å¸¸è½®è½¬åˆ°ä¸‹ä¸€ä¸ªç©å®¶
                this.currentPlayer = nextPlayer;
                console.log(`\n[è½®è½¬] ${order[currentIndex]} â†’ ${nextPlayer}`);

                // ç»Ÿä¸€å¤„ç†è½®æ¬¡é€»è¾‘
                this.processRoundEnd();

                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                if (this.checkGameEnd()) {
                    return;
                }

                this.updateUI();

                // åªæœ‰AIç©å®¶æ‰è‡ªåŠ¨å‡ºç‰Œ
                if (this.players[this.currentPlayer].isAI) {
                    setTimeout(() => this.aiAutoPlay(), 1000);
                }
            }

            // æ£€æŸ¥æ˜¯å¦åº”è¯¥æ¸…ç†æ¡Œé¢
            shouldClearTable() {
                // å¿…é¡»æœ‰å‡ºç‰Œè®°å½•
                if (this.currentRoundCards.length === 0) return false;

                // å¿…é¡»æœ‰è‡³å°‘ä¸€æ¬¡æœ‰æ•ˆå‡ºç‰Œ
                const hasValidPlay = this.currentRoundCards.some(play =>
                    play.cards && play.cards.length > 0
                );
                if (!hasValidPlay) return false;

                // æ£€æŸ¥æœ€è¿‘çš„ç©å®¶æ˜¯å¦éƒ½passäº†
                // æ‰¾åˆ°æœ€åä¸€æ¬¡æœ‰æ•ˆå‡ºç‰Œ
                let lastValidPlayIndex = -1;
                for (let i = this.currentRoundCards.length - 1; i >= 0; i--) {
                    if (this.currentRoundCards[i].cards && this.currentRoundCards[i].cards.length > 0) {
                        lastValidPlayIndex = i;
                        break;
                    }
                }

                if (lastValidPlayIndex === -1) return false;

                // æ£€æŸ¥æœ€åå‡ºç‰Œä¹‹åæ˜¯å¦æ‰€æœ‰å…¶ä»–ç©å®¶éƒ½passäº†
                const playersAfter = this.currentRoundCards.slice(lastValidPlayIndex + 1);
                const order = ['south', 'west', 'north', 'east'];
                const lastPlayPlayer = this.currentRoundCards[lastValidPlayIndex].player;
                const lastPlayerIndex = order.indexOf(lastPlayPlayer);

                // å…¶ä»–3ä¸ªç©å®¶éƒ½å¿…é¡»pass
                for (let i = 1; i <= 3; i++) {
                    const nextPlayerIndex = (lastPlayerIndex + i) % 4;
                    const nextPlayer = order[nextPlayerIndex];

                    // æ£€æŸ¥è¯¥ç©å®¶æ˜¯å¦pass
                    const playerPlay = playersAfter.find(p => p.player === nextPlayer);
                    if (!playerPlay || (playerPlay.cards && playerPlay.cards.length > 0)) {
                        return false; // è¯¥ç©å®¶æ²¡æœ‰passæˆ–å‡ºäº†ç‰Œ
                    }
                }

                return true;
            }

            // è·å–æœ€åå‡ºç‰Œçš„ç©å®¶
            getLastPlayPlayer() {
                for (let i = this.currentRoundCards.length - 1; i >= 0; i--) {
                    const play = this.currentRoundCards[i];
                    if (play.cards && play.cards.length > 0) {
                        return play.player;
                    }
                }
                return null;
            }

            aiAutoPlay() {
                if (this.gameState !== 'playing') return;

                const aiPlayer = this.players[this.currentPlayer];
                console.log(`\n[AIå†³ç­–] === ${this.currentPlayer} è½®åˆ°æˆ‘ ===`);
                console.log(`æ‰‹ç‰Œ: ${aiPlayer.cards.length}å¼ `);

                // è·å–ä¸Šä¸€æ‰‹ç‰Œï¼ˆæœ€åä¸€æ¬¡æœ‰æ•ˆå‡ºç‰Œï¼Œépassï¼‰
                let lastPlay = null;
                if (this.currentRoundCards.length > 0) {
                    for (let i = this.currentRoundCards.length - 1; i >= 0; i--) {
                        const play = this.currentRoundCards[i];
                        if (play.cards && play.cards.length > 0) {
                            lastPlay = {
                                cards: play.cards,
                                type: play.cardType || this.getCardType(play.cards)
                            };
                            break;
                        }
                    }
                }

                // å¦‚æœæ²¡æœ‰ä¸Šä¸€æ‰‹ç‰Œï¼ŒAIå¯ä»¥ä¸»åŠ¨å‡ºç‰Œ
                if (!lastPlay) {
                    // ä¼˜å…ˆé€‰æ‹©å•ç‰Œ
                    if (aiPlayer.cards.length > 0) {
                        // é€‰æ‹©æœ€å°çš„å•ç‰Œ
                        const minCard = aiPlayer.cards.reduce((min, card) => {
                            return this.getRankValue(card.rank) < this.getRankValue(min.rank) ? card : min;
                        });

                        // å‡ºå•ç‰Œ
                        aiPlayer.cards.splice(aiPlayer.cards.indexOf(minCard), 1);

                        // éªŒè¯å‡ºç‰Œåˆæ³•æ€§
                        const validation = this.rules.validatePlay([minCard], null, aiPlayer.cards);
                        if (validation.valid) {
                            // æ·»åŠ åˆ°å½“å‰è½®æ¬¡
                            this.currentRoundCards.push({
                                player: this.currentPlayer,
                                cards: [minCard],
                                cardType: validation.cardType,
                                timestamp: Date.now()
                            });
                        }
                    }
                } else {
                    // éœ€è¦æ ¹æ®ä¸Šä¸€æ‰‹ç‰Œå‡ºç‰Œ - ä½¿ç”¨æ›´æ™ºèƒ½çš„é€»è¾‘
                    let canPlay = false;

                    // é¦–å…ˆå°è¯•æ‰¾åˆ°æ‰€æœ‰å¯èƒ½çš„å‡ºç‰Œ
                    const possiblePlays = this.findAllPossiblePlays(aiPlayer.cards, lastPlay);

                    if (possiblePlays.length > 0) {
                        // é€‰æ‹©æœ€å°çš„åˆæ³•å‡ºç‰Œï¼ˆèŠ‚çœå¤§ç‰Œï¼‰
                        const selectedPlay = possiblePlays[0];

                        // ç§»é™¤å‡ºçš„ç‰Œ
                        selectedPlay.cards.forEach(card => {
                            const index = aiPlayer.cards.findIndex(c =>
                                c.suit === card.suit && c.rank === card.rank
                            );
                            if (index !== -1) {
                                aiPlayer.cards.splice(index, 1);
                            }
                        });

                        // æ·»åŠ åˆ°å½“å‰è½®æ¬¡
                        this.currentRoundCards.push({
                            player: this.currentPlayer,
                            cards: selectedPlay.cards,
                            cardType: selectedPlay.type,
                            timestamp: Date.now()
                        });
                        canPlay = true;
                        console.log(`AI ${this.currentPlayer} å‡ºç‰Œ: ${selectedPlay.cards.map(c => c.rank + c.suit).join(', ')}`);
                    }

                    if (!canPlay) {
                        // AIé€‰æ‹©ä¸è¦
                        this.currentRoundCards.push({
                            player: this.currentPlayer,
                            cards: [],
                            timestamp: Date.now(),
                            action: 'pass'
                        });
                        console.log(`AI ${this.currentPlayer} é€‰æ‹©è¿‡ç‰Œ`);
                    }
                }

                this.switchToNextPlayer();
                this.updateUI();
                console.log(`${this.currentPlayer} è½®è½¬å®Œæˆ`);

                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                if (this.checkGameEnd()) {
                    return;
                }

              }

            // ç»Ÿä¸€å¤„ç†è½®æ¬¡ç»“æŸé€»è¾‘
            processRoundEnd() {
                // æ£€æŸ¥æ˜¯å¦åº”è¯¥æ¸…ç†æ¡Œé¢ï¼ˆè¿ç»­ä¸‰å®¶passæˆ–å››å®¶éƒ½å‡ºç‰Œï¼‰
                if (this.shouldClearTable()) {
                    console.log('[è½®æ¬¡ç»“æŸ] æ¸…ç†æ¡Œé¢');
                    this.currentRoundCards = [];
                    this.lastPlayer = null;

                    // æ›´æ–°å‡ºç‰ŒåŒºåŸŸæ˜¾ç¤º
                    const plays = ['northPlays', 'eastPlays', 'southPlays', 'westPlays'];
                    plays.forEach(id => {
                        const element = document.getElementById(id);
                        if (element) element.innerHTML = '';
                    });
                }
            }

            // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
            checkGameEnd() {
                // æ£€æŸ¥æ˜¯å¦æœ‰ç©å®¶æ‰‹ç‰Œä¸º0ï¼ˆä¸Šæ¸¸ï¼‰
                for (let position in this.players) {
                    if (this.players[position].cards.length === 0) {
                        console.log(`${position} æ‰‹ç‰Œä¸º0ï¼Œæ¸¸æˆç»“æŸï¼`);
                        // æ¸¸æˆç»“æŸï¼Œè®°å½•ç»“æœ
                        this.endGame(position);
                        return true;
                    }
                }
                return false;
            }

            // æ¸¸æˆç»“æŸå¤„ç†
            endGame(winnerPosition) {
                this.gameState = 'ended';

                // ç¡®å®šæ’å
                const rankings = this.determineRankings(winnerPosition);

                // è®°å½•æœ«æ¸¸ç©å®¶ï¼ˆç¬¬å››åï¼‰
                this.lastGameLoser = rankings[3]; // ç¬¬å››åæ˜¯æœ«æ¸¸

                // æ˜¾ç¤ºç»“æœ
                const winnerName = this.players[winnerPosition].name;
                const loserName = this.players[this.lastGameLoser].name;

                this.showMessage(`æ¸¸æˆç»“æŸï¼${winnerName}è·èƒœï¼Œ${loserName}æ˜¯æœ«æ¸¸`, 'success');

                // è¯¢é—®æ˜¯å¦å¼€å§‹æ–°æ¸¸æˆ
                setTimeout(() => {
                    if (confirm('æ¸¸æˆç»“æŸï¼æ˜¯å¦å¼€å§‹æ–°çš„ä¸€å±€ï¼Ÿ')) {
                        this.startNewGame();
                    }
                }, 2000);
            }

            // ç¡®å®šç©å®¶æ’å
            determineRankings(firstPlace) {
                // æ ¹æ®å‰©ä½™æ‰‹ç‰Œæ•°é‡ç¡®å®šæ’å
                const playersWithCards = [];
                for (let pos in this.players) {
                    playersWithCards.push({
                        position: pos,
                        cardCount: this.players[pos].cards.length
                    });
                }

                // æŒ‰å‰©ä½™æ‰‹ç‰Œæ•°æ’åº
                playersWithCards.sort((a, b) => a.cardCount - b.cardCount);

                // è¿”å›æ’åé¡ºåºï¼ˆä»ç¬¬äºŒååˆ°ç¬¬å››åï¼‰
                const rankings = [firstPlace];
                playersWithCards.forEach(p => {
                    if (p.position !== firstPlace) {
                        rankings.push(p.position);
                    }
                });

                return rankings;
            }

            // æ£€æŸ¥æ˜¯å¦å¼€å§‹æ–°è½®æ¬¡
            checkNewRound() {
                if (this.currentRoundCards.length === 0) return false;

                // åªè€ƒè™‘æœ€è¿‘çš„æ“ä½œï¼ˆé¿å…æ•°ç»„è¿‡é•¿ï¼‰
                const recentCards = this.currentRoundCards.slice(-8);
                const currentRoundPlays = recentCards.filter(play => play.action !== 'pass');
                const passActions = recentCards.filter(play => play.action === 'pass');

                // æƒ…å†µ1ï¼šè¿ç»­ä¸‰å®¶pass
                if (passActions.length >= 3) {
                    return true;
                }

                // æƒ…å†µ2ï¼šä¸€è½®ç»“æŸï¼ˆå››å®¶éƒ½å‡ºè¿‡ç‰Œï¼Œä¸”æœ€åä¸€å®¶æ˜¯èµ¢å®¶ï¼‰
                const uniquePlayers = new Set(recentCards.map(play => play.player));
                if (uniquePlayers.size === 4) {
                    // æ£€æŸ¥æ˜¯å¦å›åˆ°èµ·å§‹ç©å®¶æˆ–æœ€åå‡ºç‰Œè€…
                    const lastPlay = recentCards[recentCards.length - 1];
                    if (lastPlay && lastPlay.cards.length > 0) {
                        return true;
                    }
                }

                // æƒ…å†µ3ï¼šå½“å‰è½®æ¬¡æœ‰æœ‰æ•ˆå‡ºç‰Œï¼Œä¸”è½®åˆ°èµ·å§‹ç©å®¶
                if (currentRoundPlays.length > 0 && this.currentPlayer === this.getFirstPlayerOfRound()) {
                    return true;
                }

                return false;
            }

            // è·å–å½“å‰è½®æ¬¡çš„èµ·å§‹ç©å®¶
            getFirstPlayerOfRound() {
                if (this.currentRoundCards.length === 0) return this.currentPlayer;

                // æ‰¾åˆ°ç¬¬ä¸€ä¸ªépassçš„ç©å®¶
                for (let play of this.currentRoundCards) {
                    if (play.action !== 'pass' && play.cards.length > 0) {
                        return play.player;
                    }
                }
                return this.currentPlayer;
            }

            // å¼€å§‹æ–°ä¸€è½®ï¼ˆæ¸…é™¤ä¹‹å‰çš„å‡ºç‰Œï¼Œå¹¶æ£€æŸ¥AIç»§ç»­ï¼‰
            startNewRound() {
                this.currentRoundCards = [];
                this.lastPlayer = null;
                this.updatePlayArea();
            }

            // å¼€å§‹æ–°æ¸¸æˆ
            startNewGame() {
                this.isFirstGame = false;
                this.currentRoundCards = [];
                this.lastPlayer = null;
                this.selectedCards = [];
                this.lastPlay = null;

                // æ¸…ç©ºæ‰€æœ‰ç©å®¶æ‰‹ç‰Œ
                for (let pos in this.players) {
                    this.players[pos].cards = [];
                }

                // é‡æ–°åˆå§‹åŒ–æ¸¸æˆ
                this.initializeGame();
            }

            // è¾…åŠ©å‡½æ•°ï¼šæŒ‰ç‚¹æ•°åˆ†ç»„
            groupCardsByRank(cards) {
                const groups = {};
                cards.forEach(card => {
                    if (!groups[card.rank]) {
                        groups[card.rank] = [];
                    }
                    groups[card.rank].push(card);
                });
                return groups;
            }

            // è¾…åŠ©å‡½æ•°ï¼šè·å–ç‰Œé¢å€¼å¤§å°
            getRankValue(rank) {
                const rankOrder = {
                    '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
                    'J': 11, 'Q': 12, 'K': 13, 'A': 14, '2': 15, 'å°ç‹': 16, 'å¤§ç‹': 17
                };
                return rankOrder[rank] || 0;
            }

            showHint() {
                this.showMessage('å»ºè®®ï¼šå‡ºå°ç‰Œæˆ–ä¿ç•™ç‚¸å¼¹åˆ°åæœŸä½¿ç”¨', 'info');
            }

            reportCards() {
                const southCards = this.players.south.cards;
                const message = `ä½ çš„æ‰‹ç‰Œï¼š${southCards.length}å¼ `;
                this.showMessage(message, 'info');
            }

            // æ‰¾åˆ°æ‰€æœ‰å¯èƒ½çš„å‡ºç‰Œ
            findAllPossiblePlays(handCards, lastPlay) {
                const possiblePlays = [];
                let lastType = lastPlay.type;

                // å¦‚æœæ²¡æœ‰typeï¼Œä½¿ç”¨è§„åˆ™å¼•æ“è¯†åˆ«
                if (!lastType && lastPlay.cards) {
                    if (this.useAdvancedEngine && this.ruleEngine) {
                        lastType = this.ruleEngine.getCardType(lastPlay.cards);
                    } else {
                        lastType = this.getCardType(lastPlay.cards);
                    }
                }

                if (!lastType) return possiblePlays;

                // å¦‚æœä¸Šå®¶å‡ºäº†ç«ç®­ï¼Œæ²¡æœ‰ä»»ä½•ç‰Œå¯ä»¥æ‰“
                if (lastType.type === 'rocket') {
                    return possiblePlays; // è¿”å›ç©ºæ•°ç»„ï¼ŒAIåªèƒ½pass
                }

                // 1. å°è¯•ç‚¸å¼¹ï¼ˆå¯ä»¥æ‰“ä»»ä½•ç‰Œï¼‰
                this.tryBombs(handCards, possiblePlays, lastType, lastPlay);

                // 2. æ ¹æ®ä¸Šå®¶ç‰Œå‹æ‰¾å¯¹åº”çš„ç‰Œ
                if (lastType.type === 'single') {
                    this.findSingles(handCards, possiblePlays, lastType, lastPlay);
                } else if (lastType.type === 'pair') {
                    this.findPairs(handCards, possiblePlays, lastType);
                } else if (lastType.type === 'triple') {
                    this.findTriples(handCards, possiblePlays, lastType);
                }
                // TODO: æ·»åŠ ä¸‰å¸¦ä¸€ã€ä¸‰å¸¦äºŒç­‰å¤æ‚ç‰Œå‹çš„å¤„ç†

                // æ’åºï¼šä¼˜å…ˆçº§å°çš„åœ¨å‰ï¼ˆç‚¸å¼¹ä¼˜å…ˆçº§é«˜ä½†æœ€åç”¨ï¼‰
                return possiblePlays.sort((a, b) => {
                    // ç‚¸å¼¹ä¼˜å…ˆçº§ä½ï¼ˆå°½é‡ä¸ç”¨ï¼‰
                    if (a.type.type === 'bomb' && b.type.type !== 'bomb') return 1;
                    if (b.type.type === 'bomb' && a.type.type !== 'bomb') return -1;

                    // æ™®é€šç‰Œå‹æŒ‰å¤§å°æ’åº
                    return this.comparePlayValues(a, b);
                });
            }

            // å°è¯•ç‚¸å¼¹
            tryBombs(handCards, possiblePlays, lastType, lastPlay) {
                const rankGroups = this.groupCardsByRank(handCards);

                // æ£€æŸ¥4å¼ ç‚¸å¼¹
                for (let [rank, cards] of Object.entries(rankGroups)) {
                    if (cards.length >= 4) {
                        const bombCards = cards.slice(0, 4);
                        // ä½¿ç”¨è§„åˆ™å¼•æ“è¯†åˆ«ç‚¸å¼¹
                        let bombType = null;
                        if (this.useAdvancedEngine && this.ruleEngine) {
                            bombType = this.ruleEngine.getCardType(bombCards);
                        } else {
                            bombType = this.getCardType(bombCards);
                        }

                        if (bombType && bombType.type === 'bomb') {
                            // å¦‚æœä¸Šå®¶ä¸æ˜¯ç‚¸å¼¹ï¼Œç‚¸å¼¹å¯ä»¥æ‰“ä»»ä½•ç‰Œ
                            if (lastType.type !== 'bomb') {
                                possiblePlays.push({
                                    cards: bombCards,
                                    type: bombType
                                });
                            } else {
                                // å¦‚æœä¸Šå®¶ä¹Ÿæ˜¯ç‚¸å¼¹ï¼Œæ¯”è¾ƒå¤§å°
                                let canBeat = false;
                                if (this.ruleEngine) {
                                    canBeat = this.ruleEngine.compareCardTypes(bombType, lastType) > 0;
                                } else {
                                    // ç®€å•æ¯”è¾ƒï¼šæ¯”è¾ƒç‚¸å¼¹çš„ä¸»ç‰Œå€¼
                                    canBeat = this.getRankValue(bombCards[0].rank) > this.getRankValue(lastPlay.cards[0].rank);
                                }

                                if (canBeat) {
                                    possiblePlays.push({
                                        cards: bombCards,
                                        type: bombType
                                    });
                                }
                            }
                        }
                    }
                }

                // æ£€æŸ¥ç«ç®­ï¼ˆå¤§å°ç‹ï¼‰
                const jokers = handCards.filter(card => card.suit === 'joker');
                if (jokers.length >= 2) {
                    const hasBig = jokers.some(j => j.rank === 'big');
                    const hasSmall = jokers.some(j => j.rank === 'small');
                    if (hasBig && hasSmall) {
                        const rocketCards = jokers.filter(j => j.rank === 'big' || j.rank === 'small').slice(0, 2);
                        possiblePlays.push({
                            cards: rocketCards,
                            type: { type: 'rocket', subtype: 'kingRocket' }
                        });
                    }
                }
            }

            // æ‰¾å•ç‰Œ
            findSingles(handCards, possiblePlays, lastType, lastPlay) {
                // å¦‚æœä¸Šå®¶å‡ºçš„æ˜¯ç‚¸å¼¹æˆ–ç«ç®­ï¼Œä¸èƒ½ç”¨å•ç‰Œæ‰“
                if (lastType.type === 'bomb' || lastType.type === 'rocket') {
                    return;
                }

                const lastCards = lastType.cards || [];
                const lastValue = lastCards.length > 0 ? this.getRankValue(lastCards[0].rank) : (lastType.rank || lastType.highCard || 0);

                for (let card of handCards) {
                    const cardValue = this.getRankValue(card.rank);
                    if (cardValue > lastValue) {
                        const lastPlayForValidation = {
                            cards: lastCards,
                            type: lastType
                        };
                        const validation = this.rules.validatePlay([card], lastPlayForValidation, handCards);
                        if (validation.valid) {
                            possiblePlays.push({
                                cards: [card],
                                type: validation.cardType
                            });
                        }
                    }
                }
            }

            // æ‰¾å¯¹å­
            findPairs(handCards, possiblePlays, lastType) {
                // å¦‚æœä¸Šå®¶å‡ºçš„æ˜¯ç‚¸å¼¹æˆ–ç«ç®­ï¼Œä¸èƒ½ç”¨å¯¹å­æ‰“
                if (lastType.type === 'bomb' || lastType.type === 'rocket') {
                    return;
                }

                const rankGroups = this.groupCardsByRank(handCards);
                // ä»lastTypeä¸­è·å–ä¸Šå®¶ç‰Œçš„ä¿¡æ¯
                const lastRank = lastType.rank || lastType.highPair || 0;
                const lastCards = lastType.cards || [];

                for (let [rank, cards] of Object.entries(rankGroups)) {
                    if (cards.length >= 2) {
                        const rankValue = this.getRankValue(rank);
                        if (rankValue > lastRank) {
                            const pairCards = cards.slice(0, 2);
                            // æ„é€ lastPlayå¯¹è±¡è¿›è¡ŒéªŒè¯
                            const lastPlayForValidation = {
                                cards: lastCards,
                                type: lastType
                            };
                            const validation = this.rules.validatePlay(pairCards, lastPlayForValidation, handCards);
                            if (validation.valid) {
                                possiblePlays.push({
                                    cards: pairCards,
                                    type: validation.cardType
                                });
                            }
                        }
                    }
                }
            }

            // æ‰¾ä¸‰å¼ 
            findTriples(handCards, possiblePlays, lastType) {
                // å¦‚æœä¸Šå®¶å‡ºçš„æ˜¯ç‚¸å¼¹æˆ–ç«ç®­ï¼Œä¸èƒ½ç”¨ä¸‰å¼ æ‰“
                if (lastType.type === 'bomb' || lastType.type === 'rocket') {
                    return;
                }

                const rankGroups = this.groupCardsByRank(handCards);
                // ä»lastTypeä¸­è·å–ä¸Šå®¶ç‰Œçš„ä¿¡æ¯
                const lastRank = lastType.rank || lastType.highTriple || 0;
                const lastCards = lastType.cards || [];

                for (let [rank, cards] of Object.entries(rankGroups)) {
                    if (cards.length >= 3) {
                        const rankValue = this.getRankValue(rank);
                        if (rankValue > lastRank) {
                            const tripleCards = cards.slice(0, 3);
                            // æ„é€ lastPlayå¯¹è±¡è¿›è¡ŒéªŒè¯
                            const lastPlayForValidation = {
                                cards: lastCards,
                                type: lastType
                            };
                            const validation = this.rules.validatePlay(tripleCards, lastPlayForValidation, handCards);
                            if (validation.valid) {
                                possiblePlays.push({
                                    cards: tripleCards,
                                    type: validation.cardType
                                });
                            }
                        }
                    }
                }
            }

            // æ¯”è¾ƒå‡ºç‰Œå¤§å°
            comparePlayValues(play1, play2) {
                if (!this.ruleEngine) return 0;
                try {
                    return this.ruleEngine.compareCardTypes(play1.type, play2.type);
                } catch (error) {
                    console.warn('[ç‰Œå‹æ¯”è¾ƒé”™è¯¯]', error);
                    return 0;
                }
            }

            // æ˜¾ç¤ºæ¸¸æˆå†…æ¶ˆæ¯
            showMessage(message, type = 'info') {
                const messageBubble = document.getElementById('messageBubble');
                if (messageBubble) {
                    messageBubble.textContent = message;
                    messageBubble.className = 'message-bubble';

                    // æ ¹æ®æ¶ˆæ¯ç±»å‹æ·»åŠ æ ·å¼
                    if (type === 'error') {
                        messageBubble.style.background = '#ff4444';
                        messageBubble.style.animation = 'shake 0.5s';
                    } else if (type === 'success') {
                        messageBubble.style.background = '#4CAF50';
                    } else {
                        messageBubble.style.background = '#2196F3';
                    }

                    // 3ç§’åæ¢å¤é»˜è®¤æ ·å¼
                    setTimeout(() => {
                        messageBubble.style.background = '#2196F3';
                        messageBubble.style.animation = '';
                    }, 3000);
                }
            }

            // å†³å®šé¦–å±€é¦–å‡ºç©å®¶ï¼ˆéšæœºå†³å®šï¼‰
            determineFirstPlayer() {
                // éé¦–å±€ï¼Œç”±ä¸Šå±€æœ«æ¸¸å…ˆå‡º
                if (!this.isFirstGame && this.lastGameLoser) {
                    this.showMessage(`${this.players[this.lastGameLoser].name}æ˜¯ä¸Šå±€æœ«æ¸¸ï¼Œä¼˜å…ˆå‡ºç‰Œ`, 'info');
                    return this.lastGameLoser;
                }

                // é¦–å±€éšæœºå†³å®šé¦–å‡ºç©å®¶
                const order = ['south', 'west', 'north', 'east'];
                const firstPlayer = order[Math.floor(Math.random() * 4)];

                this.showMessage(`${this.players[firstPlayer].name}éšæœºè·å¾—é¦–å‡ºæƒ`, 'info');
                return firstPlayer;
            }

            // è·å–æ‰€æœ‰ç‰Œ
            getAllCards() {
                const allCards = [];
                const suits = ['â™ ', 'â™¥', 'â™£', 'â™¦'];
                const ranks = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A', '2'];

                // æ¯ç§ç‰Œå‹4å¼ 
                for (let suit of suits) {
                    for (let rank of ranks) {
                        for (let i = 0; i < 4; i++) {
                            allCards.push({ suit, rank });
                        }
                    }
                }

                // å¤§å°ç‹
                allCards.push({ suit: 'joker', rank: 'small' });
                allCards.push({ suit: 'joker', rank: 'big' });

                return allCards;
            }

  
            showRecords() {
                this.showMessage('æˆ˜ç»©åŠŸèƒ½å¼€å‘ä¸­...', 'info');
            }

            restartGame() {
                if (confirm('ç¡®å®šè¦é‡æ–°å¼€å§‹æ¸¸æˆå—ï¼Ÿ')) {
                    this.currentRoundCards = [];
                    this.lastPlayer = null;
                    this.selectedCards = [];
                    this.gameState = 'waiting';
                    this.initializeGame();
                }
            }

            showSettings() {
                alert('è®¾ç½®åŠŸèƒ½å¼€å‘ä¸­...');
            }

            getCardType(cards) {
                if (!cards || cards.length === 0) return null;

                // æ£€æŸ¥å¤§å°ç‹ï¼ˆç‚¸å¼¹ï¼‰
                if (cards.length === 1) {
                    if (cards[0].suit === 'joker') {
                        return { type: 'bomb', subtype: 'singleJoker' };
                    }
                    return { type: 'single' };
                } else if (cards.length === 2) {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç«ç®­ï¼ˆå¤§å°ç‹ï¼‰
                    if (cards[0].suit === 'joker' && cards[1].suit === 'joker') {
                        return { type: 'rocket', subtype: 'kingRocket' };
                    }
                    // æ£€æŸ¥æ˜¯å¦æ˜¯å¯¹å­
                    if (cards[0].rank === cards[1].rank) {
                        return { type: 'pair' };
                    }
                    return { type: 'invalid' };
                } else if (cards.length === 3) {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ä¸‰å¼ 
                    if (cards[0].rank === cards[1].rank && cards[1].rank === cards[2].rank) {
                        return { type: 'triple' };
                    }
                    return { type: 'invalid' };
                } else if (cards.length === 4) {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç‚¸å¼¹ï¼ˆ4å¼ åŒç‚¹æ•°ï¼‰
                    const firstRank = cards[0].rank;
                    if (cards.every(card => card.rank === firstRank)) {
                        return { type: 'bomb', subtype: '4bomb' };
                    }
                    // æ£€æŸ¥ä¸‰å¸¦ä¸€
                    const rankCounts = {};
                    cards.forEach(card => {
                        rankCounts[card.rank] = (rankCounts[card.rank] || 0) + 1;
                    });
                    const counts = Object.values(rankCounts);
                    if (counts.includes(3) && counts.includes(1)) {
                        const mainRank = Object.keys(rankCounts).find(rank => rankCounts[rank] === 3);
                        return { type: 'tripleWithOne', mainRank: this.getRankValue(mainRank) };
                    }
                    return { type: 'invalid' };
                } else if (cards.length === 5) {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç‚¸å¼¹ï¼ˆ5å¼ åŒç‚¹æ•°ï¼‰
                    const firstRank = cards[0].rank;
                    if (cards.every(card => card.rank === firstRank)) {
                        return { type: 'bomb', subtype: '5bomb' };
                    }
                    // æ£€æŸ¥ä¸‰å¸¦äºŒ
                    const rankCounts = {};
                    cards.forEach(card => {
                        rankCounts[card.rank] = (rankCounts[card.rank] || 0) + 1;
                    });
                    const counts = Object.values(rankCounts);
                    if (counts.includes(3) && counts.includes(2)) {
                        const mainRank = Object.keys(rankCounts).find(rank => rankCounts[rank] === 3);
                        return { type: 'tripleWithPair', mainRank: this.getRankValue(mainRank) };
                    }
                    return { type: 'invalid' };
                } else if (cards.length >= 6) {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç‚¸å¼¹ï¼ˆ6å¼ æˆ–æ›´å¤šåŒç‚¹æ•°ï¼‰
                    const firstRank = cards[0].rank;
                    if (cards.every(card => card.rank === firstRank)) {
                        return { type: 'bomb', subtype: `${cards.length}bomb` };
                    }
                }

                return { type: 'basic' };
            }

            // éªŒè¯ç‰Œå‹æ˜¯å¦æœ‰æ•ˆ
            isValidPlayType(cardType, expectedCount) {
                if (!cardType || expectedCount <= 0) return false;

                switch (expectedCount) {
                    case 1:
                        return cardType.type === 'single';
                    case 2:
                        return cardType.type === 'pair';
                    case 3:
                        return cardType.type === 'triple';
                    default:
                        // å¯¹äºæ›´å¤šå¼ çš„ç‰Œï¼Œè¿™é‡Œå¯ä»¥æ‰©å±•è§„åˆ™ï¼ˆå¦‚é¡ºå­ã€è¿å¯¹ç­‰ï¼‰
                        return cardType.type !== 'invalid';
                }
            }
        }

        // æ¼è›‹è§„åˆ™å¼•æ“
        class GuandanRules {
            constructor() {
                this.cardOrder = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A', '2', 'å°ç‹', 'å¤§ç‹'];
                this.currentLevel = 2;
                this.jokerCard = null;
                this.initializeLevel();

                // ä½¿ç”¨æ–°å®Œå–„çš„è§„åˆ™å¼•æ“
                try {
                    if (typeof RuleEngine !== 'undefined') {
                        this.ruleEngine = new RuleEngine(null);
                        this.ruleEngine.setLevel(this.currentLevel);
                        this.useAdvancedEngine = true;
                        console.log('[è§„åˆ™å¼•æ“] å·²å¯ç”¨é«˜çº§è§„åˆ™å¼•æ“');
                    }
                } catch (error) {
                    console.warn('[è§„åˆ™å¼•æ“] é«˜çº§å¼•æ“åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨åŸºç¡€å¼•æ“');
                }
            }

            initializeLevel() {
                this.jokerCard = this.currentLevel === 14 ? 'A' : this.currentLevel.toString();
            }

            getCardValue(rank) {
                return this.cardOrder.indexOf(rank);
            }

            validatePlay(cards, lastPlay, playerHand) {
                try {
                    // è°ƒè¯•è¾“å‡º
                    console.log('[validatePlay] å‡ºç‰Œ:', cards.map(c => c.rank + (c.suit === 'joker' ? '' : c.suit)).join(', '));
                    if (lastPlay) {
                        console.log('[validatePlay] ä¸Šå®¶ç‰Œ:', lastPlay.cards ? lastPlay.cards.map(c => c.rank + (c.suit === 'joker' ? '' : c.suit)).join(', ') : 'æœªçŸ¥');
                    }

                    // ä½¿ç”¨æ–°çš„å®˜æ–¹è§„åˆ™å¼•æ“
                    if (this.ruleEngine) {
                        let lastPlayCards = null;
                        if (lastPlay && lastPlay.cards) {
                            lastPlayCards = lastPlay.cards;
                        } else if (lastPlay && Array.isArray(lastPlay)) {
                            lastPlayCards = lastPlay;
                        }

                        const result = this.ruleEngine.validatePlay(cards, lastPlayCards, playerHand);
                        console.log('[validatePlay] è§„åˆ™å¼•æ“ç»“æœ:', result);

                        return result;
                    }
                } catch (error) {
                    console.error('[å‡ºç‰ŒéªŒè¯é”™è¯¯]', error);
                }

                // ç®€å•éªŒè¯
                if (cards.length === 0) {
                    return { valid: false, message: 'æ²¡æœ‰é€‰æ‹©ç‰Œ' };
                }

                return { valid: true, message: 'å‡ºç‰Œåˆæ³•', cardType: { type: 'basic' } };
            }

            getCardType(cards) {
                if (!cards || cards.length === 0) return null;

                // ä½¿ç”¨æ–°çš„å®˜æ–¹è§„åˆ™å¼•æ“
                if (this.ruleEngine) {
                    try {
                        return this.ruleEngine.getCardType(cards);
                    } catch (error) {
                        console.warn('[è§„åˆ™å¼•æ“] ç‰Œå‹è¯†åˆ«å¤±è´¥');
                    }
                }

                // åŸºç¡€ç‰Œå‹è¯†åˆ«
                if (cards.length === 1) {
                    return { type: 'single' };
                }

                return null;
            }
        }

        // å…¨å±€æ¸¸æˆå®ä¾‹
        let game;

        // å…¨å±€å‡½æ•°
        function playCards() {
            if (game) game.playCards();
        }

        function passTurn() {
            if (game) game.passTurn();
        }

        function showHint() {
            if (game) game.showHint();
        }

        function reportCards() {
            if (game) game.reportCards();
        }

        function showRecords() {
            if (game) game.showRecords();
        }

        function restartGame() {
            if (game) game.restartGame();
        }

        function showSettings() {
            if (game) game.showSettings();
        }

        // æ¨¡å—åŒ–åŠ è½½ç®¡ç†å™¨
        class ModuleLoader {
            constructor() {
                this.modules = new Map();
                this.loadProgress = 0;
                this.totalModules = 3;
            }

            updateProgress(moduleName, status, progress = null) {
                this.loadProgress = Math.min(100, this.loadProgress + (100 / this.totalModules));

                document.getElementById('loadingProgress').style.width = this.loadProgress + '%';
                document.getElementById('loadingStatus').textContent = `æ­£åœ¨åŠ è½½ ${moduleName}...`;

                this.log(`[æ¨¡å—åŠ è½½] ${moduleName}: ${status}`);
            }

            log(message) {
                console.log(message);
            }

            handleError(error, moduleName) {
                this.log(`[é”™è¯¯] ${moduleName}: ${error.message}`);
                document.getElementById('errorText').textContent = `${moduleName} åŠ è½½å¤±è´¥: ${error.message}`;
                document.getElementById('errorMessage').classList.add('show');
            }

            async loadAllModules() {
                try {
                    // æ¨¡æ‹ŸåŠ è½½æ¨¡å—
                    this.updateProgress('æ¸¸æˆå¼•æ“', 'loading');
                    await new Promise(resolve => setTimeout(resolve, 500));

                    this.updateProgress('ç•Œé¢ç»„ä»¶', 'loading');
                    await new Promise(resolve => setTimeout(resolve, 500));

                    // åˆå§‹åŒ–æ¸¸æˆ
                    await this.initializeGame();

                    // éšè—åŠ è½½ç”»é¢ï¼Œæ˜¾ç¤ºæ¸¸æˆ
                    setTimeout(() => {
                        document.getElementById('loadingScreen').style.display = 'none';
                        document.getElementById('gameContainer').classList.add('loaded');
                    }, 500);

                    this.log('[ç³»ç»Ÿ] æ‰€æœ‰æ¨¡å—åŠ è½½å®Œæˆï¼Œæ¸¸æˆåˆå§‹åŒ–æˆåŠŸ');

                } catch (error) {
                    this.handleError(error, 'æ¨¡å—åŠ è½½å™¨');
                }
            }

            async initializeGame() {
                try {
                    game = new GuandanGame();
                    this.log('[æ¸¸æˆå¼•æ“] åˆå§‹åŒ–å®Œæˆ');
                } catch (error) {
                    this.handleError(error, 'æ¸¸æˆåˆå§‹åŒ–');
                    throw error;
                }
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆåå¼€å§‹åŠ è½½æ¨¡å—
        document.addEventListener('DOMContentLoaded', () => {
            console.log('é¡µé¢åŠ è½½å®Œæˆï¼Œå¼€å§‹æ¨¡å—åŠ è½½æµç¨‹');
            const loader = new ModuleLoader();

            setTimeout(() => {
                loader.loadAllModules();
            }, 100);
        });

        // å…¨å±€é”™è¯¯å¤„ç†
        window.addEventListener('error', (event) => {
            console.error('[å…¨å±€é”™è¯¯]', event.error);
        });
    </script>
</body>
</html>