<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¼è›‹ - ç°ä»£åŒ–ç•Œé¢ç‰ˆæœ¬</title>

    <!-- å¼•å…¥ç°ä»£åŒ–CSSæ ·å¼ -->
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/responsive.css">
    <link rel="stylesheet" href="css/game-modern.css">

    <style>
        @keyframes shake {
            0%, 100% { transform: translate(-50%, -50%) translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translate(-50%, -50%) translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translate(-50%, -50%) translateX(5px); }
        }

        /* å¼ºåˆ¶ä¿®å¤ç‰Œé¢æ˜¾ç¤ºé—®é¢˜ */
        .player-card.red {
            color: #DC143C !important;
        }
        .player-card.black {
            color: #000 !important;
        }

        /* ç¡®ä¿ç‰Œé¢å†…å®¹å®šä½æ­£ç¡® */
        .player-card .card-top-left,
        .player-card .card-bottom-right {
            position: absolute !important;
        }

        .player-card .card-top-left {
            top: 3px !important;
            left: 3px !important;
        }

        .player-card .card-bottom-right {
            bottom: 3px !important;
            right: 3px !important;
            transform: rotate(180deg) !important;
        }

        /* ç‰Œé¢æ–‡å­—æ ·å¼ */
        .player-card .card-rank {
            font-weight: bold !important;
            font-size: 18px !important; /* ä»14pxå¢åŠ åˆ°18px (1.3å€) */
            line-height: 1 !important;
        }

        .player-card .card-suit {
            font-size: 26px !important; /* ä»20pxå¢åŠ åˆ°26px (1.3å€) */
            line-height: 1 !important;
        }

        /* JOKERç«–å‘æ˜¾ç¤ºæ ·å¼ */
        .player-card .card-rank.joker-text {
            writing-mode: vertical-rl !important;
            text-orientation: upright !important;
            letter-spacing: -3px !important; /* å‡å°‘å­—æ¯é—´è·ï¼Œæ›´ç´§å‡‘ */
            line-height: 0.6 !important; /* å‡å°‘è¡Œé«˜ï¼Œæ›´ç´§å‡‘ */
            font-size: 14px !important; /* æ”¹å›14px */
        }

        .message-bubble {
            /* ç§»é™¤è¿‡æ¸¡åŠ¨ç”»ï¼Œé¿å…ä½ç½®ç§»åŠ¨ */
        }

        /* å¼ºåˆ¶è¦†ç›–é€‰ä¸­ç‰Œçš„æ ·å¼ - ä¿æŒåŸæœ‰z-index */
        .player-card.selected {
            transform: translateY(-20px) scale(1.1) !important;
            border-color: #f39c12 !important;
            border-width: 2px !important;
            background: linear-gradient(135deg, #fff9e6 0%, #fef5e7 100%) !important;
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.5) !important;
            /* ä¿æŒåŸæœ‰çš„z-indexè®¡ç®— */
            z-index: calc(5 * var(--card-index, 1)) !important;
        }

        /* è°ƒè¯•ç”¨ï¼šç¡®ä¿hoveræ•ˆæœä¸å½±å“é€‰ä¸­ */
        .player-card.selected:hover {
            transform: translateY(-20px) scale(1.1) !important;
        }

        /* ç¡®ä¿æ‰‹ç‰Œå®¹å™¨å†…çš„ç‰Œä¿æŒæ­£ç¡®çš„å±‚çº§å…³ç³» */
        #southCards .player-card:nth-child(n) {
            z-index: calc(5 * var(--card-index, 1)) !important;
        }
    </style>
</head>
<body>
    <!-- åŠ è½½ç”»é¢ -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-spinner"></div>
        <div class="loading-text">æ­£åœ¨åŠ è½½æ¼è›‹æ¸¸æˆ...</div>
        <div class="loading-progress">
            <div class="loading-progress-bar" id="loadingProgress"></div>
        </div>
        <div id="loadingStatus">åˆå§‹åŒ–ç»„ä»¶ä¸­...</div>
    </div>

    <!-- é”™è¯¯æ¶ˆæ¯ -->
    <div class="error-message" id="errorMessage">
        <h3>åŠ è½½é”™è¯¯</h3>
        <p id="errorText">æ¸¸æˆç»„ä»¶åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•ã€‚</p>
        <button onclick="location.reload()" class="btn btn-secondary">é‡æ–°åŠ è½½</button>
    </div>

    <!-- æ¸¸æˆä¸»å®¹å™¨ -->
    <div class="game-container" id="gameContainer">
        <!-- æ¶ˆæ¯æç¤ºæ°”æ³¡ -->
        <div id="messageBubble" class="message-bubble" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #2196F3; color: white; padding: 10px 20px; border-radius: 20px; font-size: 14px; z-index: 1000; display: none; box-shadow: 0 2px 10px rgba(0,0,0,0.3);"></div>

        <div class="game-table">
            <!-- é¡¶éƒ¨ä¿¡æ¯æ  -->
            <div class="top-info-bar">
                <div class="info-display coin-display">
                    <span>ğŸ’°</span>
                    <span id="coins">1000</span>
                </div>
                <div class="info-display level-display">
                    <span>â­</span>
                    <span id="level">åˆçº§</span>
                </div>
                <div class="info-display score-display">
                    <span>ğŸ†</span>
                    <span id="score">1250</span>
                </div>
                <button class="settings-btn" onclick="showSettings()">âš™ï¸ è®¾ç½®</button>
            </div>

            <!-- é¡¶éƒ¨å›¢é˜Ÿä¿¡æ¯æ  -->
            <div class="team-info-bar">
                <div class="team-info-item">
                    <div class="team-label">é˜Ÿå‹é˜Ÿ (A)</div>
                    <div class="team-value team-a" id="teamACards">54å¼ </div>
                </div>
                <div class="team-info-item">
                    <div class="team-label">å¯¹æ‰‹é˜Ÿ (B)</div>
                    <div class="team-value team-b" id="teamBCards">54å¼ </div>
                </div>
                <div class="team-info-item">
                    <div class="team-label">å½“å‰çŠ¶æ€</div>
                    <div class="team-value" id="gameStatus">è¿›è¡Œä¸­</div>
                </div>
            </div>

            <!-- åŒ—æ–¹ç©å®¶ï¼ˆå¯¹å®¶ï¼‰ -->
            <div class="player-position player-north">
                <div class="ai-hand-cards" id="northCards">
                    <!-- AIæ‰‹ç‰Œåªæ˜¾ç¤ºç‰ŒèƒŒï¼Œå †å æ•ˆæœ -->
                </div>
                <!-- æ‚¬æµ®ä¿¡æ¯é¢æ¿ -->
                <div class="player-info">
                    <div class="player-avatar">ğŸ¤–</div>
                    <div class="player-details">
                        <div class="player-name-row">
                            <div class="player-name">AIç©å®¶2</div>
                            <div class="team-indicator opponent-indicator" title="å¯¹æ‰‹">ğŸ”´</div>
                        </div>
                        <div class="player-status">
                            <span class="card-count-info">å‰©ä½™: <span id="northCount">27</span>å¼ </span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- è¥¿æ–¹ç©å®¶ï¼ˆé˜Ÿå‹ï¼‰ -->
            <div class="player-position player-west">
                <!-- æ‚¬æµ®ä¿¡æ¯é¢æ¿ - åœ¨æ‰‹ç‰Œå·¦è¾¹ -->
                <div class="player-info">
                    <div class="player-avatar">ğŸ¯</div>
                    <div class="player-details">
                        <div class="player-name-row">
                            <div class="player-name">AIç©å®¶3</div>
                            <div class="team-indicator teammate-indicator" title="é˜Ÿå‹">ğŸ’š</div>
                        </div>
                        <div class="player-status">
                            <span class="card-count-info">å‰©ä½™: <span id="westCount">27</span>å¼ </span>
                        </div>
                    </div>
                </div>
                <!-- æ‰‹ç‰Œ - åœ¨å³è¾¹ -->
                <div class="ai-hand-cards" id="westCards">
                    <!-- AIæ‰‹ç‰Œåªæ˜¾ç¤ºç‰ŒèƒŒï¼Œå †å æ•ˆæœ -->
                </div>
            </div>

            <!-- ä¸œæ–¹ç©å®¶ï¼ˆå¯¹æ‰‹ï¼‰ -->
            <div class="player-position player-east">
                <!-- æ‚¬æµ®ä¿¡æ¯é¢æ¿ - åœ¨æ‰‹ç‰Œå·¦è¾¹ -->
                <div class="player-info">
                    <div class="player-avatar">âš¡</div>
                    <div class="player-details">
                        <div class="player-name-row">
                            <div class="player-name">AIç©å®¶4</div>
                            <div class="team-indicator opponent-indicator" title="å¯¹æ‰‹">ğŸ”´</div>
                        </div>
                        <div class="player-status">
                            <span class="card-count-info">å‰©ä½™: <span id="eastCount">27</span>å¼ </span>
                        </div>
                    </div>
                </div>
                <!-- æ‰‹ç‰Œ - åœ¨å³è¾¹ -->
                <div class="ai-hand-cards" id="eastCards">
                    <!-- AIæ‰‹ç‰Œåªæ˜¾ç¤ºç‰ŒèƒŒï¼Œå †å æ•ˆæœ -->
                </div>
            </div>

            <!-- å—æ–¹ç©å®¶ï¼ˆè‡ªå·±ï¼‰ -->
            <div class="player-position player-south">
                <!-- ä¸»ç©å®¶ä¿¡æ¯é¢æ¿ - æ‰‹ç‰Œå·¦ä¾§ -->
                <div class="player-info main-player-info" id="mainPlayerInfo">
                    <div class="player-avatar">ğŸŒŸ</div>
                    <div class="player-details">
                        <div class="player-name-row">
                            <div class="player-name">å—å®¶(ä½ )</div>
                            <div class="team-indicator teammate-indicator" title="é˜Ÿå‹">ğŸ’š</div>
                        </div>
                        <div class="player-status">
                            <span class="card-count-info">æ‰‹ç‰Œ: <span id="southCardCountDisplay">0</span>å¼ </span>
                        </div>
                        <div class="player-status" id="mainPlayerStatus">å‡†å¤‡ä¸­...</div>
                    </div>
                </div>
                <div class="player-hand-cards" id="southCards">
                    <!-- ç©å®¶æ‰‹ç‰Œå †å æ‘†æ”¾ -->
                </div>
            </div>

            <!-- ä¸­å¤®å‡ºç‰ŒåŒºåŸŸ -->
            <div class="central-play-area" id="centralPlayArea">
                <!-- åŒ—ä½å‡ºç‰Œç»„ - ç‹¬ç«‹åœ¨é¡¶éƒ¨ -->
                <div class="plays-group north-plays" id="northPlays"></div>

                <!-- è¥¿ä½å‡ºç‰Œç»„ - ç‹¬ç«‹åœ¨å·¦ä¾§ -->
                <div class="plays-group west-plays" id="westPlays"></div>

                <!-- ä¸­å¤®çŠ¶æ€æ˜¾ç¤º -->
                <div id="playAreaCenter">
                    <div id="playAreaStatus">ç­‰å¾…å‡ºç‰Œ...</div>
                </div>

                <!-- ä¸œä½å‡ºç‰Œç»„ - ç‹¬ç«‹åœ¨å³ä¾§ -->
                <div class="plays-group east-plays" id="eastPlays"></div>

                <!-- å—ä½å‡ºç‰Œç»„ - ç‹¬ç«‹åœ¨åº•éƒ¨ -->
                <div class="plays-group south-plays" id="southPlays"></div>
            </div>

            <!-- æ§åˆ¶æŒ‰é’®é¢æ¿ -->
            <div class="control-panel">
                <div class="control-buttons">
                    <button class="btn btn-play" id="playBtn" onclick="playCards()" disabled>
                        ğŸš€ å‡ºç‰Œ
                    </button>
                    <button class="btn btn-hint" id="hintBtn" onclick="showHint()">
                        ğŸ’¡ æç¤º
                    </button>
                    <button class="btn btn-pass" id="passBtn" onclick="passTurn()" disabled>
                        âœ‹ ä¸è¦
                    </button>
                    <button class="btn btn-sort" id="sortBtn" onclick="toggleSortMode()" title="åˆ‡æ¢æ’åºæ–¹å¼">
                        ğŸ”€ ç‚¹æ•°
                    </button>
                    <button class="btn btn-report" id="reportBtn" onclick="reportCards()">
                        ğŸ“Š æŠ¥ç‰Œ
                    </button>
                    <button class="btn btn-records" id="recordsBtn" onclick="showRecords()">
                        ğŸ† æˆ˜ç»©
                    </button>
                    <button class="btn btn-restart" id="restartBtn" onclick="restartGame()">
                        ğŸ”„ é‡æ–°å¼€å§‹
                    </button>
                    <button class="btn btn-secondary" onclick="testCardSelection()" style="margin-top: 5px;">
                        ğŸ§ª æµ‹è¯•é€‰ä¸­
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // æµ‹è¯•å‡½æ•° - æ‰‹åŠ¨åˆ‡æ¢ç¬¬ä¸€å¼ ç‰Œçš„é€‰ä¸­çŠ¶æ€
        function testCardSelection() {
            const firstCard = document.querySelector('#southCards .player-card');
            if (firstCard) {
                const isSelected = firstCard.classList.contains('selected');
                if (isSelected) {
                    firstCard.classList.remove('selected');
                    console.log('æµ‹è¯•ï¼šç§»é™¤ç¬¬ä¸€å¼ ç‰Œçš„é€‰ä¸­çŠ¶æ€');
                } else {
                    firstCard.classList.add('selected');
                    console.log('æµ‹è¯•ï¼šæ·»åŠ ç¬¬ä¸€å¼ ç‰Œçš„é€‰ä¸­çŠ¶æ€');
                }
                // å¼ºåˆ¶é‡ç»˜
                firstCard.offsetHeight;
            } else {
                console.log('æ²¡æœ‰æ‰¾åˆ°æ‰‹ç‰Œå…ƒç´ ');
            }
        }
    </script>

    <!-- æ¸¸æˆJavaScript -->
    <!-- å¼•å…¥å¤–éƒ¨JavaScriptç»„ä»¶ -->
    <script src="js/components/RuleEngine.js"></script>
    <script src="js/ui-enhancements.js"></script>

    <!-- å¼•å…¥æµ‹è¯•æ¡†æ¶ -->
    <script src="js/test/TestSuite.js"></script>
    <script src="js/test/TestRunner.js"></script>
    <script src="js/test/tests/CardTypeTests.js"></script>
    <script src="js/test/tests/ComparisonTests.js"></script>
    <script src="js/test/tests/RoundTests.js"></script>
    <script src="js/test/tests/AITests.js"></script>

    <script>
        // æ¸¸æˆçŠ¶æ€ç®¡ç†ï¼ˆä¸åŸç‰ˆä¿æŒä¸€è‡´ï¼‰
        class GuandanGame {
            constructor() {
                this.players = {
                    // æ ‡å‡†æ–¹ä½ï¼šå—-è¥¿-åŒ—-ä¸œï¼ˆé€†æ—¶é’ˆï¼‰
                    east: { id: 'player2', name: 'ä¸œå®¶AI', cards: [], team: 'A', isAI: true },
                    south: { id: 'player1', name: 'å—å®¶(ä½ )', cards: [], team: 'A', isAI: false },
                    west: { id: 'player3', name: 'è¥¿å®¶AI', cards: [], team: 'B', isAI: true },
                    north: { id: 'player4', name: 'åŒ—å®¶AI', cards: [], team: 'B', isAI: true }
                };

                // æ’åºæ¨¡å¼
                this.sortMode = localStorage.getItem('guandan_sortMode') || 'rank'; // 'rank' æˆ– 'pattern'

                // é¦–å±€é€šè¿‡ç¿»ç‰Œå†³å®šé¦–å‡ºç©å®¶
                this.isFirstGame = true;
                this.currentPlayer = null; // å°†åœ¨initializeGameä¸­è®¾ç½®
                this.lastPlayer = null;
                this.currentRoundCards = [];
                this.selectedCards = [];
                this.gameState = 'waiting';
                this.playHistory = [];

                // æ¸¸æˆç»“æœè·Ÿè¸ª
                this.lastGameLoser = null; // ä¸Šå±€æœ«æ¸¸ç©å®¶
                this.gameResults = []; // æ¸¸æˆç»“æœè®°å½•

                // åˆå§‹åŒ–è§„åˆ™å¼•æ“ - ä½¿ç”¨æ–°çš„å®˜æ–¹è§„åˆ™å¼•æ“
                this.ruleEngine = new RuleEngine(this);
                this.rules = this.ruleEngine; // ä¿æŒå…¼å®¹æ€§
                this.lastPlay = null;

                // è½®æ¬¡ç®¡ç†
                this.roundActive = false;
                this.roundPlayers = new Set();
                this.roundStartPlayer = null;
                // è®°å½•æœ¬è½®å·²ç»è¿‡ç‰Œçš„ç©å®¶
                this.roundPassedPlayers = new Set();

                // æ¸¸æˆç»“æŸç›¸å…³
                this.gameRankings = []; // ç©å®¶æ’å [å¤´æ¸¸, äºŒæ¸¸, ä¸‰æ¸¸, æœ«æ¸¸]
                this.gameEnded = false;  // æ¸¸æˆæ˜¯å¦ç»“æŸ
                this.finishedPlayers = []; // å·²å®Œæˆæ¸¸æˆçš„ç©å®¶ï¼ˆæŒ‰å®Œæˆé¡ºåºï¼‰

                // åˆ’é€‰æ‰‹ç‰ŒåŠŸèƒ½
                this.brushSelectState = {
                    isSelecting: false,      // æ˜¯å¦æ­£åœ¨åˆ’é€‰
                    startTime: 0,           // å¼€å§‹æ—¶é—´ï¼ˆç”¨äºåˆ¤æ–­æ˜¯å¦ä¸ºå•å‡»ï¼‰
                    startX: 0,              // å¼€å§‹Xåæ ‡
                    startY: 0,              // å¼€å§‹Yåæ ‡
                    selectedIds: new Set(), // å·²åˆ’é€‰çš„ç‰ŒIDé›†åˆ
                    processedIds: new Set() // å·²å¤„ç†çš„ç‰ŒIDé›†åˆï¼ˆé¿å…é‡å¤å¤„ç†ï¼‰
                };

                // æ™ºèƒ½æç¤ºåŠŸèƒ½
                this.currentHintIndex = 0;        // å½“å‰æç¤ºç´¢å¼•
                this.availableHints = [];          // æ‰€æœ‰å¯ç”¨æç¤º
                this.isHintMode = false;          // æç¤ºæ¨¡å¼çŠ¶æ€
                this.lastHintTime = 0;            // é˜²æ­¢é‡å¤ç‚¹å‡»

                // å‡çº§æœºåˆ¶
                this.teamAScore = 0;
                this.teamBScore = 0;
                this.currentLevel = 2;
                this.gameHistory = [];
                this.currentDealer = null;

                // AIè®°ç‰Œç³»ç»Ÿ
                this.playedCards = []; // å·²å‡ºçš„ç‰Œ
                this.cardMemory = {
                    south: [], // è®°å½•å—å®¶å‡ºçš„ç‰Œ
                    west: [],  // è®°å½•è¥¿å®¶å‡ºçš„ç‰Œ
                    north: [], // è®°å½•åŒ—å®¶å‡ºçš„ç‰Œ
                    east: []   // è®°å½•ä¸œå®¶å‡ºçš„ç‰Œ
                };

                // éŸ³é¢‘ç³»ç»Ÿ
                this.audioContext = null;

                // è®¾ç½®è§„åˆ™å¼•æ“çš„åˆå§‹çº§åˆ«
                if (this.ruleEngine) {
                    this.ruleEngine.setLevel(this.currentLevel);
                }

                this.initializeGame();
            }

            // è¾…åŠ©å‡½æ•°ï¼šè·å–ç‰Œé¢æ˜¾ç¤ºå†…å®¹
            getCardDisplay(card) {
                if (card.rank === 'å°ç‹') {
                    return { rank: 'ç‹', suit: '', color: 'black', isJoker: true };
                } else if (card.rank === 'å¤§ç‹') {
                    return { rank: 'ç‹', suit: '', color: 'red', isJoker: true };
                }
                return { rank: card.rank, suit: card.suit, color: card.isRed ? 'red' : 'black', isJoker: false };
            }

            initializeGame() {
                this.dealCards();

                // å†³å®šé¦–å‡ºç©å®¶
                this.currentPlayer = this.determineFirstPlayer();
                console.log(`æ¸¸æˆåˆå§‹åŒ–å®Œæˆï¼Œé¦–å‡ºç©å®¶ï¼š${this.currentPlayer}`);

                // åˆå§‹åŒ–æ’åºæŒ‰é’®æ˜¾ç¤º
                const sortBtn = document.getElementById('sortBtn');
                if (sortBtn) {
                    if (this.sortMode === 'pattern') {
                        sortBtn.innerHTML = 'ğŸ¯ ç‰Œå‹';
                        sortBtn.title = 'åˆ‡æ¢åˆ°ç‚¹æ•°æ’åº';
                    } else {
                        sortBtn.innerHTML = 'ğŸ”€ ç‚¹æ•°';
                        sortBtn.title = 'åˆ‡æ¢åˆ°ç‰Œå‹æ’åº';
                    }
                }

                this.updateUI();
                this.gameState = 'playing';

                // å¦‚æœé¦–å‡ºç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨å‡ºç‰Œ
                if (this.players[this.currentPlayer].isAI) {
                    console.log(`é¦–å‡ºç©å®¶ ${this.currentPlayer} æ˜¯AIï¼Œè‡ªåŠ¨å‡ºç‰Œ`);
                    setTimeout(() => this.aiAutoPlay(), 1500);
                }
            }

            dealCards() {
                console.log('[dealCards] å¼€å§‹å‘ç‰Œï¼Œæ¸…ç©ºå‰æ£€æŸ¥æ‰‹ç‰Œæ•°é‡:');
                console.log(`  - å—å®¶: ${this.players.south.cards.length}å¼ `);
                console.log(`  - è¥¿å®¶: ${this.players.west.cards.length}å¼ `);
                console.log(`  - åŒ—å®¶: ${this.players.north.cards.length}å¼ `);
                console.log(`  - ä¸œå®¶: ${this.players.east.cards.length}å¼ `);

                // åˆ›å»ºç‰Œç»„å¹¶åˆ†å‘
                const deck = this.createDeck();
                const positions = ['south', 'west', 'north', 'east']; // æŒ‰é€†æ—¶é’ˆé¡ºåºå‘ç‰Œ

                // æ¼è›‹è§„åˆ™ï¼šæ¯äºº27å¼ ç‰Œï¼Œæ€»å…±108å¼ 
                const cardsPerPlayer = 27;

                console.log(`[å‘ç‰Œ] æ€»ç‰Œæ•°: ${deck.length}, æ¯äºº${cardsPerPlayer}å¼ `);

                // æ¸…ç©ºç©å®¶æ‰‹ç‰Œ
                positions.forEach(pos => {
                    this.players[pos].cards = [];
                    console.log(`[å‘ç‰Œ] å·²æ¸…ç©º${pos}çš„æ‰‹ç‰Œ`);
                });

                // ç›´æ¥å‘ç‰Œï¼Œæ¯äºº27å¼ 
                let cardIndex = 0;
                positions.forEach((pos) => {
                    for (let i = 0; i < cardsPerPlayer; i++) {
                        this.players[pos].cards.push(deck[cardIndex]);
                        cardIndex++;
                    }
                    console.log(`${pos} ç©å®¶è·å¾— ${this.players[pos].cards.length} å¼ ç‰Œ`);
                });

                // éªŒè¯æ€»ç‰Œæ•°
                const totalCards = Object.values(this.players).reduce((sum, p) => sum + p.cards.length, 0);
                console.log(`æ€»å…±åˆ†é… ${totalCards} å¼ ç‰Œï¼Œä½¿ç”¨äº† ${cardIndex} å¼ ç‰Œ`);

                // éªŒè¯æ¯ä¸ªç©å®¶çš„ç‰Œæ•°
                console.log(`[å‘ç‰ŒéªŒè¯] å—å®¶(ç©å®¶)æ‰‹ç‰Œæ•°: ${this.players.south.cards.length}`);
                console.log(`[å‘ç‰ŒéªŒè¯] è¥¿å®¶(AI)æ‰‹ç‰Œæ•°: ${this.players.west.cards.length}`);
                console.log(`[å‘ç‰ŒéªŒè¯] åŒ—å®¶(AI)æ‰‹ç‰Œæ•°: ${this.players.north.cards.length}`);
                console.log(`[å‘ç‰ŒéªŒè¯] ä¸œå®¶(AI)æ‰‹ç‰Œæ•°: ${this.players.east.cards.length}`);

                // å¯¹æ‰‹ç‰Œè¿›è¡Œæ’åºï¼ˆåªå¯¹äººç±»ç©å®¶ï¼‰
                this.sortPlayerCards('south');
            }

            createDeck() {
                const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
                const ranks = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A', '2'];
                const deck = [];
                let cardIdCounter = 0; // ç”¨äºç”Ÿæˆå”¯ä¸€ID

                // åˆ›å»ºä¸¤å‰¯ç‰Œï¼ˆæ¼è›‹ä½¿ç”¨ä¸¤å‰¯ç‰Œï¼‰
                for (let deckCount = 0; deckCount < 2; deckCount++) {
                    for (let suit = 0; suit < 4; suit++) {
                        for (let rank = 0; rank < 13; rank++) {
                            deck.push({
                                id: `card_${cardIdCounter++}`, // æ·»åŠ å”¯ä¸€ID
                                suit: suits[suit],
                                rank: ranks[rank],
                                value: rank + 3,
                                isRed: suit === 1 || suit === 2,
                                deckId: deckCount + 1 // æ ‡è®°æ¥è‡ªå“ªå‰¯ç‰Œ
                            });
                        }
                    }
                }

                // æ·»åŠ å¤§å°ç‹ï¼ˆä¸¤å‰¯ç‰Œå„2å¼ ï¼Œå…±4å¼ ç‹ç‰Œï¼‰
                deck.push({
                    id: `card_${cardIdCounter++}`,
                    suit: 'joker',
                    rank: 'å°ç‹',
                    value: 16,
                    isRed: true,
                    deckId: 1
                });
                deck.push({
                    id: `card_${cardIdCounter++}`,
                    suit: 'joker',
                    rank: 'å°ç‹',
                    value: 16,
                    isRed: true,
                    deckId: 2
                });
                deck.push({
                    id: `card_${cardIdCounter++}`,
                    suit: 'joker',
                    rank: 'å¤§ç‹',
                    value: 17,
                    isRed: true,
                    deckId: 1
                });
                deck.push({
                    id: `card_${cardIdCounter++}`,
                    suit: 'joker',
                    rank: 'å¤§ç‹',
                    value: 17,
                    isRed: true,
                    deckId: 2
                });

                console.log(`[createDeck] åˆ›å»ºäº† ${deck.length} å¼ ç‰Œï¼Œæ¯å¼ éƒ½æœ‰å”¯ä¸€ID`);
                return this.shuffleArray(deck);
            }

            shuffleArray(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }

            updateUI() {
                this.updatePlayerCards();
                this.updatePlayArea();
                this.updateInfoBars();
                this.updateControlButtons();
                // åŒæ­¥é€‰ä¸­çŠ¶æ€
                this.syncSelectedState();
            }

            /**
             * æ›´æ–°UIä½†ä¸é‡æ–°æ¸²æŸ“ç©å®¶æ‰‹ç‰Œ
             */
            updateUINoPlayerCards() {
                this.updatePlayArea();
                this.updateInfoBars();
                this.updateControlButtons();
                // åŒæ­¥é€‰ä¸­çŠ¶æ€
                this.syncSelectedState();
            }

            /**
             * åŒæ­¥é€‰ä¸­çŠ¶æ€ - ç¡®ä¿DOMå’ŒselectedCardsæ•°ç»„ä¸€è‡´
             */
            syncSelectedState() {
                // ä»DOMä¸­æŸ¥æ‰¾æ‰€æœ‰é€‰ä¸­å…ƒç´ 
                const selectedElements = document.querySelectorAll('#southCards .player-card.selected');

                // å¦‚æœDOMå’Œæ•°ç»„ä¸ä¸€è‡´ï¼Œå¼ºåˆ¶åŒæ­¥
                if (selectedElements.length !== this.selectedCards.length) {
                    console.warn(`[syncSelectedState] çŠ¶æ€ä¸ä¸€è‡´ï¼DOMé€‰ä¸­${selectedElements.length}å¼ ï¼Œæ•°ç»„ä¸­æœ‰${this.selectedCards.length}å¼ `);
                    console.log(`[syncSelectedState] é€‰ä¸­å…ƒç´ åˆ—è¡¨:`, Array.from(selectedElements).map(el => {
                        const index = parseInt(el.dataset.index);
                        const card = this.players.south.cards[index];
                        return card ? `${card.rank}${card.suit}` : 'æœªçŸ¥';
                    }));

                    // æ¸…ç©ºselectedCardsæ•°ç»„
                    this.selectedCards = [];

                    // ä»DOMä¸­é‡æ–°æ„å»ºselectedCardsæ•°ç»„
                    selectedElements.forEach(element => {
                        const index = parseInt(element.dataset.index);
                        const card = this.players.south.cards[index];
                        if (card) {
                            this.selectedCards.push(card);
                        }
                    });

                    console.log(`[syncSelectedState] å¼ºåˆ¶åŒæ­¥å®Œæˆï¼Œæ¢å¤${this.selectedCards.length}å¼ ç‰Œ`);
                }
            }

            updatePlayerCards() {
                // æ›´æ–°AIç©å®¶æ‰‹ç‰Œæ˜¾ç¤º
                ['north', 'west', 'east'].forEach(pos => {
                    const cardCount = this.players[pos].cards.length;
                    const container = document.getElementById(pos + 'Cards');
                    container.innerHTML = '';

                    // æ˜¾ç¤ºç‰ŒèƒŒï¼Œæ•°é‡ä¸å®é™…æ‰‹ç‰Œæ•°å¯¹åº”
                    const displayCount = Math.min(cardCount, 5);
                    for (let i = 0; i < displayCount; i++) {
                        const cardElement = document.createElement('div');
                        cardElement.className = 'ai-card-back';
                        cardElement.innerHTML = 'ğŸ‚ ';
                        container.appendChild(cardElement);
                    }

                    // æ›´æ–°AIç©å®¶ç‰Œæ•°æ˜¾ç¤º
                    const countElement = document.getElementById(pos + 'Count');
                    if (countElement) {
                        countElement.textContent = cardCount;
                    }
                });

                // æ›´æ–°ç©å®¶æ‰‹ç‰Œæ˜¾ç¤º
                const southCards = this.players.south.cards;
                const southContainer = document.getElementById('southCards');
                southContainer.innerHTML = '';

                southCards.forEach((card, index) => {
                    const cardElement = document.createElement('div');
                    const display = this.getCardDisplay(card);
                    cardElement.className = `player-card ${display.color}`;

                    // ç”Ÿæˆç‰Œçš„HTMLå†…å®¹
                    let cardHTML = '<div class="card-content">';

                    if (display.isJoker) {
                        // å¤§å°ç‹çš„ç‰¹æ®Šæ˜¾ç¤º
                        cardHTML += `
                            <div class="card-top-left">
                                <div class="card-rank joker-text">${card.rank}</div>
                            </div>
                            <div class="card-bottom-right">
                                <div class="card-rank joker-text">${card.rank}</div>
                            </div>
                        `;
                    } else {
                        // æ™®é€šç‰Œçš„æ˜¾ç¤º
                        cardHTML += `
                            <div class="card-top-left">
                                <div class="card-rank">${display.rank}</div>
                                <div class="card-suit">${display.suit}</div>
                            </div>
                            <div class="card-bottom-right">
                                <div class="card-rank">${display.rank}</div>
                                <div class="card-suit">${display.suit}</div>
                            </div>
                        `;
                    }

                    cardHTML += '</div>';
                    cardElement.innerHTML = cardHTML;

                    cardElement.style.setProperty('--card-index', index + 1);

                    // æ·»åŠ åˆ’é€‰éœ€è¦çš„æ•°æ®å±æ€§
                    cardElement.dataset.index = index;
                    cardElement.dataset.cardId = card.id || `${card.rank}${card.suit}`;
                    cardElement.dataset.selected = 'false';

                    // ç¡®ä¿æ–°å‘çš„ç‰Œæ²¡æœ‰é€‰ä¸­çŠ¶æ€
                    cardElement.classList.remove('selected');

                    // ç§»é™¤onclickï¼Œæ”¹ç”¨addEventListenerå¤„ç†ç‚¹å‡»
                    // cardElement.onclick = () => this.selectCard(card, cardElement);
                    cardElement.addEventListener('click', (e) => {
                        // å¦‚æœæ˜¯åˆ’é€‰æ“ä½œï¼Œä¸å¤„ç†clickäº‹ä»¶
                        if (this.brushSelectState && this.brushSelectState.isSelecting) {
                            // å¦‚æœåˆ’é€‰æ¥è‡ªmousedownä¸”æ²¡æœ‰ç§»åŠ¨ï¼Œè¯´æ˜æ˜¯å•å‡»ï¼Œéœ€è¦æ¸…ç†çŠ¶æ€
                            if (this.brushSelectState.isFromMouseDown && !this.brushSelectState.hasMoved) {
                                console.log('[ç‚¹å‡»] æ¸…ç†mousedowné€ æˆçš„åˆ’é€‰çŠ¶æ€');
                                // æ¸…ç†çŠ¶æ€ï¼Œè®©æ­£å¸¸ç‚¹å‡»å¯ä»¥ç»§ç»­
                                this.brushSelectState.isSelecting = false;
                            } else {
                                console.log('[ç‚¹å‡»] å¿½ç•¥ï¼šåˆ’é€‰è¿›è¡Œä¸­');
                                return;
                            }
                        }

                        // ç›´æ¥å¤„ç†å•å‡»
                        e.stopPropagation();
                        console.log('[ç‚¹å‡»] å¤„ç†å•å‡»äº‹ä»¶');
                        this.selectCard(card, cardElement);
                    });

                    // æ·»åŠ åˆ’é€‰äº‹ä»¶ç›‘å¬å™¨
                    cardElement.addEventListener('mousedown', (e) => this.handleBrushStart(e, cardElement, card));
                    cardElement.addEventListener('mouseenter', (e) => this.handleBrushEnter(e, cardElement, card));

                    southContainer.appendChild(cardElement);
                });

                // æ›´æ–°å—æ–¹ç©å®¶å‰©ä½™ç‰Œæ•°
                const southCountElement = document.getElementById('southCardCountDisplay');
                if (southCountElement) {
                    southCountElement.textContent = southCards.length;
                }
            }

            // ========== æ’åºç›¸å…³æ–¹æ³• ==========

            /**
             * åˆ‡æ¢æ’åºæ¨¡å¼
             */
            toggleSortMode() {
                // è®°å½•åˆ‡æ¢å‰çš„æ¨¡å¼
                const oldMode = this.sortMode;

                // åˆ‡æ¢æ’åºæ¨¡å¼
                this.sortMode = this.sortMode === 'rank' ? 'pattern' : 'rank';
                localStorage.setItem('guandan_sortMode', this.sortMode);

                console.log(`[toggleSortMode] æ¨¡å¼åˆ‡æ¢: ${oldMode} -> ${this.sortMode}`);

                // ä¿å­˜å·²é€‰ä¸­çš„ç‰Œï¼ˆä½¿ç”¨å”¯ä¸€æ ‡è¯†ï¼‰
                const selectedCardIds = new Set();
                console.log(`[toggleSortMode] ä¿å­˜å‰æœ‰${this.selectedCards.length}å¼ é€‰ä¸­ç‰Œ`);
                this.selectedCards.forEach(card => {
                    const cardId = card.id || (card.rank + card.suit);
                    selectedCardIds.add(cardId);
                    console.log(`[toggleSortMode] ä¿å­˜ç‰Œ: ${card.rank}${card.suit}, ID: ${cardId}`);
                });

                console.log(`[toggleSortMode] Setä¸­æœ‰${selectedCardIds.size}å¼ å”¯ä¸€ç‰Œ`, Array.from(selectedCardIds));

                // é‡æ–°æ’åºæ‰‹ç‰Œ
                this.sortPlayerCards('south');

                // æ¢å¤é€‰ä¸­çŠ¶æ€ï¼ˆåœ¨UIæ›´æ–°åæ‰§è¡Œï¼‰
                setTimeout(() => {
                    // å…ˆæ¸…ç©ºselectedCardsæ•°ç»„
                    this.selectedCards = [];
                    const usedIds = new Set(); // è·Ÿè¸ªå·²ä½¿ç”¨çš„ID

                    document.querySelectorAll('#southCards .player-card').forEach((cardElement, index) => {
                        const card = this.players.south.cards[index];
                        if (!card) return;

                        const cardId = card.id || (card.rank + card.suit);

                        // æ£€æŸ¥æ˜¯å¦åº”è¯¥é€‰ä¸­è¿™å¼ ç‰Œï¼Œå¹¶ä¸”è¯¥IDæœªè¢«ä½¿ç”¨è¿‡
                        if (selectedCardIds.has(cardId) && !usedIds.has(cardId)) {
                            // æ ‡è®°æ­¤IDå·²ä½¿ç”¨
                            usedIds.add(cardId);

                            // ç¡®ä¿DOMæœ‰é€‰ä¸­æ ·å¼
                            if (!cardElement.classList.contains('selected')) {
                                cardElement.classList.add('selected');
                            }
                            // æ·»åŠ åˆ°æ•°ç»„
                            this.selectedCards.push(card);
                            console.log(`[toggleSortMode] æ¢å¤é€‰ä¸­: ${card.rank}${card.suit} (ID: ${cardId})`);
                        } else {
                            // ç¡®ä¿DOMæ²¡æœ‰é€‰ä¸­æ ·å¼
                            if (cardElement.classList.contains('selected')) {
                                cardElement.classList.remove('selected');
                            }
                        }
                    });

                    console.log(`[toggleSortMode] æ¢å¤å®Œæˆï¼Œå…±${this.selectedCards.length}å¼ ç‰Œ`);

                    // é‡æ–°æ¸²æŸ“ç©å®¶æ‰‹ç‰Œä»¥æ˜¾ç¤ºæ–°çš„æ’åº
                    this.updatePlayerCards();

                    // åœ¨åŒä¸€ä¸ªsetTimeoutå†…æ›´æ–°æŒ‰é’®æ˜¾ç¤º
                    const sortBtn = document.getElementById('sortBtn');
                    console.log('[toggleSortMode] è·å–æŒ‰é’®å…ƒç´ :', sortBtn);
                    if (sortBtn) {
                        console.log(`[toggleSortMode] å½“å‰sortMode: ${this.sortMode}`);
                        if (this.sortMode === 'pattern') {
                            sortBtn.innerHTML = 'ğŸ¯ ç‰Œå‹';
                            sortBtn.title = 'åˆ‡æ¢åˆ°ç‚¹æ•°æ’åº';
                            console.log('[toggleSortMode] æŒ‰é’®æ–‡å­—æ›´æ–°ä¸º: ğŸ¯ ç‰Œå‹');
                        } else {
                            sortBtn.innerHTML = 'ğŸ”€ ç‚¹æ•°';
                            sortBtn.title = 'åˆ‡æ¢åˆ°ç‰Œå‹æ’åº';
                            console.log('[toggleSortMode] æŒ‰é’®æ–‡å­—æ›´æ–°ä¸º: ğŸ”€ ç‚¹æ•°');
                        }
                        console.log('[toggleSortMode] æŒ‰é’®innerHTMLå®é™…å€¼:', sortBtn.innerHTML);
                    } else {
                        console.error('[toggleSortMode] æ— æ³•æ‰¾åˆ°sortBtnå…ƒç´ ');
                    }
                }, 50);

                // æ˜¾ç¤ºæç¤º
                const modeText = this.sortMode === 'pattern' ? 'ç‰Œå‹' : 'ç‚¹æ•°';
                const message = `å·²åˆ‡æ¢åˆ°${modeText}æ’åº`;
                console.log('[toggleSortMode]', message);
                this.showMessage(message, 'info');
            }

            /**
             * æ’åºç©å®¶æ‰‹ç‰Œ
             * @param {string} playerId - ç©å®¶ID
             */
            sortPlayerCards(playerId) {
                const player = this.players[playerId];
                if (!player || player.isAI) return;

                if (this.sortMode === 'pattern') {
                    // æŒ‰ç‰Œå‹æ’åº
                    player.cards = this.sortCardsByPattern(player.cards);
                } else {
                    // æŒ‰ç‚¹æ•°æ’åºï¼ˆé»˜è®¤ï¼‰
                    player.cards.sort((a, b) => this.getRankValue(b.rank) - this.getRankValue(a.rank));
                }
            }

            /**
             * æŒ‰ç‰Œå‹æ’åºæ‰‹ç‰Œ
             * @param {Array} cards - æ‰‹ç‰Œæ•°ç»„
             * @returns {Array} æ’åºåçš„æ‰‹ç‰Œ
             */
            sortCardsByPattern(cards) {
                // ç‰Œå‹ä¼˜å…ˆçº§ï¼ˆæ•°å€¼è¶Šå¤§ä¼˜å…ˆçº§è¶Šé«˜ï¼‰
                const patternPriority = {
                    'king_bomb': 12,      // å¤©ç‹ç‚¸ï¼ˆ4å¼ ç‹ï¼‰
                    'bomb_8': 11,         // 8ç‚¸
                    'bomb_7': 10,         // 7ç‚¸
                    'bomb_6': 9,          // 6ç‚¸
                    'straight_flush': 8,  // åŒèŠ±é¡º
                    'bomb_5': 7,          // 5ç‚¸
                    'bomb_4': 6,          // 4ç‚¸
                    'airplane': 5,        // é’¢æ¿ï¼ˆè¿ä¸‰ï¼‰
                    'consecutive_pairs': 4, // è¿å¯¹
                    'straight': 3,        // é¡ºå­
                    'three_with_pair': 2, // ä¸‰å¸¦äºŒ
                    'triple': 1,          // ä¸‰å¼ 
                    'pair': 0,            // å¯¹å­
                    'single': -1          // å•å¼ 
                };

                // æŒ‰ç‰Œå€¼åˆ†ç»„
                const rankGroups = {};
                cards.forEach(card => {
                    if (!rankGroups[card.rank]) {
                        rankGroups[card.rank] = [];
                    }
                    rankGroups[card.rank].push(card);
                });

                const groups = {
                    king_bomb: [],
                    bomb_8: [],
                    bomb_7: [],
                    bomb_6: [],
                    straight_flush: [],
                    bomb_5: [],
                    bomb_4: [],
                    airplane: [],
                    consecutive_pairs: [],
                    straight: [],
                    three_with_pair: [],
                    triple: [],
                    pair: [],
                    single: []
                };

                const usedCards = new Set();

                // 1. è¯†åˆ«å¤©ç‹ç‚¸ï¼ˆ4å¼ ç‹ï¼‰
                const jokers = cards.filter(card => card.suit === 'joker');
                if (jokers.length === 4) {
                    groups.king_bomb.push(jokers);
                    jokers.forEach(card => usedCards.add(card));
                }

                // 2. è¯†åˆ«ç‚¸å¼¹ï¼ˆ4å¼ åŠä»¥ä¸ŠåŒç‚¹æ•°ï¼‰
                for (let rank in rankGroups) {
                    const count = rankGroups[rank].length;
                    if (count >= 4 && rank !== 'å°ç‹' && rank !== 'å¤§ç‹') {
                        const bomb = rankGroups[rank].slice(0, count);

                        // æ ¹æ®å¼ æ•°åˆ†ç±»
                        if (count >= 8) {
                            groups.bomb_8.push(bomb);
                        } else if (count >= 7) {
                            groups.bomb_7.push(bomb);
                        } else if (count >= 6) {
                            groups.bomb_6.push(bomb);
                        } else if (count >= 5) {
                            groups.bomb_5.push(bomb);
                        } else {
                            groups.bomb_4.push(bomb);
                        }

                        bomb.forEach(card => usedCards.add(card));
                    }
                }

                // 3. è¯†åˆ«åŒèŠ±é¡ºï¼ˆ5å¼ ä»¥ä¸ŠåŒèŠ±è‰²è¿ç»­ï¼‰
                const suitGroups = {};
                cards.forEach(card => {
                    if (!usedCards.has(card) && card.suit !== 'joker' && card.rank !== '2') {
                        if (!suitGroups[card.suit]) {
                            suitGroups[card.suit] = [];
                        }
                        suitGroups[card.suit].push(card);
                    }
                });

                for (let suit in suitGroups) {
                    const suitCards = suitGroups[suit];
                    suitCards.sort((a, b) => this.getRankValue(a.rank) - this.getRankValue(b.rank));

                    // æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„åŒèŠ±é¡º
                    for (let i = 0; i <= suitCards.length - 5; i++) {
                        for (let length = 5; length <= suitCards.length - i; length++) {
                            const straight = suitCards.slice(i, i + length);
                            let isConsecutive = true;

                            for (let j = 1; j < straight.length; j++) {
                                if (this.getRankValue(straight[j].rank) !== this.getRankValue(straight[j-1].rank) + 1) {
                                    isConsecutive = false;
                                    break;
                                }
                            }

                            if (isConsecutive && !straight.some(card => usedCards.has(card))) {
                                groups.straight_flush.push(straight);
                                straight.forEach(card => usedCards.add(card));
                                break; // åªå–æœ€é•¿çš„åŒèŠ±é¡º
                            }
                        }
                    }
                }

                // 4. è¯†åˆ«è¿å¯¹ï¼ˆ3å¯¹åŠä»¥ä¸Šè¿ç»­å¯¹å­ï¼‰
                const pairs = [];
                for (let rank in rankGroups) {
                    if (rankGroups[rank].length >= 2) {
                        const availableCards = rankGroups[rank].filter(card => !usedCards.has(card));
                        if (availableCards.length >= 2) {
                            pairs.push({
                                rank: rank,
                                value: this.getRankValue(rank),
                                cards: availableCards.slice(0, 2)
                            });
                        }
                    }
                }

                // æ£€æŸ¥æ˜¯å¦æœ‰ç‹å¯¹ï¼ˆå¤§ç‹+å°ç‹ï¼‰
                // é‡ç”¨ä¹‹å‰å®šä¹‰çš„jokersæ•°ç»„ï¼Œä½†éœ€è¦å…ˆè¿‡æ»¤å·²ä½¿ç”¨çš„ç‰Œ
                const availableJokers = jokers.filter(card => !usedCards.has(card));
                if (availableJokers.length === 2) {
                    // æ‰¾åˆ°å¤§ç‹å’Œå°ç‹ï¼Œåˆ›å»ºç‹å¯¹
                    const bigJoker = availableJokers.find(c => c.rank === 'å¤§ç‹');
                    const smallJoker = availableJokers.find(c => c.rank === 'å°ç‹');
                    if (bigJoker && smallJoker) {
                        pairs.unshift({
                            rank: 'ç‹å¯¹',
                            value: 999,  // ç¡®ä¿ç‹å¯¹æ’åœ¨æœ€å‰é¢
                            cards: [bigJoker, smallJoker]
                        });
                        // æ ‡è®°å·²ä½¿ç”¨
                        usedCards.add(bigJoker);
                        usedCards.add(smallJoker);
                    }
                }

                pairs.sort((a, b) => b.value - a.value);

                // æŸ¥æ‰¾è¿ç»­çš„å¯¹å­
                for (let i = 0; i <= pairs.length - 3; i++) {
                    let consecutivePairs = [pairs[i]];
                    let j = i + 1;

                    while (j < pairs.length && pairs[j].value === pairs[j-1].value - 1) {
                        consecutivePairs.push(pairs[j]);
                        j++;
                    }

                    if (consecutivePairs.length >= 3) {
                        const allPairs = consecutivePairs.flatMap(p => p.cards);
                        groups.consecutive_pairs.push(allPairs);
                        allPairs.forEach(card => usedCards.add(card));
                    }
                }

                // 5. è¯†åˆ«é’¢æ¿ï¼ˆè¿ä¸‰/é£æœºï¼‰
                const triples = [];
                for (let rank in rankGroups) {
                    if (rankGroups[rank].length >= 3) {
                        const availableCards = rankGroups[rank].filter(card => !usedCards.has(card));
                        if (availableCards.length >= 3) {
                            triples.push({
                                rank: rank,
                                value: this.getRankValue(rank),
                                cards: availableCards.slice(0, 3)
                            });
                        }
                    }
                }
                triples.sort((a, b) => b.value - a.value);

                // æŸ¥æ‰¾è¿ç»­çš„ä¸‰å¼ 
                for (let i = 0; i <= triples.length - 2; i++) {
                    let consecutiveTriples = [triples[i]];
                    let j = i + 1;

                    while (j < triples.length && triples[j].value === triples[j-1].value - 1) {
                        consecutiveTriples.push(triples[j]);
                        j++;
                    }

                    if (consecutiveTriples.length >= 2) {
                        const allTriples = consecutiveTriples.flatMap(t => t.cards);
                        groups.airplane.push(allTriples);
                        allTriples.forEach(card => usedCards.add(card));
                    }
                }

                // 6. è¯†åˆ«é¡ºå­ï¼ˆ5å¼ åŠä»¥ä¸Šè¿ç»­å•ç‰Œï¼‰
                const nonJokerCards = cards.filter(card =>
                    !usedCards.has(card) &&
                    card.suit !== 'joker' &&
                    card.rank !== '2'
                );
                nonJokerCards.sort((a, b) => this.getRankValue(a.rank) - this.getRankValue(b.rank));

                for (let i = 0; i <= nonJokerCards.length - 5; i++) {
                    for (let length = 5; length <= nonJokerCards.length - i; length++) {
                        const straight = nonJokerCards.slice(i, i + length);
                        let isConsecutive = true;

                        for (let j = 1; j < straight.length; j++) {
                            if (this.getRankValue(straight[j].rank) !== this.getRankValue(straight[j-1].rank) + 1) {
                                isConsecutive = false;
                                break;
                            }
                        }

                        if (isConsecutive && !straight.some(card => usedCards.has(card))) {
                            groups.straight.push(straight);
                            straight.forEach(card => usedCards.add(card));
                            break;
                        }
                    }
                }

                // 7. è¯†åˆ«å‰©ä½™çš„ç‰Œå‹
                for (let rank in rankGroups) {
                    const cards = rankGroups[rank];
                    const availableCards = cards.filter(card => !usedCards.has(card));

                    // ä¸‰å¸¦äºŒ
                    if (availableCards.length >= 3) {
                        const triple = availableCards.slice(0, 3);

                        // æŸ¥æ‰¾å…¶ä»–ç‰Œä½œä¸ºå¸¦ç‰Œ
                        const otherCards = availableCards.slice(3);
                        if (otherCards.length >= 2) {
                            const threeWithPair = [...triple, ...otherCards.slice(0, 2)];
                            groups.three_with_pair.push(threeWithPair);
                            triple.forEach(card => usedCards.add(card));
                            otherCards.slice(0, 2).forEach(card => usedCards.add(card));
                            continue;
                        }
                    }

                    // ä¸‰å¼ 
                    if (availableCards.length >= 3) {
                        groups.triple.push(availableCards.slice(0, 3));
                        availableCards.slice(0, 3).forEach(card => usedCards.add(card));
                    } else if (availableCards.length >= 2) {
                        groups.pair.push(availableCards.slice(0, 2));
                        availableCards.slice(0, 2).forEach(card => usedCards.add(card));
                    } else if (availableCards.length >= 1) {
                        groups.single.push(availableCards[0]);
                        usedCards.add(availableCards[0]);
                    }
                }

                // æŒ‰ä¼˜å…ˆçº§æ’åºå¹¶ä»å¤§åˆ°å°æ’åˆ—
                const sortedCards = [];
                const sortedTypes = Object.keys(groups).sort((a, b) => patternPriority[b] - patternPriority[a]);

                // åˆ›å»ºä¸€ä¸ªæ–°çš„Setæ¥æ£€æµ‹é‡å¤
                const cardSet = new Set();

                sortedTypes.forEach(type => {
                    // åŒç‰Œå‹å†…æŒ‰ç‚¹æ•°ä»å¤§åˆ°å°æ’åº
                    groups[type].sort((a, b) => {
                        const aValue = Array.isArray(a) ? this.getRankValue(a[0].rank) : this.getRankValue(a.rank);
                        const bValue = Array.isArray(b) ? this.getRankValue(b[0].rank) : this.getRankValue(b.rank);
                        return bValue - aValue;
                    });

                    // å±•å¼€æ‰€æœ‰ç‰Œ
                    groups[type].forEach(cards => {
                        if (Array.isArray(cards)) {
                            cards.forEach(card => {
                                const cardId = card.id || (card.rank + card.suit);
                                if (!cardSet.has(cardId)) {
                                    sortedCards.push(card);
                                    cardSet.add(cardId);
                                } else {
                                    console.warn(`[sortCardsByPattern] å‘ç°é‡å¤ç‰Œ: ${card.rank}${card.suit}`);
                                }
                            });
                        } else {
                            const cardId = cards.id || (cards.rank + cards.suit);
                            if (!cardSet.has(cardId)) {
                                sortedCards.push(cards);
                                cardSet.add(cardId);
                            } else {
                                console.warn(`[sortCardsByPattern] å‘ç°é‡å¤ç‰Œ: ${cards.rank}${cards.suit}`);
                            }
                        }
                    });
                });

                console.log(`[sortCardsByPattern] è¾“å…¥${cards.length}å¼ ç‰Œï¼Œè¾“å‡º${sortedCards.length}å¼ ç‰Œ`);
                return sortedCards;
            }

            updatePlayArea() {
                // æ¸…ç©ºä¸­å¤®åŒºåŸŸ
                ['northPlays', 'southPlays', 'westPlays', 'eastPlays'].forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.innerHTML = '';
                        element.classList.remove('latest-group');
                    }
                });

                // æ›´æ–°ä¸­å¤®çŠ¶æ€
                const centerArea = document.getElementById('playAreaCenter');
                if (this.currentRoundCards.length === 0) {
                    centerArea.innerHTML = '<div id="playAreaStatus">ç­‰å¾…å‡ºç‰Œ...</div>';
                    centerArea.style.display = 'block';
                    return;
                }

                // éšè—ä¸­å¤®çŠ¶æ€
                centerArea.style.display = 'none';

                // æŒ‰å‡ºç‰Œä½ç½®åˆ†é…åˆ°ä¸­å¤®åŒºåŸŸçš„å„ä½ç½®
                // ç¡®ä¿åå‡ºç‰Œçš„ç©å®¶è¦†ç›–å…ˆå‡ºç‰Œçš„ç©å®¶
                this.currentRoundCards.forEach((play, index) => {
                    if (play.cards.length === 0 || play.action === 'pass') {
                        return;
                    }

                    const positionElement = document.getElementById(play.player + 'Plays');
                    if (!positionElement) return;

                    // æœ€æ–°å‡ºç‰Œçªå‡ºæ˜¾ç¤º
                    if (index === this.currentRoundCards.length - 1) {
                        positionElement.classList.add('latest-group');
                    }

                    // ä½¿ç”¨æ—¶é—´æˆ³ç¡®ä¿åå‡ºç‰Œçš„z-indexæ›´é«˜
                    const playTime = play.timestamp || Date.now();
                    const baseZIndex = 1000 + playTime;

                    // åˆ›å»ºç‰Œå…ƒç´ 
                    play.cards.forEach((card, cardIndex) => {
                        const cardElement = document.createElement('div');
                        const display = this.getCardDisplay(card);
                        cardElement.className = `player-card ${display.color}`;

                        // ç”Ÿæˆç‰Œçš„HTMLå†…å®¹
                        let cardHTML = '<div class="card-content">';

                        if (display.isJoker) {
                            // å¤§å°ç‹çš„ç‰¹æ®Šæ˜¾ç¤º
                            cardHTML += `
                                <div class="card-top-left">
                                    <div class="card-rank joker-text">JOKER</div>
                                </div>
                                <div class="card-bottom-right">
                                    <div class="card-rank joker-text">JOKER</div>
                                </div>
                            `;
                        } else {
                            // æ™®é€šç‰Œçš„æ˜¾ç¤º
                            cardHTML += `
                                <div class="card-top-left">
                                    <div class="card-rank">${display.rank}</div>
                                    <div class="card-suit">${display.suit}</div>
                                </div>
                                <div class="card-bottom-right">
                                    <div class="card-rank">${display.rank}</div>
                                    <div class="card-suit">${display.suit}</div>
                                </div>
                            `;
                        }

                        cardHTML += '</div>';
                        cardElement.innerHTML = cardHTML;

                        // è®¾ç½®åŸºäºæ—¶é—´å’Œç‰Œåºçš„z-indexï¼Œç¡®ä¿åå‡ºç‰Œè¦†ç›–å…ˆå‡ºç‰Œ
                        cardElement.style.zIndex = baseZIndex + cardIndex;
                        positionElement.appendChild(cardElement);
                    });
                });
            }

            updateInfoBars() {
                // æ›´æ–°æ¸¸æˆçŠ¶æ€
                const statusElement = document.getElementById('gameStatus');
                if (statusElement) {
                    statusElement.textContent = this.gameState === 'playing' ? 'è¿›è¡Œä¸­' : 'ç­‰å¾…';
                }
            }

            updateControlButtons() {
                const isPlayerTurn = this.currentPlayer === 'south' && this.gameState === 'playing';

                // ä¸»è¦æ¸¸æˆæŒ‰é’®
                const playBtn = document.getElementById('playBtn');
                const passBtn = document.getElementById('passBtn');
                const hintBtn = document.getElementById('hintBtn');
                const reportBtn = document.getElementById('reportBtn');

                // è°ƒè¯•è¾“å‡º
                console.log(`[updateControlButtons] å‡ºç‰ŒæŒ‰é’®çŠ¶æ€æ£€æŸ¥:`);
                console.log(`  - currentPlayer: ${this.currentPlayer} (éœ€è¦: south)`);
                console.log(`  - gameState: ${this.gameState} (éœ€è¦: playing)`);
                console.log(`  - isPlayerTurn: ${isPlayerTurn}`);
                console.log(`  - selectedCards.length: ${this.selectedCards.length}`);

                playBtn.disabled = !isPlayerTurn || this.selectedCards.length === 0;
                console.log(`  - playBtn.disabled: ${playBtn.disabled} (ç¦ç”¨åŸå› : ${!isPlayerTurn ? 'ä¸æ˜¯ç©å®¶å›åˆ' : 'æ²¡æœ‰é€‰ç‰Œ'})`);

                passBtn.disabled = !isPlayerTurn;
                hintBtn.disabled = !isPlayerTurn;
                reportBtn.disabled = !isPlayerTurn;

                // æ›´æ–°å‡ºç‰ŒæŒ‰é’®æç¤º
                this.updatePlayButtonHint();

                // æ›´æ–°æŒ‰é’®è§†è§‰çŠ¶æ€
                if (window.uiEnhancements) {
                    [playBtn, passBtn, hintBtn, reportBtn].forEach(btn => {
                        window.uiEnhancements.updateButtonState(btn);
                    });
                }

                // é«˜äº®å½“å‰ç©å®¶
                if (window.uiEnhancements && window.uiEnhancements.highlightCurrentPlayer) {
                    window.uiEnhancements.highlightCurrentPlayer(this.currentPlayer);
                }
            }

            /**
             * æ›´æ–°å‡ºç‰ŒæŒ‰é’®æç¤º
             */
            updatePlayButtonHint() {
                const playBtn = document.getElementById('playBtn');
                if (!playBtn) return;

                if (this.selectedCards.length === 0) {
                    playBtn.innerHTML = 'ğŸš€ å‡ºç‰Œ';
                    playBtn.title = 'è¯·å…ˆé€‰æ‹©è¦å‡ºçš„ç‰Œ';
                    return;
                }

                // è·å–é€‰ä¸­ç‰Œçš„ç±»å‹
                const cardType = this.getCardType(this.selectedCards);
                console.log('[updatePlayButtonHint] é€‰ä¸­ç‰Œ:', this.selectedCards.map(c => c.rank + c.suit).join(','));
                console.log('[updatePlayButtonHint] cardType:', cardType);

                // å¤„ç†cardTypeå’ŒtypeName
                let typeName = 'æœªçŸ¥ç‰Œå‹';
                if (cardType) {
                    typeName = this.getCardTypeName(cardType);
                    console.log('[updatePlayButtonHint] ç‰Œå‹åç§°:', typeName);
                } else if (this.selectedCards.length === 1) {
                    typeName = 'å•å¼ ';
                }

                // æ£€æŸ¥å‡ºç‰Œæ˜¯å¦åˆæ³•
                let canPlay = false;
                if (this.currentPlayer === 'south' && this.gameState === 'playing') {
                    const lastPlay = this.getLastPlay();
                    canPlay = this.canBeatLastPlay(this.selectedCards, lastPlay);
                }

                // æ›´æ–°æŒ‰é’®æ–‡æœ¬å’Œæç¤º
                if (canPlay) {
                    playBtn.innerHTML = `ğŸš€ å‡ºç‰Œ (${typeName})`;
                    playBtn.title = `å‡º${this.selectedCards.length}å¼ ${typeName}`;
                } else {
                    playBtn.innerHTML = `ğŸš€ å‡ºç‰Œ (${typeName})`;
                    playBtn.title = `å‡º${this.selectedCards.length}å¼ ${typeName}ï¼ˆä¸åˆæ³•ï¼‰`;
                }
            }

            /**
             * è·å–ä¸Šä¸€æ‰‹ç‰Œ
             */
            getLastPlay() {
                if (this.currentRoundCards.length === 0) return null;

                // æ‰¾åˆ°æœ€åä¸€æ¬¡æœ‰æ•ˆå‡ºç‰Œï¼ˆépassï¼‰
                for (let i = this.currentRoundCards.length - 1; i >= 0; i--) {
                    const play = this.currentRoundCards[i];
                    if (play.cards && play.cards.length > 0) {
                        return {
                            cards: play.cards,
                            type: play.cardType || this.getCardType(play.cards)
                        };
                    }
                }
                return null;
            }

            /**
             * æ£€æŸ¥æ˜¯å¦èƒ½æ‰“è¿‡ä¸Šä¸€æ‰‹ç‰Œ
             */
            canBeatLastPlay(cards, lastPlay) {
                if (!lastPlay || !lastPlay.cards) {
                    // é¦–å‡ºï¼Œä»»ä½•æœ‰æ•ˆç‰Œå‹éƒ½å¯ä»¥
                    return this.getCardType(cards) !== 'invalid';
                }

                // ä½¿ç”¨è§„åˆ™å¼•æ“éªŒè¯
                const validation = this.rules.validatePlay(cards, lastPlay);
                return validation.isValid;
            }

            /**
             * è·å–ç‰Œå‹åç§°
             */
            getCardTypeName(cardType) {
                // å¦‚æœä¼ å…¥çš„æ˜¯å¯¹è±¡ï¼Œå–typeå±æ€§
                if (typeof cardType === 'object' && cardType && cardType.type) {
                    cardType = cardType.type;
                }

                const typeNames = {
                    'single': 'å•å¼ ',
                    'pair': 'å¯¹å­',
                    'triple': 'ä¸‰å¼ ',
                    'triple_single': 'ä¸‰å¸¦ä¸€',
                    'triple_pair': 'ä¸‰å¸¦äºŒ',
                    'straight': 'é¡ºå­',
                    'pair_straight': 'è¿å¯¹',
                    'plane': 'é£æœº',
                    'bomb': 'ç‚¸å¼¹',
                    'king_bomb': 'å¤©ç‹ç‚¸',
                    'rocket': 'å¤©ç‹ç‚¸',  // å…¼å®¹rocketç±»å‹
                    'straight_flush': 'åŒèŠ±é¡º',
                    'invalid': 'æ— æ•ˆ'
                };
                return typeNames[cardType] || 'æœªçŸ¥ç‰Œå‹';
            }

            selectCard(card, element) {
                if (this.currentPlayer !== 'south') return;

                // é¦–æ¬¡ç‚¹å‡»æ—¶åˆå§‹åŒ–éŸ³é¢‘
                this.initAudio();

                // æ£€æŸ¥å…ƒç´ æ˜¯å¦æœ‰selectedç±»
                const wasSelected = element.classList.contains('selected');
                console.log(`[é€‰æ‹©ç‰Œ] ç‚¹å‡» ${card.rank}${card.suit}, DOMé€‰ä¸­çŠ¶æ€: ${wasSelected}`);

                // åŒæ­¥çŠ¶æ€ï¼šç¡®ä¿DOMå’Œæ•°ç»„ä¸€è‡´
                if (wasSelected && this.selectedCards.length === 0) {
                    // DOMæ˜¾ç¤ºé€‰ä¸­ä½†æ•°ç»„ä¸ºç©ºï¼Œè¯´æ˜æ˜¯çŠ¶æ€ä¸ä¸€è‡´
                    console.warn('[é€‰æ‹©ç‰Œ] çŠ¶æ€ä¸ä¸€è‡´ï¼æ¸…é™¤DOMé€‰ä¸­çŠ¶æ€');
                    element.classList.remove('selected');
                    return;
                }

                // ä»selectedCardsä¸­æŸ¥æ‰¾è¿™å¼ ç‰Œ
                console.log(`[é€‰æ‹©ç‰Œ] æŸ¥æ‰¾ç‰Œ ${card.rank}${card.suit}, ID: ${card.id || 'æ— '}`);
                console.log(`[é€‰æ‹©ç‰Œ] å½“å‰selectedCardsæ•°ç»„:`, this.selectedCards.map(c => `${c.rank}${c.suit}(${c.id || 'æ— '})`));

                const index = this.selectedCards.findIndex(c =>
                    (c.id && c.id === card.id) ||
                    (!c.id && c.rank === card.rank && c.suit === card.suit)
                );

                console.log(`[é€‰æ‹©ç‰Œ] åœ¨æ•°ç»„ä¸­æŸ¥æ‰¾ç»“æœ: index=${index}`);
                console.log(`[é€‰æ‹©ç‰Œ] wasSelected=${wasSelected}, åœ¨æ•°ç»„ä¸­=${index !== -1}`);

                if (wasSelected) {
                    // åº”è¯¥å–æ¶ˆé€‰ä¸­
                    if (index !== -1) {
                        // ä»æ•°ç»„ä¸­ç§»é™¤
                        this.selectedCards.splice(index, 1);
                        element.classList.remove('selected');
                        console.log(`[é€‰æ‹©ç‰Œ] å–æ¶ˆé€‰ä¸­: ${card.rank}${card.suit}, å‰©ä½™: ${this.selectedCards.length}å¼ `);
                    } else {
                        // æ•°ç»„ä¸­æ‰¾ä¸åˆ°ï¼Œå¼ºåˆ¶æ¸…é™¤DOMçŠ¶æ€
                        console.warn('[é€‰æ‹©ç‰Œ] æ•°ç»„ä¸­æ‰¾ä¸åˆ°ï¼Œæ¸…é™¤DOMçŠ¶æ€');
                        element.classList.remove('selected');
                    }
                } else {
                    // åº”è¯¥é€‰ä¸­
                    if (index === -1) {
                        // æ•°ç»„ä¸­ç¡®å®æ²¡æœ‰ï¼Œæ·»åŠ åˆ°æ•°ç»„
                        this.selectedCards.push(card);
                        element.classList.add('selected');
                        console.log(`[é€‰æ‹©ç‰Œ] é€‰ä¸­: ${card.rank}${card.suit}, æ€»è®¡: ${this.selectedCards.length}å¼ `);
                    } else {
                        // æ•°ç»„ä¸­å·²å­˜åœ¨ï¼Œä¸åº”è¯¥å‘ç”Ÿ
                        console.error('[é€‰æ‹©ç‰Œ] é€»è¾‘é”™è¯¯ï¼šæ•°ç»„ä¸­å·²å­˜åœ¨ä½†DOMæœªé€‰ä¸­');
                    }
                }

                // ä½¿ç”¨requestAnimationFrameç¡®ä¿æ ·å¼æ­£ç¡®åº”ç”¨
                requestAnimationFrame(() => {
                    this.updateControlButtons();
                });
            }

            /**
             * æ¸…ç©ºæ‰€æœ‰é€‰ä¸­çš„ç‰Œ
             */
            clearSelection() {
                console.log('[æ¸…ç©ºé€‰æ‹©] å¼€å§‹æ¸…ç©ºé€‰æ‹©');
                console.log(`[æ¸…ç©ºé€‰æ‹©] æ¸…ç©ºå‰ - æ•°ç»„ä¸­æœ‰${this.selectedCards.length}å¼ ç‰Œ`);

                // ç§»é™¤æ‰€æœ‰é€‰ä¸­ç‰Œçš„æ ·å¼
                const selectedElements = document.querySelectorAll('.player-card.selected');
                console.log(`[æ¸…ç©ºé€‰æ‹©] æ‰¾åˆ°${selectedElements.length}ä¸ªé€‰ä¸­å…ƒç´ `);

                selectedElements.forEach(el => {
                    el.classList.remove('selected');
                });

                // æ¸…ç©ºé€‰ä¸­ç‰Œæ•°ç»„
                this.selectedCards = [];

                // å†æ¬¡æ£€æŸ¥æ˜¯å¦è¿˜æœ‰æ®‹ç•™
                const remainingSelected = document.querySelectorAll('.player-card.selected');
                if (remainingSelected.length > 0) {
                    console.warn(`[æ¸…ç©ºé€‰æ‹©] è­¦å‘Šï¼šä»æœ‰${remainingSelected.length}ä¸ªé€‰ä¸­å…ƒç´ æ®‹ç•™`);
                    remainingSelected.forEach(el => el.classList.remove('selected'));
                }

                console.log('[æ¸…ç©ºé€‰æ‹©] æ¸…ç©ºå®Œæˆ');
                this.updateControlButtons();
            }

            // ========== åˆ’é€‰æ‰‹ç‰ŒåŠŸèƒ½ ==========

            /**
             * å¼€å§‹åˆ’é€‰
             */
            handleBrushStart(e, cardElement, card) {
                if (this.currentPlayer !== 'south') return;

                // è®°å½•åˆå§‹ä½ç½®ï¼Œä½†ä¸ç«‹å³preventDefault
                const touch = e.touches ? e.touches[0] : e;

                // åˆå§‹åŒ–åˆ’é€‰çŠ¶æ€
                this.brushSelectState.isSelecting = true;
                this.brushSelectState.startTime = Date.now();
                this.brushSelectState.startX = touch.clientX;
                this.brushSelectState.startY = touch.clientY;
                this.brushSelectState.selectedIds.clear();
                this.brushSelectState.processedIds.clear(); // æ¸…ç©ºå·²å¤„ç†IDé›†åˆ
                this.brushSelectState.hasMoved = false; // æ ‡è®°æ˜¯å¦å·²ç§»åŠ¨
                this.brushSelectState.isFromMouseDown = true; // æ ‡è®°æ¥è‡ªmousedown

                console.log('[åˆ’é€‰å¼€å§‹] mousedownè§¦å‘');

                // å»¶è¿Ÿè§¦å‘èµ·å§‹ç‰Œçš„å¤„ç†ï¼Œç»™clickäº‹ä»¶ç•™å‡ºæ—¶é—´
                setTimeout(() => {
                    if (this.brushSelectState.isSelecting) {
                        this.handleBrushEnter(e, cardElement, card);
                    }
                }, 100);

                // ä¿å­˜æ­£ç¡®çš„thiså¼•ç”¨
                const self = this;

                // æ·»åŠ å…¨å±€ç›‘å¬å™¨
                self.brushMouseMoveHandler = self.handleBrushMove.bind(self);
                self.brushMouseUpHandler = self.handleBrushEnd.bind(self);

                document.addEventListener('mousemove', self.brushMouseMoveHandler);
                document.addEventListener('mouseup', self.brushMouseUpHandler);
                document.addEventListener('touchmove', self.brushMouseMoveHandler);
                document.addEventListener('touchend', self.brushMouseUpHandler);
            }

            /**
             * åˆ’é€‰è¿›å…¥æŸå¼ ç‰Œ
             */
            handleBrushEnter(e, cardElement, card) {
                // å…è®¸åœ¨æ²¡æœ‰åˆ’é€‰çŠ¶æ€æ—¶å¤„ç†èµ·å§‹ç‰Œ
                if (!this.brushSelectState.isSelecting && e.type !== 'mousedown') return;

                const cardId = cardElement.dataset.cardId;

                // é¿å…é‡å¤å¤„ç†åŒä¸€å¼ ç‰Œ
                if (this.brushSelectState.processedIds.has(cardId)) return;

                // æ ‡è®°ä¸ºå·²å¤„ç†
                this.brushSelectState.processedIds.add(cardId);
                this.brushSelectState.selectedIds.add(cardId);

                // æ·»åŠ ä¸´æ—¶åˆ’é€‰æ ·å¼
                cardElement.classList.add('brushing');

                // åˆ‡æ¢é€‰ä¸­çŠ¶æ€ï¼šå·²é€‰ä¸­çš„å–æ¶ˆï¼Œæœªé€‰ä¸­çš„é€‰ä¸­
                if (this.isCardSelected(card)) {
                    // å¦‚æœå·²é€‰ä¸­ï¼Œåˆ™å–æ¶ˆé€‰ä¸­
                    this.selectCard(card, cardElement); // å†æ¬¡è°ƒç”¨ä¼šå–æ¶ˆé€‰ä¸­
                    cardElement.classList.add('unselecting'); // æ·»åŠ å–æ¶ˆé€‰ä¸­çš„æ ·å¼
                } else {
                    // å¦‚æœæœªé€‰ä¸­ï¼Œåˆ™é€‰ä¸­å®ƒ
                    this.selectCard(card, cardElement);
                }

                // çŸ­æš‚å»¶è¿Ÿåç§»é™¤ä¸´æ—¶æ ·å¼
                setTimeout(() => {
                    cardElement.classList.remove('brushing');
                    cardElement.classList.remove('unselecting');
                }, 100);
            }

            /**
             * åˆ’é€‰è¿‡ç¨‹ä¸­çš„é¼ æ ‡ç§»åŠ¨
             */
            handleBrushMove(e) {
                if (!this.brushSelectState.isSelecting) return;

                const touch = e.touches ? e.touches[0] : e;

                // æ£€æŸ¥æ˜¯å¦ç§»åŠ¨äº†è¶³å¤Ÿçš„è·ç¦»
                const deltaX = Math.abs(touch.clientX - this.brushSelectState.startX);
                const deltaY = Math.abs(touch.clientY - this.brushSelectState.startY);
                const hasMoved = deltaX > 5 || deltaY > 5;

                if (hasMoved && !this.brushSelectState.hasMoved) {
                    // ç¬¬ä¸€æ¬¡ç§»åŠ¨æ—¶é˜»æ­¢é»˜è®¤è¡Œä¸º
                    e.preventDefault();
                    this.brushSelectState.hasMoved = true;
                }

                if (this.brushSelectState.hasMoved) {
                    const element = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (element && element.classList.contains('player-card')) {
                        // é€šè¿‡è§¦å‘ mouseenter äº‹ä»¶æ¥å¤„ç†
                        element.dispatchEvent(new MouseEvent('mouseenter', {
                            bubbles: true,
                            cancelable: true,
                            view: window
                        }));
                    }
                }
            }

            /**
             * ç»“æŸåˆ’é€‰
             */
            handleBrushEnd(e) {
                if (!this.brushSelectState.isSelecting) return;

                // å¦‚æœæ²¡æœ‰ç§»åŠ¨ï¼Œè¯´æ˜æ˜¯å•å‡»ï¼Œä¸æ‰§è¡Œåˆ’é€‰é€»è¾‘
                if (!this.brushSelectState.hasMoved) {
                    // æ¸…ç†çŠ¶æ€
                    console.log('[åˆ’é€‰ç»“æŸ] æ²¡æœ‰ç§»åŠ¨ï¼Œæ¸…ç†åˆ’é€‰çŠ¶æ€');
                    this.brushSelectState.isSelecting = false;
                    this.brushSelectState.isFromMouseDown = false;
                    return;
                }

                // åˆ’é€‰ç»“æŸ
                console.log(`[åˆ’é€‰ç»“æŸ] å…±å¤„ç†äº† ${this.brushSelectState.processedIds.size} å¼ ç‰Œ`);

                // æ¸…ç†çŠ¶æ€
                this.brushSelectState.isSelecting = false;
                this.brushSelectState.isFromMouseDown = false;
                this.brushSelectState.selectedIds.clear();
                this.brushSelectState.processedIds.clear();
                console.log('[åˆ’é€‰ç»“æŸ] å·²æ¸…ç†åˆ’é€‰çŠ¶æ€');

                // ç§»é™¤å…¨å±€ç›‘å¬å™¨
                if (this.brushMouseMoveHandler) {
                    document.removeEventListener('mousemove', this.brushMouseMoveHandler);
                    document.removeEventListener('mouseup', this.brushMouseUpHandler);
                    document.removeEventListener('touchmove', this.brushMouseMoveHandler);
                    document.removeEventListener('touchend', this.brushMouseUpHandler);

                    // æ¸…ç†å¼•ç”¨
                    this.brushMouseMoveHandler = null;
                    this.brushMouseUpHandler = null;
                }
            }

            /**
             * æ£€æŸ¥æŸå¼ ç‰Œæ˜¯å¦å·²è¢«é€‰ä¸­
             */
            isCardSelected(card) {
                const cardId = card.id || `${card.rank}${card.suit}`;
                return this.selectedCards.some(c =>
                    (c.id && c.id === card.id) ||
                    (!c.id && c.rank === card.rank && c.suit === card.suit)
                );
            }

            playCards() {
                if (this.selectedCards.length === 0) return;

                // è·å–ä¸Šä¸€æ‰‹ç‰Œ
                let lastPlay = null;
                if (this.currentRoundCards.length > 0) {
                    // æ‰¾åˆ°æœ€åä¸€æ¬¡æœ‰æ•ˆå‡ºç‰Œï¼ˆépassï¼‰
                    for (let i = this.currentRoundCards.length - 1; i >= 0; i--) {
                        const play = this.currentRoundCards[i];
                        if (play.cards && play.cards.length > 0) {
                            lastPlay = {
                                cards: play.cards,
                                type: play.cardType || this.getCardType(play.cards)
                            };
                            break;
                        }
                    }
                }

                // ä½¿ç”¨è§„åˆ™å¼•æ“éªŒè¯å‡ºç‰Œ
                const validation = this.rules.validatePlay(
                    this.selectedCards,
                    lastPlay,
                    this.players.south.cards
                );

                if (!validation.valid) {
                    this.showMessage(validation.message, 'error');
                    return;
                }

                // ç§»é™¤æ‰‹ç‰Œ - ä½¿ç”¨å”¯ä¸€IDæ¥ç¡®ä¿ç§»é™¤æ­£ç¡®çš„ç‰Œ
                this.selectedCards.forEach(card => {
                    // ä¼˜å…ˆä½¿ç”¨å”¯ä¸€IDæŸ¥æ‰¾
                    let index = -1;
                    if (card.id) {
                        index = this.players.south.cards.findIndex(c => c.id === card.id);
                    }

                    // å¦‚æœæ²¡æœ‰IDï¼ˆå…¼å®¹æ—§æ•°æ®ï¼‰ï¼Œä½¿ç”¨suitå’Œrank
                    if (index === -1) {
                        index = this.players.south.cards.findIndex(c =>
                            c.suit === card.suit && c.rank === card.rank
                        );
                    }

                    if (index !== -1) {
                        console.log(`[å‡ºç‰Œ] ç§»é™¤ç‰Œ: ${card.rank}${card.suit} (ID: ${card.id || 'æœªçŸ¥'})`);
                        this.players.south.cards.splice(index, 1);
                    } else {
                        console.error(`[å‡ºç‰Œé”™è¯¯] æ‰¾ä¸åˆ°è¦ç§»é™¤çš„ç‰Œ: ${card.rank}${card.suit}`);
                    }
                });

                // æ›´æ–°è®°ç‰Œç³»ç»Ÿ
                this.updateCardMemory('south', [...this.selectedCards]);

                // æ·»åŠ åˆ°å½“å‰è½®æ¬¡
                this.currentRoundCards.push({
                    player: 'south',
                    cards: [...this.selectedCards],
                    cardType: validation.type,
                    timestamp: Date.now()
                });

                // è®°å½•æœ¬è½®å‡ºç‰Œçš„ç©å®¶
                this.roundPlayers.add('south');

                // æ’­æ”¾éŸ³æ•ˆ
                const cardType = validation.type;
                if (cardType && cardType.type === 'bomb') {
                    this.playSound('bomb');
                } else {
                    this.playSound('play');
                }

                this.selectedCards = [];

                // é‡ç½®æç¤ºçŠ¶æ€
                this.isHintMode = false;
                this.currentHintIndex = 0;
                this.availableHints = [];

                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                if (this.checkGameEnd()) {
                    return;
                }

                // åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªç©å®¶
                this.switchToNextPlayer();
            }

            passTurn() {
                this.selectedCards = [];

                // é‡ç½®æç¤ºçŠ¶æ€
                this.isHintMode = false;
                this.currentHintIndex = 0;
                this.availableHints = [];

                // è®°å½•passæ“ä½œ
                this.currentRoundCards.push({
                    player: this.currentPlayer,
                    cards: [],
                    timestamp: Date.now(),
                    action: 'pass'
                });

                // æ·»åŠ åˆ°å·²è¿‡ç‰Œç©å®¶é›†åˆ
                this.roundPassedPlayers.add(this.currentPlayer);
                console.log(`[è½®æ¬¡] ${this.currentPlayer} è¿‡ç‰Œï¼Œæœ¬å›åˆæ°¸ä¹…å¤±å»å‡ºç‰Œæƒ`);

                // æ’­æ”¾è¿‡ç‰ŒéŸ³æ•ˆ
                this.playSound('pass');

                this.switchToNextPlayer();
            }

            switchToNextPlayer() {
                // é€†æ—¶é’ˆé¡ºåºï¼šå— â†’ è¥¿ â†’ åŒ— â†’ ä¸œ
                const order = ['south', 'west', 'north', 'east'];
                const currentIndex = order.indexOf(this.currentPlayer);

                // æ£€æŸ¥å½“å‰ç©å®¶æ˜¯å¦æ‰‹ç‰Œä¸º0ï¼Œå¦‚æœæ˜¯åˆ™è‡ªåŠ¨è¿‡ç‰Œ
                if (this.players[this.currentPlayer].cards.length === 0) {
                    console.log(`[switchToNextPlayer] ${this.currentPlayer} æ‰‹ç‰Œä¸º0ï¼Œè‡ªåŠ¨è¿‡ç‰Œ`);
                    this.roundPassedPlayers.add(this.currentPlayer);
                }

                // å¦‚æœæ‰€æœ‰å…¶ä»–ç©å®¶éƒ½è¿‡ç‰Œäº†ï¼Œæ¸…ç†æ¡Œé¢
                const activePlayers = order.filter(p => this.players[p].cards.length > 0);
                const passedActivePlayers = activePlayers.filter(p => this.roundPassedPlayers.has(p));

                if (passedActivePlayers.length >= activePlayers.length - 1 && activePlayers.length > 0) {
                    console.log('[è½®æ¬¡ç»“æŸ] æ‰€æœ‰å…¶ä»–æ´»è·ƒç©å®¶éƒ½è¿‡ç‰Œï¼Œè½®æ¬¡ç»“æŸ');
                    this.processRoundEnd();
                    return;
                }

                // æ‰¾åˆ°ä¸‹ä¸€ä¸ªå¯ä»¥å‡ºç‰Œçš„ç©å®¶
                let nextPlayer = null;
                for (let i = 1; i <= 4; i++) {
                    const candidate = order[(currentIndex + i) % 4];
                    // å¦‚æœè¯¥ç©å®¶æ²¡æœ‰è¿‡ç‰Œä¸”è¿˜æœ‰æ‰‹ç‰Œï¼Œåˆ™å¯ä»¥ä½œä¸ºä¸‹ä¸€ä¸ªç©å®¶
                    if (!this.roundPassedPlayers.has(candidate) && this.players[candidate].cards.length > 0) {
                        nextPlayer = candidate;
                        break;
                    }
                }

                // é˜²æ­¢æ­»å¾ªç¯
                if (!nextPlayer) {
                    console.error('[switchToNextPlayer] é”™è¯¯ï¼šæ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªç©å®¶ï¼Œå¼ºåˆ¶æ¸…ç†æ¡Œé¢');
                    this.processRoundEnd();
                    return;
                }

                // æ­£å¸¸è½®è½¬åˆ°ä¸‹ä¸€ä¸ªç©å®¶
                this.currentPlayer = nextPlayer;
                console.log(`\n[è½®è½¬] ${order[currentIndex]} â†’ ${nextPlayer}`);

                // å¦‚æœåˆ‡æ¢åˆ°éå—å®¶ç©å®¶ï¼Œé‡ç½®æç¤ºçŠ¶æ€
                if (nextPlayer !== 'south') {
                    this.isHintMode = false;
                    this.currentHintIndex = 0;
                    this.availableHints = [];
                }

                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                if (this.checkGameEnd()) {
                    return;
                }

                // å¦‚æœæ˜¯å—å®¶ç©å®¶ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦è‡ªåŠ¨è¿‡ç‰Œ
                if (this.currentPlayer === 'south' && !this.players[this.currentPlayer].isAI) {
                    // è·å–å½“å‰æ¡Œé¢ä¸Šæœ€å¤§çš„ç‰Œ
                    let currentMaxPlay = null;
                    if (this.currentRoundCards.length > 0) {
                        let maxPlay = null;
                        let maxWeight = -1;

                        for (let play of this.currentRoundCards) {
                            if (play.cards && play.cards.length > 0) {
                                const playType = play.cardType || this.getCardType(play.cards);
                                if (playType && playType.weight > maxWeight) {
                                    maxWeight = playType.weight;
                                    maxPlay = {
                                        cards: play.cards,
                                        type: playType,
                                        player: play.player
                                    };
                                }
                            }
                        }
                        currentMaxPlay = maxPlay;
                    }

                    // å¦‚æœæœ‰æ¡Œé¢ä¸Šçš„ç‰Œï¼Œæ£€æŸ¥å—å®¶æ˜¯å¦èƒ½ç®¡ä½
                    if (currentMaxPlay) {
                        const possiblePlays = this.findAllPossiblePlays(this.players.south.cards, currentMaxPlay);
                        console.log(`[è‡ªåŠ¨è¿‡ç‰Œæ£€æŸ¥] å—å®¶æ‰‹ç‰Œ: ${this.players.south.cards.length}å¼ `);
                        console.log(`[è‡ªåŠ¨è¿‡ç‰Œæ£€æŸ¥] å½“å‰æœ€å¤§ç‰Œ: ${currentMaxPlay.cards.map(c => c.rank).join(',')}`);
                        console.log(`[è‡ªåŠ¨è¿‡ç‰Œæ£€æŸ¥] æ‰¾åˆ°å¯èƒ½çš„å‡ºç‰Œ: ${possiblePlays.length}ä¸ª`);

                        if (possiblePlays.length === 0) {
                            // å—å®¶æ— æ³•ç®¡ä½ï¼Œè‡ªåŠ¨è¿‡ç‰Œ
                            console.log('[è‡ªåŠ¨è¿‡ç‰Œ] å—å®¶æ— æ³•ç®¡ä½ï¼Œè‡ªåŠ¨è¿‡ç‰Œ');
                            this.showMessage('ä½ æ²¡æœ‰èƒ½ç®¡ä½çš„ç‰Œï¼Œè‡ªåŠ¨è¿‡ç‰Œ', 'info');

                            // å»¶è¿Ÿ1ç§’åè‡ªåŠ¨è¿‡ç‰Œ
                            setTimeout(() => {
                                this.passTurn();
                            }, 1000);
                            return;
                        }
                    }
                }

                this.updateUI();

                // åªæœ‰AIç©å®¶æ‰è‡ªåŠ¨å‡ºç‰Œ
                if (this.players[this.currentPlayer].isAI) {
                    // éšæœºæ€è€ƒæ—¶é—´ï¼Œè®©AIæ›´åƒçœŸäºº
                    const thinkingTime = this.getRandomThinkingTime();
                    this.showAIThinking(this.currentPlayer);
                    setTimeout(() => this.aiAutoPlay(), thinkingTime);
                }
            }

            // æ£€æŸ¥æ˜¯å¦åº”è¯¥æ¸…ç†æ¡Œé¢
            shouldClearTable() {
                // å¿…é¡»æœ‰å‡ºç‰Œè®°å½•
                if (this.currentRoundCards.length === 0) return false;

                // å¿…é¡»æœ‰è‡³å°‘ä¸€æ¬¡æœ‰æ•ˆå‡ºç‰Œ
                const hasValidPlay = this.currentRoundCards.some(play =>
                    play.cards && play.cards.length > 0
                );
                if (!hasValidPlay) return false;

                console.log(`[shouldClearTable] å½“å‰è½®æ¬¡è®°å½•: ${this.currentRoundCards.map(p => `${p.player}: ${p.cards && p.cards.length > 0 ? p.cards.map(c => c.rank).join(',') : 'pass'}`).join(' | ')}`);

                // æ£€æŸ¥æœ€è¿‘çš„ç©å®¶æ˜¯å¦éƒ½passäº†
                // æ‰¾åˆ°æœ€åä¸€æ¬¡æœ‰æ•ˆå‡ºç‰Œ
                let lastValidPlayIndex = -1;
                for (let i = this.currentRoundCards.length - 1; i >= 0; i--) {
                    if (this.currentRoundCards[i].cards && this.currentRoundCards[i].cards.length > 0) {
                        lastValidPlayIndex = i;
                        break;
                    }
                }

                if (lastValidPlayIndex === -1) return false;

                const lastPlayPlayer = this.currentRoundCards[lastValidPlayIndex].player;
                console.log(`[shouldClearTable] æœ€åå‡ºç‰Œç©å®¶: ${lastPlayPlayer}, ç´¢å¼•: ${lastValidPlayIndex}`);

                // æ£€æŸ¥æœ€åå‡ºç‰Œä¹‹åæ˜¯å¦æ‰€æœ‰å…¶ä»–ç©å®¶éƒ½passäº†
                const playersAfter = this.currentRoundCards.slice(lastValidPlayIndex + 1);
                console.log(`[shouldClearTable] ä¹‹åçš„æ“ä½œ: ${playersAfter.map(p => p.player).join(', ')}`);

                const order = ['south', 'west', 'north', 'east'];
                const lastPlayerIndex = order.indexOf(lastPlayPlayer);

                // å…¶ä»–3ä¸ªç©å®¶éƒ½å¿…é¡»pass
                for (let i = 1; i <= 3; i++) {
                    const nextPlayerIndex = (lastPlayerIndex + i) % 4;
                    const nextPlayer = order[nextPlayerIndex];
                    console.log(`[shouldClearTable] æ£€æŸ¥ç©å®¶ ${nextPlayer}...`);

                    // æ£€æŸ¥è¯¥ç©å®¶æ˜¯å¦pass
                    const playerPlay = playersAfter.find(p => p.player === nextPlayer);
                    // ä¿®å¤ï¼šæ£€æŸ¥actionæ˜¯å¦ä¸ºpassï¼Œæˆ–è€…cardsä¸ºç©ºæ•°ç»„
                    if (!playerPlay || (!playerPlay.action && playerPlay.cards && playerPlay.cards.length > 0)) {
                        console.log(`[shouldClearTable] ç©å®¶ ${nextPlayer} æ²¡æœ‰passæˆ–å‡ºäº†ç‰Œï¼Œä¸æ¸…æ¡Œ`);
                        return false; // è¯¥ç©å®¶æ²¡æœ‰passæˆ–å‡ºäº†ç‰Œ
                    } else {
                        console.log(`[shouldClearTable] ç©å®¶ ${nextPlayer} å·²pass`);
                    }
                }

                console.log(`[shouldClearTable] æ‰€æœ‰ç©å®¶éƒ½passï¼Œæ¸…ç†æ¡Œé¢`);
                return true;
            }

            // è·å–æœ€åå‡ºç‰Œçš„ç©å®¶
            getLastPlayPlayer() {
                for (let i = this.currentRoundCards.length - 1; i >= 0; i--) {
                    const play = this.currentRoundCards[i];
                    if (play.cards && play.cards.length > 0) {
                        return play.player;
                    }
                }
                return null;
            }

            aiAutoPlay() {
                if (this.gameState !== 'playing') return;

                // æ¸…é™¤æ€è€ƒçŠ¶æ€
                this.clearAIThinking(this.currentPlayer);

                const aiPlayer = this.players[this.currentPlayer];
                console.log(`\n[AIå†³ç­–] === ${this.currentPlayer} è½®åˆ°æˆ‘ ===`);
                console.log(`æ‰‹ç‰Œ: ${aiPlayer.cards.length}å¼ `);

                // è·å–å½“å‰æ¡Œé¢ä¸Šæœ€å¤§çš„ç‰Œï¼ˆä¸æ˜¯ä¸Šä¸€æ‰‹ç‰Œï¼‰
                let currentMaxPlay = null;
                if (this.currentRoundCards.length > 0) {
                    // éå†æ‰€æœ‰å‡ºç‰Œï¼Œæ‰¾åˆ°æœ€å¤§çš„
                    let maxPlay = null;
                    let maxWeight = -1;

                    for (let play of this.currentRoundCards) {
                        if (play.cards && play.cards.length > 0) {
                            const playType = play.cardType || this.getCardType(play.cards);
                            if (playType && playType.weight > maxWeight) {
                                maxWeight = playType.weight;
                                maxPlay = {
                                    cards: play.cards,
                                    type: playType,
                                    player: play.player
                                };
                            }
                        }
                    }
                    currentMaxPlay = maxPlay;

                    if (currentMaxPlay) {
                        console.log(`[AI] å½“å‰æ¡Œé¢æœ€å¤§ç‰Œ: ${currentMaxPlay.player}çš„${currentMaxPlay.cards.map(c => c.rank + c.suit).join(',')}, æƒé‡: ${currentMaxPlay.type.weight}`);
                    }
                }

                // å¦‚æœæ²¡æœ‰æ¡Œé¢ä¸Šçš„ç‰Œï¼ŒAIå¯ä»¥ä¸»åŠ¨å‡ºç‰Œ
                if (!currentMaxPlay) {
                    // æ™ºèƒ½é€‰æ‹©å‡ºç‰Œç­–ç•¥
                    const playDecision = this.makeAIPlayDecision(aiPlayer.cards);

                    if (playDecision && playDecision.cards.length > 0) {
                        // ç§»é™¤å‡ºçš„ç‰Œ
                        playDecision.cards.forEach(card => {
                            const index = aiPlayer.cards.findIndex(c =>
                                (c.id && c.id === card.id) ||
                                (!c.id && c.suit === card.suit && c.rank === card.rank)
                            );
                            if (index !== -1) {
                                aiPlayer.cards.splice(index, 1);
                            }
                        });

                        // éªŒè¯å‡ºç‰Œåˆæ³•æ€§
                        const validation = this.rules.validatePlay(playDecision.cards, null, aiPlayer.cards);
                        if (validation.valid) {
                            // æ›´æ–°è®°ç‰Œç³»ç»Ÿ
                            this.updateCardMemory(this.currentPlayer, playDecision.cards);

                            // æ·»åŠ åˆ°å½“å‰è½®æ¬¡
                            this.currentRoundCards.push({
                                player: this.currentPlayer,
                                cards: playDecision.cards,
                                cardType: validation.type,
                                timestamp: Date.now()
                            });

                            // è®°å½•æœ¬è½®å‡ºç‰Œçš„ç©å®¶
                            this.roundPlayers.add(this.currentPlayer);

                            // æ’­æ”¾éŸ³æ•ˆ
                            const cardType = validation.type;
                            if (cardType && cardType.type === 'bomb') {
                                this.playSound('bomb');
                            } else {
                                this.playSound('play');
                            }

                            console.log(`[AIç­–ç•¥] ${this.currentPlayer} ä¸»åŠ¨å‡ºç‰Œ: ${playDecision.reason}`);
                        }
                    }
                } else {
                    // éœ€è¦æ ¹æ®ä¸Šä¸€æ‰‹ç‰Œå‡ºç‰Œ - ä½¿ç”¨æ›´æ™ºèƒ½çš„é€»è¾‘
                    let canPlay = false;

                    // é¦–å…ˆå°è¯•æ‰¾åˆ°æ‰€æœ‰å¯èƒ½çš„å‡ºç‰Œ
                    const possiblePlays = this.findAllPossiblePlays(aiPlayer.cards, currentMaxPlay);

                    console.log(`AI ${this.currentPlayer} è°ƒè¯•ä¿¡æ¯:`);
                    console.log(`  - æ‰‹ç‰Œ: ${aiPlayer.cards.map(c => c.rank).join(', ')}`);
                    console.log(`  - å½“å‰æœ€å¤§ç‰Œ: ${currentMaxPlay ? currentMaxPlay.cards.map(c => c.rank).join(', ') : 'æ— '} (æ¥è‡ª${currentMaxPlay ? currentMaxPlay.player : 'æ— '})`);
                    console.log(`  - æ‰¾åˆ°å¯èƒ½çš„å‡ºç‰Œ: ${possiblePlays.length} ä¸ª`);

                    if (possiblePlays.length > 0) {
                        // é€‰æ‹©æœ€å°çš„åˆæ³•å‡ºç‰Œï¼ˆèŠ‚çœå¤§ç‰Œï¼‰
                        const selectedPlay = possiblePlays[0];

                        // ç§»é™¤å‡ºçš„ç‰Œ - ä½¿ç”¨å”¯ä¸€IDæ¥ç¡®ä¿ç§»é™¤æ­£ç¡®çš„ç‰Œ
                        selectedPlay.cards.forEach(card => {
                            // ä¼˜å…ˆä½¿ç”¨å”¯ä¸€IDæŸ¥æ‰¾
                            let index = -1;
                            if (card.id) {
                                index = aiPlayer.cards.findIndex(c => c.id === card.id);
                            }

                            // å¦‚æœæ²¡æœ‰IDï¼ˆå…¼å®¹æ—§æ•°æ®ï¼‰ï¼Œä½¿ç”¨suitå’Œrank
                            if (index === -1) {
                                index = aiPlayer.cards.findIndex(c =>
                                    c.suit === card.suit && c.rank === card.rank
                                );
                            }

                            if (index !== -1) {
                                console.log(`[AIå‡ºç‰Œ] ç§»é™¤ç‰Œ: ${card.rank}${card.suit} (ID: ${card.id || 'æœªçŸ¥'})`);
                                aiPlayer.cards.splice(index, 1);
                            } else {
                                console.error(`[AIå‡ºç‰Œé”™è¯¯] æ‰¾ä¸åˆ°è¦ç§»é™¤çš„ç‰Œ: ${card.rank}${card.suit}`);
                            }
                        });

                        // æ›´æ–°è®°ç‰Œç³»ç»Ÿ
                        this.updateCardMemory(this.currentPlayer, selectedPlay.cards);

                        // æ·»åŠ åˆ°å½“å‰è½®æ¬¡
                        this.currentRoundCards.push({
                            player: this.currentPlayer,
                            cards: selectedPlay.cards,
                            cardType: selectedPlay.type,
                            timestamp: Date.now()
                        });

                        // è®°å½•æœ¬è½®å‡ºç‰Œçš„ç©å®¶
                        this.roundPlayers.add(this.currentPlayer);

                        // æ’­æ”¾éŸ³æ•ˆ
                        if (selectedPlay.type && selectedPlay.type.type === 'bomb') {
                            this.playSound('bomb');
                        } else {
                            this.playSound('play');
                        }

                        canPlay = true;
                        console.log(`AI ${this.currentPlayer} å‡ºç‰Œ: ${selectedPlay.cards.map(c => c.rank + c.suit).join(', ')}`);
                    }

                    if (!canPlay) {
                        // AIé€‰æ‹©ä¸è¦
                        this.currentRoundCards.push({
                            player: this.currentPlayer,
                            cards: [],
                            timestamp: Date.now(),
                            action: 'pass'
                        });

                        // æ·»åŠ åˆ°å·²è¿‡ç‰Œç©å®¶é›†åˆ
                        this.roundPassedPlayers.add(this.currentPlayer);
                        console.log(`[è½®æ¬¡] AI ${this.currentPlayer} è¿‡ç‰Œï¼Œæœ¬å›åˆæ°¸ä¹…å¤±å»å‡ºç‰Œæƒ`);

                        // æ’­æ”¾è¿‡ç‰ŒéŸ³æ•ˆ
                        this.playSound('pass');

                        console.log(`AI ${this.currentPlayer} é€‰æ‹©è¿‡ç‰Œ`);
                    }
                }

                this.switchToNextPlayer();
                this.updateUI();
                console.log(`${this.currentPlayer} è½®è½¬å®Œæˆ`);

                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                if (this.checkGameEnd()) {
                    return;
                }

              }

            // ç»Ÿä¸€å¤„ç†è½®æ¬¡ç»“æŸé€»è¾‘
            processRoundEnd() {
                console.log('[è½®æ¬¡ç»“æŸ] æ¸…ç†æ¡Œé¢');

                // è·å–æœ€åå‡ºç‰Œçš„ç©å®¶ï¼Œä»–å°†è·å¾—ä¸‹ä¸€è½®çš„é¦–å‡ºæƒ
                const lastPlayer = this.getLastPlayPlayer();

                // æ¸…ç†æ¡Œé¢
                this.currentRoundCards = [];
                this.lastPlayer = null;

                // æ¸…ç†è¿‡ç‰Œè®°å½•ï¼Œå¼€å§‹æ–°ä¸€è½®
                this.roundPassedPlayers.clear();
                this.roundPlayers.clear();

                // æ›´æ–°å‡ºç‰ŒåŒºåŸŸæ˜¾ç¤º
                const plays = ['northPlays', 'eastPlays', 'southPlays', 'westPlays'];
                plays.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) element.innerHTML = '';
                });

                // è®¾ç½®ä¸‹ä¸€è½®çš„é¦–å‡ºç©å®¶
                if (lastPlayer) {
                    this.currentPlayer = lastPlayer;
                    console.log(`[æ–°è½®] ${lastPlayer} è·å¾—é¦–å‡ºæƒ`);

                    // å¦‚æœæ˜¯AIç©å®¶ï¼Œç»™æ€è€ƒæ—¶é—´åè‡ªåŠ¨å‡ºç‰Œ
                    if (this.players[this.currentPlayer].isAI) {
                        const thinkingTime = this.getRandomThinkingTime();
                        this.showAIThinking(this.currentPlayer);
                        setTimeout(() => this.aiAutoPlay(), thinkingTime);
                    }
                } else {
                    // å¦‚æœæ‰¾ä¸åˆ°æœ€åå‡ºç‰Œçš„ç©å®¶ï¼Œä¿æŒå½“å‰ç©å®¶
                    console.log(`[æ–°è½®] ä¿æŒå½“å‰ç©å®¶: ${this.currentPlayer}`);
                }
            }

            // æ£€æŸ¥æ˜¯å¦æœ‰ç©å®¶å®Œæˆæ¸¸æˆï¼ˆæ‰‹ç‰Œä¸º0ï¼‰
            checkGameEnd() {
                // æ£€æŸ¥æ˜¯å¦æœ‰ç©å®¶æ‰‹ç‰Œä¸º0
                for (let position in this.players) {
                    if (this.players[position].cards.length === 0) {
                        // è®°å½•å®Œæˆæ¸¸æˆçš„ç©å®¶
                        if (!this.finishedPlayers.includes(position)) {
                            this.finishedPlayers.push(position);
                            console.log(`${position} å®Œæˆæ¸¸æˆï¼Œå½“å‰æ’å: ${this.finishedPlayers.join(', ')}`);
                        }
                    }
                }

                // æ£€æŸ¥æ˜¯å¦å¤´æ¸¸äº§ç”Ÿï¼ˆç¬¬ä¸€ä¸ªå®Œæˆçš„äººï¼‰
                if (this.finishedPlayers.length === 1 && !this.gameEnded) {
                    const firstPlace = this.finishedPlayers[0];
                    console.log(`${firstPlace} è·å¾—å¤´æ¸¸ï¼`);
                    this.showMessage(`${this.players[firstPlace].name} è·å¾—å¤´æ¸¸ï¼`, 'info');

                    // å¤´æ¸¸äº§ç”Ÿåï¼Œç»§ç»­æ¸¸æˆç›´åˆ°ç¡®å®šäºŒæ¸¸
                    return false;
                }

                // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ç©å®¶éƒ½å®Œæˆæ¸¸æˆ
                if (this.finishedPlayers.length === 4) {
                    console.log('æ‰€æœ‰ç©å®¶å®Œæˆæ¸¸æˆï¼Œæ¸¸æˆç»“æŸï¼');
                    this.gameEnded = true;
                    this.endGame();
                    return true;
                }

                return false;
            }

            // æ¸¸æˆç»“æŸå¤„ç†
            endGame() {
                this.gameState = 'ended';

                // ç¡®å®šæœ€ç»ˆæ’å
                this.gameRankings = [...this.finishedPlayers]; // [å¤´æ¸¸, äºŒæ¸¸, ä¸‰æ¸¸, æœ«æ¸¸]

                // åˆ¤å®šèƒœè´Ÿ
                const result = this.determineGameResult();

                // æ˜¾ç¤ºç»“æœ
                this.showGameResult(result);

                // è¯¢é—®æ˜¯å¦å¼€å§‹æ–°æ¸¸æˆ
                setTimeout(() => {
                    if (confirm(`æ¸¸æˆç»“æŸï¼\n${result.description}\næ˜¯å¦å¼€å§‹æ–°çš„ä¸€å±€ï¼Ÿ`)) {
                        this.startNewGame();
                    }
                }, 2000);
            }

            // åˆ¤å®šæ¸¸æˆç»“æœ
            determineGameResult() {
                const [first, second, third, fourth] = this.gameRankings;

                // ç¡®å®šé˜Ÿä¼
                const firstTeam = this.players[first].team;
                const secondTeam = this.players[second].team;

                // åˆ¤å®šèƒœè´Ÿ
                if (firstTeam === secondTeam) {
                    // å¤´æ¸¸å’ŒäºŒæ¸¸åŒé˜Ÿ
                    const winnerTeam = firstTeam === 'A' ? 'å·±æ–¹ï¼ˆAé˜Ÿï¼‰' : 'å¯¹æ–¹ï¼ˆBé˜Ÿï¼‰';
                    const levelsUp = 3;
                    return {
                        winner: winnerTeam,
                        type: 'å¤´æ¸¸+äºŒæ¸¸',
                        levelsUp: levelsUp,
                        description: `${winnerTeam}è·èƒœï¼\nå¤´æ¸¸+äºŒæ¸¸ï¼Œå‡${levelsUp}çº§`,
                        rankings: this.gameRankings
                    };
                } else {
                    // æ‰¾å‡ºä¸‰æ¸¸çš„é˜Ÿä¼
                    const thirdTeam = this.players[third].team;
                    if (firstTeam === thirdTeam) {
                        // å¤´æ¸¸å’Œä¸‰æ¸¸åŒé˜Ÿ
                        const winnerTeam = firstTeam === 'A' ? 'å·±æ–¹ï¼ˆAé˜Ÿï¼‰' : 'å¯¹æ–¹ï¼ˆBé˜Ÿï¼‰';
                        const levelsUp = 2;
                        return {
                            winner: winnerTeam,
                            type: 'å¤´æ¸¸+ä¸‰æ¸¸',
                            levelsUp: levelsUp,
                            description: `${winnerTeam}è·èƒœï¼\nå¤´æ¸¸+ä¸‰æ¸¸ï¼Œå‡${levelsUp}çº§`,
                            rankings: this.gameRankings
                        };
                    } else {
                        // å¤´æ¸¸å’Œæœ«æ¸¸åŒé˜Ÿ
                        const winnerTeam = firstTeam === 'A' ? 'å·±æ–¹ï¼ˆAé˜Ÿï¼‰' : 'å¯¹æ–¹ï¼ˆBé˜Ÿï¼‰';
                        const levelsUp = 1;
                        return {
                            winner: winnerTeam,
                            type: 'å¤´æ¸¸+æœ«æ¸¸',
                            levelsUp: levelsUp,
                            description: `${winnerTeam}è·èƒœï¼\nå¤´æ¸¸+æœ«æ¸¸ï¼Œå‡${levelsUp}çº§`,
                            rankings: this.gameRankings
                        };
                    }
                }
            }

            // æ˜¾ç¤ºæ¸¸æˆç»“æœ
            showGameResult(result) {
                const rankings = result.rankings.map((pos, index) => {
                    const rankNames = ['å¤´æ¸¸', 'äºŒæ¸¸', 'ä¸‰æ¸¸', 'æœ«æ¸¸'];
                    return `${rankNames[index]}: ${this.players[pos].name}`;
                }).join('\n');

                console.log('=== æ¸¸æˆç»“æœ ===');
                console.log(rankings);
                console.log(result.description);
                console.log('================');

                // åº”ç”¨å‡çº§ç»“æœ
                this.applyLevelChange(result);
            }

            // åº”ç”¨å‡çº§ç»“æœ
            applyLevelChange(result) {
                // æ ¹æ®èƒœè´Ÿç»“æœæ›´æ–°å½“å‰çº§æ•°
                const winnerTeam = result.winner.includes('å·±æ–¹') ? 'A' : 'B';

                // è·å–èƒœæ–¹çš„å½“å‰çº§æ•°
                const currentTeamLevel = winnerTeam === 'A' ? this.teamAScore : this.teamBScore;
                const newLevel = currentTeamLevel + result.levelsUp;

                // æ›´æ–°èƒœæ–¹çº§æ•°
                if (winnerTeam === 'A') {
                    this.teamAScore = newLevel;
                } else {
                    this.teamBScore = newLevel;
                }

                // å…¨å±€å½“å‰çº§æ•°å–ä¸¤ä¸ªé˜Ÿä¼çº§æ•°çš„è¾ƒå¤§å€¼
                this.currentLevel = Math.max(this.teamAScore, this.teamBScore);

                // æ›´æ–°è§„åˆ™å¼•æ“çš„çº§æ•°
                if (this.ruleEngine) {
                    this.ruleEngine.setLevel(this.currentLevel);
                }

                // ä¸‹ä¸€å±€é¦–å‡ºç©å®¶æ˜¯æœ«æ¸¸
                this.lastGameLoser = this.gameRankings[3]; // æœ«æ¸¸

                console.log(`[å‡çº§] ${result.winner}ä»${currentTeamLevel}çº§å‡åˆ°${newLevel}çº§`);
                console.log(`[é¦–å‡º] ä¸‹ä¸€å±€ç”±${this.players[this.lastGameLoser].name}å…ˆå‡ºç‰Œ`);
            }

            // æ£€æŸ¥æ˜¯å¦å¼€å§‹æ–°è½®æ¬¡
            checkNewRound() {
                if (this.currentRoundCards.length === 0) return false;

                // åªè€ƒè™‘æœ€è¿‘çš„æ“ä½œï¼ˆé¿å…æ•°ç»„è¿‡é•¿ï¼‰
                const recentCards = this.currentRoundCards.slice(-8);
                const currentRoundPlays = recentCards.filter(play => play.action !== 'pass');
                const passActions = recentCards.filter(play => play.action === 'pass');

                // æƒ…å†µ1ï¼šè¿ç»­ä¸‰å®¶pass
                if (passActions.length >= 3) {
                    return true;
                }

                // æƒ…å†µ2ï¼šä¸€è½®ç»“æŸï¼ˆå››å®¶éƒ½å‡ºè¿‡ç‰Œï¼Œä¸”æœ€åä¸€å®¶æ˜¯èµ¢å®¶ï¼‰
                const uniquePlayers = new Set(recentCards.map(play => play.player));
                if (uniquePlayers.size === 4) {
                    // æ£€æŸ¥æ˜¯å¦å›åˆ°èµ·å§‹ç©å®¶æˆ–æœ€åå‡ºç‰Œè€…
                    const lastPlay = recentCards[recentCards.length - 1];
                    if (lastPlay && lastPlay.cards.length > 0) {
                        return true;
                    }
                }

                // æƒ…å†µ3ï¼šå½“å‰è½®æ¬¡æœ‰æœ‰æ•ˆå‡ºç‰Œï¼Œä¸”è½®åˆ°èµ·å§‹ç©å®¶
                if (currentRoundPlays.length > 0 && this.currentPlayer === this.getFirstPlayerOfRound()) {
                    return true;
                }

                return false;
            }

            // è·å–å½“å‰è½®æ¬¡çš„èµ·å§‹ç©å®¶
            getFirstPlayerOfRound() {
                if (this.currentRoundCards.length === 0) return this.currentPlayer;

                // æ‰¾åˆ°ç¬¬ä¸€ä¸ªépassçš„ç©å®¶
                for (let play of this.currentRoundCards) {
                    if (play.action !== 'pass' && play.cards.length > 0) {
                        return play.player;
                    }
                }
                return this.currentPlayer;
            }

            // å¼€å§‹æ–°ä¸€è½®ï¼ˆæ¸…é™¤ä¹‹å‰çš„å‡ºç‰Œï¼Œå¹¶æ£€æŸ¥AIç»§ç»­ï¼‰
            startNewRound() {
                this.currentRoundCards = [];
                this.lastPlayer = null;
                this.updatePlayArea();
            }

            // å¼€å§‹æ–°æ¸¸æˆ
            startNewGame() {
                this.isFirstGame = false;
                this.currentRoundCards = [];
                this.lastPlayer = null;
                this.selectedCards = [];
                this.lastPlay = null;

                // é‡ç½®æ¸¸æˆç»“æŸç›¸å…³å˜é‡
                this.gameRankings = [];
                this.gameEnded = false;
                this.finishedPlayers = [];

                // æ¸…ç©ºæ‰€æœ‰ç©å®¶æ‰‹ç‰Œ
                for (let pos in this.players) {
                    this.players[pos].cards = [];
                }

                // é‡æ–°åˆå§‹åŒ–æ¸¸æˆ
                this.initializeGame();
            }

            // è¾…åŠ©å‡½æ•°ï¼šæŒ‰ç‚¹æ•°åˆ†ç»„
            groupCardsByRank(cards) {
                const groups = {};
                cards.forEach(card => {
                    if (!groups[card.rank]) {
                        groups[card.rank] = [];
                    }
                    groups[card.rank].push(card);
                });
                return groups;
            }

            // è¾…åŠ©å‡½æ•°ï¼šè·å–ç‰Œé¢å€¼å¤§å°
            getRankValue(rank) {
                // æ¼è›‹è§„åˆ™ï¼šA > K > Q > J > 10 > 9 > 8 > 7 > 6 > 5 > 4 > 3 > 2
                const rankOrder = {
                    '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
                    'J': 11, 'Q': 12, 'K': 13, 'A': 14, 'å°ç‹': 102, 'å¤§ç‹': 103
                };

                // ç‹å¯¹ç‰¹æ®Šå¤„ç†
                if (rank === 'ç‹å¯¹') {
                    return 999;  // ç¡®ä¿ç‹å¯¹æœ€å¤§
                }

                return rankOrder[rank] || 0;
            }

            // æ›´æ–°è®°ç‰Œç³»ç»Ÿ
            updateCardMemory(player, cards) {
                // è®°å½•æ¯ä¸ªç©å®¶å‡ºçš„ç‰Œ
                this.cardMemory[player].push(...cards);

                // è®°å½•æ‰€æœ‰å·²å‡ºçš„ç‰Œ
                this.playedCards.push(...cards);
            }

            // AIæ™ºèƒ½åˆ†æå‰©ä½™ç‰Œ
            analyzeRemainingCards(player) {
                const remainingCards = this.players[player].cards;
                const analysis = {
                    singles: [],
                    pairs: [],
                    triples: [],
                    bombs: [],
                    totalCards: remainingCards.length
                };

                // æŒ‰ç‚¹æ•°åˆ†ç»„
                const rankGroups = {};
                remainingCards.forEach(card => {
                    if (!rankGroups[card.rank]) {
                        rankGroups[card.rank] = [];
                    }
                    rankGroups[card.rank].push(card);
                });

                // åˆ†æç‰Œå‹
                for (let rank in rankGroups) {
                    const group = rankGroups[rank];
                    if (group.length === 1) {
                        analysis.singles.push(group[0]);
                    } else if (group.length === 2) {
                        analysis.pairs.push(group);
                    } else if (group.length === 3) {
                        analysis.triples.push(group);
                    } else if (group.length >= 4) {
                        analysis.bombs.push(group);
                    }
                }

                return analysis;
            }

            // AIæ™ºèƒ½å‡ºç‰Œå†³ç­–
            makeAIPlayDecision(cards) {
                if (!cards || cards.length === 0) return null;

                // åˆ†ææ‰‹ç‰Œç»“æ„
                const analysis = this.analyzeCards(cards);

                // æ ¹æ®ä¸åŒæƒ…å†µé€‰æ‹©å‡ºç‰Œç­–ç•¥
                const strategies = [
                    // ç­–ç•¥1ï¼šå¦‚æœæ‰‹ç‰Œå¾ˆå°‘ï¼Œä¼˜å…ˆå‡ºå•å¼ æˆ–å¯¹å­
                    () => {
                        if (cards.length <= 3) {
                            // å‡ºæœ€å°çš„å•å¼ 
                            if (analysis.singles.length > 0) {
                                return {
                                    cards: [analysis.singles[0]],
                                    reason: 'æ‰‹ç‰Œè¾ƒå°‘ï¼Œå‡ºå°å•å¼ '
                                };
                            }
                        }
                        return null;
                    },

                    // ç­–ç•¥2ï¼šå°è¯•å‡ºå¯¹å­ï¼ˆæ‹†æ•£ä¸‰å¼ ï¼‰
                    () => {
                        if (analysis.pairs.length > 0) {
                            // é€‰æ‹©æœ€å°çš„å¯¹å­
                            return {
                                cards: analysis.pairs[0],
                                reason: 'å‡ºå¯¹å­æ§åˆ¶èŠ‚å¥'
                            };
                        }
                        return null;
                    },

                    // ç­–ç•¥3ï¼šå¦‚æœæœ‰ä¸‰å¼ ä¸”ä¸æ˜¯ç‚¸å¼¹ï¼Œè€ƒè™‘æ‹†å¼€
                    () => {
                        if (analysis.triples.length > 0 && analysis.bombs.length === 0) {
                            // ä¼˜å…ˆä¿ç•™ç‚¸å¼¹ï¼Œæ‹†å¼€æ™®é€šçš„ä¸‰å¼ 
                            const triple = analysis.triples[0];
                            return {
                                cards: [triple[0]], // å‡ºä¸€å¼ 
                                reason: 'æ‹†ä¸‰å¼ ï¼Œä¿ç•™ç‰ŒåŠ›'
                            };
                        }
                        return null;
                    },

                    // ç­–ç•¥4ï¼šå°è¯•å‡ºé¡ºå­
                    () => {
                        const straights = this.findStraights(cards);
                        if (straights.length > 0 && straights[0].length >= 5) {
                            // å‡ºæœ€çŸ­çš„é¡ºå­
                            return {
                                cards: straights[0],
                                reason: 'å‡ºé¡ºå­æ¸…ç†æ‰‹ç‰Œ'
                            };
                        }
                        return null;
                    },

                    // ç­–ç•¥5ï¼šé»˜è®¤å‡ºæœ€å°çš„å•å¼ 
                    () => {
                        const sortedCards = [...cards].sort((a, b) =>
                            this.getRankValue(a.rank) - this.getRankValue(b.rank)
                        );
                        return {
                            cards: [sortedCards[0]],
                            reason: 'å‡ºæœ€å°å•å¼ '
                        };
                    }
                ];

                // ä¾æ¬¡å°è¯•ç­–ç•¥
                for (let strategy of strategies) {
                    const decision = strategy();
                    if (decision) return decision;
                }

                return null;
            }

            // åˆ†ææ‰‹ç‰Œç»“æ„
            analyzeCards(cards) {
                const ranks = {};
                cards.forEach(card => {
                    const rank = card.rank;
                    if (!ranks[rank]) {
                        ranks[rank] = [];
                    }
                    ranks[rank].push(card);
                });

                const analysis = {
                    singles: [],
                    pairs: [],
                    triples: [],
                    bombs: []
                };

                Object.values(ranks).forEach(group => {
                    if (group.length === 1) {
                        analysis.singles.push(group[0]);
                    } else if (group.length === 2) {
                        analysis.pairs.push(group);
                    } else if (group.length === 3) {
                        analysis.triples.push(group);
                    } else if (group.length >= 4) {
                        analysis.bombs.push(group);
                    }
                });

                // æ’åº
                analysis.singles.sort((a, b) => this.getRankValue(a.rank) - this.getRankValue(b.rank));
                analysis.pairs.sort((a, b) => this.getRankValue(a[0].rank) - this.getRankValue(b[0].rank));
                analysis.triples.sort((a, b) => this.getRankValue(a[0].rank) - this.getRankValue(b[0].rank));

                return analysis;
            }

            // æŸ¥æ‰¾å¯èƒ½çš„é¡ºå­
            findStraights(cards) {
                const ranks = [...new Set(cards.map(c => this.getRankValue(c.rank)))].sort((a, b) => a - b);
                const straights = [];

                // ç§»é™¤å¤§å°ç‹å’Œ2
                const validRanks = ranks.filter(r => r < 15); // 15æ˜¯2çš„å€¼

                for (let i = 0; i < validRanks.length; i++) {
                    for (let j = i + 4; j < validRanks.length; j++) {
                        if (validRanks[j] - validRanks[i] === j - i) {
                            // æ‰¾åˆ°äº†é¡ºå­
                            const straightRanks = validRanks.slice(i, j + 1);
                            const straightCards = [];

                            straightRanks.forEach(rank => {
                                const card = cards.find(c => this.getRankValue(c.rank) === rank);
                                if (card) straightCards.push(card);
                            });

                            if (straightCards.length === straightRanks.length) {
                                straights.push(straightCards);
                            }
                        }
                    }
                }

                return straights;
            }

            // AIæ™ºèƒ½å†³ç­–
            makeAIDecision(player) {
                const analysis = this.analyzeRemainingCards(this.currentPlayer);
                const partner = this.getPartner(this.currentPlayer);

                // ç®€å•ç­–ç•¥1ï¼šå¦‚æœåªå‰©ä¸€å¼ ç‰Œï¼Œç›´æ¥å‡º
                if (analysis.totalCards === 1) {
                    return {
                        action: 'play',
                        cards: [analysis.singles[0]]
                    };
                }

                // ç®€å•ç­–ç•¥2ï¼šå¦‚æœæ˜¯è‡ªç”±å‡ºç‰Œï¼Œå‡ºæœ€å°çš„å•å¼ 
                if (!this.roundActive || !this.lastPlay) {
                    if (analysis.singles.length > 0) {
                        // æ‰¾æœ€å°çš„å•å¼ 
                        analysis.singles.sort((a, b) => this.getRankValue(a.rank) - this.getRankValue(b.rank));
                        return {
                            action: 'play',
                            cards: [analysis.singles[0]]
                        };
                    }
                }

                // ç®€å•ç­–ç•¥3ï¼šå°è¯•æ‰“è¿‡å¯¹æ‰‹
                const validPlay = this.findValidPlay(this.players[player].cards, this.lastPlay);
                if (validPlay) {
                    return {
                        action: 'play',
                        cards: validPlay
                    };
                }

                // é»˜è®¤ç­–ç•¥ï¼šè¿‡ç‰Œ
                return {
                    action: 'pass'
                };
            }

            // è·å–é˜Ÿå‹
            getPartner(player) {
                const partnerships = {
                    'south': 'north',
                    'north': 'south',
                    'east': 'west',
                    'west': 'east'
                };
                return partnerships[player];
            }

            // æŸ¥æ‰¾åˆæ³•å‡ºç‰Œ
            findValidPlay(handCards, lastPlay) {
                if (!lastPlay || !lastPlay.cards) return null;

                const possiblePlays = [];

                // å°è¯•æ‰€æœ‰å¯èƒ½çš„å‡ºç‰Œç»„åˆ
                // 1. å•å¼ 
                for (let card of handCards) {
                    if (this.ruleEngine.canBeat([card], lastPlay.cards)) {
                        possiblePlays.push([card]);
                    }
                }

                // 2. å¯¹å­
                const pairs = this.findPairs(handCards);
                for (let pair of pairs) {
                    if (this.ruleEngine.canBeat(pair, lastPlay.cards)) {
                        possiblePlays.push(pair);
                    }
                }

                // 3. ä¸‰å¼ 
                const triples = this.findTriples(handCards);
                for (let triple of triples) {
                    if (this.ruleEngine.canBeat(triple, lastPlay.cards)) {
                        possiblePlays.push(triple);
                    }
                }

                // 4. ç‚¸å¼¹
                const bombs = this.findBombs(handCards);
                for (let bomb of bombs) {
                    if (this.ruleEngine.canBeat(bomb, lastPlay.cards)) {
                        possiblePlays.push(bomb);
                    }
                }

                // è¿”å›æœ€å°çš„åˆæ³•å‡ºç‰Œ
                if (possiblePlays.length > 0) {
                    // ç®€å•é€‰æ‹©ç¬¬ä¸€ä¸ªï¼Œå®é™…åº”è¯¥é€‰æ‹©æœ€ä¼˜ç­–ç•¥
                    return possiblePlays[0];
                }

                return null;
            }

            // æŸ¥æ‰¾å¯¹å­
            findPairs(cards) {
                const rankGroups = {};
                const pairs = [];

                // æŒ‰ç‚¹æ•°åˆ†ç»„
                cards.forEach(card => {
                    if (!rankGroups[card.rank]) {
                        rankGroups[card.rank] = [];
                    }
                    rankGroups[card.rank].push(card);
                });

                // æå–å¯¹å­
                for (let rank in rankGroups) {
                    const group = rankGroups[rank];
                    if (group.length >= 2) {
                        pairs.push([group[0], group[1]]);
                    }
                }

                return pairs;
            }

            // æŸ¥æ‰¾ä¸‰å¼ 
            findTriples(cards) {
                const rankGroups = {};
                const triples = [];

                // æŒ‰ç‚¹æ•°åˆ†ç»„
                cards.forEach(card => {
                    if (!rankGroups[card.rank]) {
                        rankGroups[card.rank] = [];
                    }
                    rankGroups[card.rank].push(card);
                });

                // æå–ä¸‰å¼ 
                for (let rank in rankGroups) {
                    const group = rankGroups[rank];
                    if (group.length >= 3) {
                        triples.push([group[0], group[1], group[2]]);
                    }
                }

                return triples;
            }

            // æŸ¥æ‰¾ç‚¸å¼¹
            findBombs(cards) {
                const rankGroups = {};
                const bombs = [];

                // æŒ‰ç‚¹æ•°åˆ†ç»„
                cards.forEach(card => {
                    if (!rankGroups[card.rank]) {
                        rankGroups[card.rank] = [];
                    }
                    rankGroups[card.rank].push(card);
                });

                // æå–ç‚¸å¼¹ï¼ˆ4å¼ åŠä»¥ä¸Šï¼‰
                for (let rank in rankGroups) {
                    const group = rankGroups[rank];
                    if (group.length >= 4) {
                        bombs.push(group);
                    }
                }

                // æ£€æŸ¥å¤©ç‹ç‚¸å¼¹
                const jokers = cards.filter(c => c.suit === 'joker');
                if (jokers.length === 4) {
                    bombs.push(jokers);
                }

                return bombs;
            }

            // åˆå§‹åŒ–éŸ³é¢‘ï¼ˆåœ¨ç”¨æˆ·é¦–æ¬¡äº¤äº’æ—¶è°ƒç”¨ï¼‰
            initAudio() {
                if (!this.audioContext) {
                    try {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        if (this.audioContext.state === 'suspended') {
                            this.audioContext.resume();
                        }
                    } catch (error) {
                        console.log('éŸ³é¢‘åˆå§‹åŒ–å¤±è´¥');
                    }
                }
            }

            // è·å–éšæœºæ€è€ƒæ—¶é—´
            getRandomThinkingTime() {
                // ä¼˜åŒ–ï¼šå‡å°‘AIæ€è€ƒæ—¶é—´ï¼Œè®©æ¸¸æˆæ›´æµç•…
                const baseTime = 600; // åŸºç¡€æ€è€ƒæ—¶é—´0.6ç§’ï¼ˆåŸ1.5ç§’ï¼‰
                const variation = Math.random() * 800; // éšæœºå˜åŒ–0-0.8ç§’ï¼ˆåŸ0-2ç§’ï¼‰

                // ç¬¬ä¸€æ¬¡å‡ºç‰Œæ—¶é€‚å½“å¢åŠ æ€è€ƒæ—¶é—´
                const isFirstPlay = this.currentRoundCards.length === 0 ||
                    this.currentRoundCards.every(play => play.cards.length === 0);
                const extraTime = isFirstPlay ? 400 : 0; // é¢å¤–0.4ç§’ï¼ˆåŸ1ç§’ï¼‰

                // æ ¹æ®AIå‰©ä½™æ‰‹ç‰Œæ•°é‡è°ƒæ•´æ€è€ƒæ—¶é—´ï¼ˆç‰Œå°‘æ—¶å‡ºç‰Œæ›´å¿«ï¼‰
                const aiPlayer = this.players[this.currentPlayer];
                const cardCountBonus = aiPlayer && aiPlayer.cards ? Math.min(10, aiPlayer.cards.length) * 20 : 0;

                return baseTime + variation + extraTime + cardCountBonus;
            }

            // æ˜¾ç¤ºAIæ€è€ƒçŠ¶æ€
            showAIThinking(player) {
                const positions = {
                    'west': 'è¥¿å®¶AI',
                    'north': 'åŒ—å®¶AI',
                    'east': 'ä¸œå®¶AI'
                };

                // åœ¨å¯¹åº”ç©å®¶ä½ç½®æ˜¾ç¤ºæ€è€ƒåŠ¨ç”»
                const positionElement = document.getElementById(player + 'Hand');
                if (positionElement) {
                    positionElement.classList.add('thinking');
                }

                // æ˜¾ç¤ºæ€è€ƒæç¤º
                this.showMessage(`${positions[player]}æ­£åœ¨æ€è€ƒ...`, 'info');
            }

            // æ¸…é™¤AIæ€è€ƒçŠ¶æ€
            clearAIThinking(player) {
                const positionElement = document.getElementById(player + 'Hand');
                if (positionElement) {
                    positionElement.classList.remove('thinking');
                }
            }

            // æ’­æ”¾éŸ³æ•ˆ
            playSound(soundType) {
                // å¦‚æœéŸ³é¢‘ä¸Šä¸‹æ–‡æœªå¯åŠ¨ï¼Œåˆ™ä¸æ’­æ”¾
                if (!this.audioContext) {
                    this.initAudio();
                    if (!this.audioContext || this.audioContext.state === 'suspended') {
                        return;
                    }
                }

                // æ’­æ”¾ç®€å•çš„éŸ³æ•ˆ
                try {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);

                    // æ ¹æ®éŸ³æ•ˆç±»å‹è®¾ç½®ä¸åŒçš„é¢‘ç‡å’Œæ¨¡å¼
                    switch(soundType) {
                        case 'play':
                            oscillator.frequency.value = 800;
                            gainNode.gain.value = 0.1;
                            oscillator.start();
                            oscillator.stop(this.audioContext.currentTime + 0.1);
                            break;
                        case 'pass':
                            oscillator.frequency.value = 300;
                            gainNode.gain.value = 0.05;
                            oscillator.start();
                            oscillator.stop(this.audioContext.currentTime + 0.2);
                            break;
                        case 'bomb':
                            oscillator.frequency.value = 1200;
                            gainNode.gain.value = 0.2;
                            oscillator.start();
                            oscillator.stop(this.audioContext.currentTime + 0.3);
                            break;
                        case 'win':
                            // æ’­æ”¾ä¸Šå‡éŸ³è°ƒ
                            oscillator.frequency.setValueAtTime(400, this.audioContext.currentTime);
                            oscillator.frequency.exponentialRampToValueAtTime(1600, this.audioContext.currentTime + 0.5);
                            gainNode.gain.value = 0.15;
                            oscillator.start();
                            oscillator.stop(this.audioContext.currentTime + 0.5);
                            break;
                        case 'levelup':
                            // æ’­æ”¾è¿ç»­çš„éŸ³è°ƒ
                            for (let i = 0; i < 3; i++) {
                                const osc = this.audioContext.createOscillator();
                                const gain = this.audioContext.createGain();
                                osc.connect(gain);
                                gain.connect(this.audioContext.destination);
                                osc.frequency.value = 600 + i * 200;
                                gain.gain.value = 0.1;
                                osc.start(this.audioContext.currentTime + i * 0.1);
                                osc.stop(this.audioContext.currentTime + i * 0.1 + 0.1);
                            }
                            break;
                    }
                } catch (error) {
                    // é™é»˜å¤„ç†éŸ³æ•ˆé”™è¯¯
                    console.log('éŸ³æ•ˆæ’­æ”¾å¤±è´¥:', error);
                }
            }

            generateSmartHints() {
                const hints = [];
                const playerCards = this.players.south.cards;

                // è·å–ä¸Šå®¶å‡ºç‰Œ
                const lastPlay = this.getLastPlay();

                if (!lastPlay || !lastPlay.cards || lastPlay.cards.length === 0) {
                    // é¦–å‡ºæƒ…å†µ - æ¨èæœ€å°å•å¼ 
                    const sortedCards = [...playerCards].sort((a, b) => this.getRankValue(a.rank) - this.getRankValue(b.rank));
                    if (sortedCards.length > 0) {
                        hints.push({
                            cards: [sortedCards[0]],
                            description: `å‡ºæœ€å°å•å¼  ${sortedCards[0].rank}${sortedCards[0].suit}`
                        });
                    }
                    return hints;
                }

                // è·Ÿç‰Œæƒ…å†µ - ä½¿ç”¨findAllPossiblePlays
                const possiblePlays = this.findAllPossiblePlays(playerCards, lastPlay);

                // æŒ‰æƒé‡ä»å°åˆ°å¤§æ’åº
                possiblePlays.sort((a, b) => {
                    // å¦‚æœéƒ½æ˜¯ç‚¸å¼¹ï¼ŒæŒ‰å¼ æ•°å’Œå¤§å°æ’åº
                    if (a.type && a.type.family === 'bomb' && b.type && b.type.family === 'bomb') {
                        if (a.cards.length !== b.cards.length) {
                            return a.cards.length - b.cards.length;
                        }
                        return this.getRankValue(a.cards[0].rank) - this.getRankValue(b.cards[0].rank);
                    }
                    // ç‚¸å¼¹æ’åœ¨æœ€å
                    if (a.type && a.type.family === 'bomb') return 1;
                    if (b.type && b.type.family === 'bomb') return -1;
                    // æ™®é€šç‰Œå‹æŒ‰æƒé‡æ’åº
                    return (a.type ? a.type.weight : 0) - (b.type ? b.type.weight : 0);
                });

                // è½¬æ¢ä¸ºæç¤ºæ ¼å¼
                possiblePlays.forEach(play => {
                    const cardsText = play.cards.map(c => c.rank + c.suit).join(' ');
                    const typeName = this.getCardTypeName(play.type);
                    hints.push({
                        cards: play.cards,
                        description: `å‡º${typeName} ${cardsText}`
                    });
                });

                return hints;
            }

            showHint() {
                // é˜²æ­¢é‡å¤ç‚¹å‡»
                const now = Date.now();
                if (now - this.lastHintTime < 500) return;
                this.lastHintTime = now;

                // æ£€æŸ¥æ˜¯å¦è½®åˆ°ç©å®¶
                if (this.currentPlayer !== 'south' || this.gameState !== 'playing') {
                    this.showMessage("ä¸æ˜¯ä½ çš„å›åˆ");
                    return;
                }

                // å¦‚æœå·²ç»æœ‰æç¤ºï¼Œåˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ª
                if (this.isHintMode && this.availableHints.length > 1) {
                    this.currentHintIndex = (this.currentHintIndex + 1) % this.availableHints.length;
                    this.applyCurrentHint();
                    return;
                }

                // ç”Ÿæˆæ‰€æœ‰æç¤º
                this.availableHints = this.generateSmartHints();

                // æ— ç‰Œå¯å‡º
                if (this.availableHints.length === 0) {
                    this.showMessage("æ²¡æœ‰èƒ½ç®¡ä½çš„ç‰Œï¼Œè‡ªåŠ¨è¿‡ç‰Œ", 'info');
                    setTimeout(() => {
                        this.passTurn();
                    }, 1000);
                    return;
                }

                // è¿›å…¥æç¤ºæ¨¡å¼
                this.isHintMode = true;
                this.currentHintIndex = 0;
                this.applyCurrentHint();
            }

            applyCurrentHint() {
                const hint = this.availableHints[this.currentHintIndex];

                // æ¸…ç©ºä¹‹å‰çš„é€‰æ‹©
                this.clearSelection();

                // è‡ªåŠ¨é€‰ç‰Œ
                hint.cards.forEach(card => {
                    const cardIndex = this.players.south.cards.findIndex(c =>
                        c.id === card.id || (c.rank === card.rank && c.suit === card.suit)
                    );
                    if (cardIndex !== -1) {
                        this.selectCardByIndex(cardIndex);
                    }
                });

                // æ˜¾ç¤ºæç¤ºä¿¡æ¯
                const currentIndexText = this.availableHints.length > 1 ?
                    ` (${this.currentHintIndex + 1}/${this.availableHints.length})` : '';
                this.showMessage(`æç¤º${currentIndexText}: ${hint.description}`, 'info');

                // æ’­æ”¾æç¤ºéŸ³æ•ˆ
                this.playSound('hint');
            }

            selectCardByIndex(index) {
                const cardElement = document.querySelectorAll('#southCards .player-card')[index];
                if (cardElement && !cardElement.classList.contains('selected')) {
                    cardElement.classList.add('selected');
                    this.selectedCards.push(this.players.south.cards[index]);
                }
            }

            getCardTypeName(cardType) {
                if (!cardType) return 'æœªçŸ¥ç‰Œå‹';

                // æ ¹æ®subtypeå’Œtypeå…±åŒåˆ¤æ–­
                if (cardType.family === 'bomb') {
                    if (cardType.subtype === 'kingBomb') {
                        return 'å¤©ç‹ç‚¸';
                    } else if (cardType.subtype === 'straightFlush') {
                        return `${cardType.length || 5}å¼ åŒèŠ±é¡º`;
                    } else {
                        // æ™®é€šç‚¸å¼¹
                        return `${cardType.count}å¼ ç‚¸å¼¹`;
                    }
                }

                const typeNames = {
                    'single': 'å•å¼ ',
                    'pair': 'å¯¹å­',
                    'triple': 'ä¸‰å¼ ',
                    'three_with_pair': 'ä¸‰å¸¦äºŒ',
                    'straight': 'é¡ºå­',
                    'consecutive_pairs': 'è¿å¯¹',
                    'airplane': 'é’¢æ¿'
                };

                // å¤„ç†ç‰¹æ®Šå¯¹å­
                if (cardType.type === 'pair' && cardType.rank === 'ç‹å¯¹') {
                    return 'ç‹å¯¹';
                }

                return typeNames[cardType.type] || cardType.type || 'æœªçŸ¥ç‰Œå‹';
            }

            reportCards() {
                const southCards = this.players.south.cards;
                const message = `ä½ çš„æ‰‹ç‰Œï¼š${southCards.length}å¼ `;
                this.showMessage(message, 'info');
            }

            // æ‰¾åˆ°æ‰€æœ‰å¯èƒ½çš„å‡ºç‰Œ
            findAllPossiblePlays(handCards, lastPlay) {
                const possiblePlays = [];

                // å¦‚æœæ²¡æœ‰lastPlayæˆ–æ²¡æœ‰cardsï¼Œè¯´æ˜æ˜¯é¦–å‡º
                if (!lastPlay || !lastPlay.cards) {
                    // é¦–å‡ºæ—¶ï¼Œä¼˜å…ˆå‡ºå•å¼ å°ç‰Œ
                    // æ‰¾å‡ºæ‰€æœ‰å•å¼ 
                    const singles = [];
                    for (let card of handCards) {
                        const type = this.rules.getCardType([card]);
                        if (type) {
                            singles.push({
                                cards: [card],
                                type: type,
                                score: this.getRankValue(card.rank)
                            });
                        }
                    }
                    // æŒ‰ä»å°åˆ°å¤§æ’åº
                    singles.sort((a, b) => a.score - b.score);
                    return singles;
                }

                // è·å–ä¸Šå®¶ç‰Œå‹
                const lastType = this.rules.getCardType(lastPlay.cards);
                if (!lastType) return [];

                // ä½¿ç”¨è§„åˆ™å¼•æ“éªŒè¯å‡ºç‰Œ
                // åªæœ‰å½“ä¸Šå®¶ä¹Ÿæ˜¯å•å¼ æ—¶ï¼Œæ‰è€ƒè™‘å‡ºå•å¼ 
                if (lastType.type === 'single') {
                    for (let card of handCards) {
                        const validation = this.rules.validatePlay([card], lastPlay, handCards);
                        if (validation.valid) {
                            possiblePlays.push({
                                cards: [card],
                                type: validation.type
                            });
                        }
                    }
                }

                // å°è¯•å¯¹å­ - è‡ªå·±æŸ¥æ‰¾
                const rankGroups = {};
                handCards.forEach(card => {
                    if (!rankGroups[card.rank]) {
                        rankGroups[card.rank] = [];
                    }
                    rankGroups[card.rank].push(card);
                });

                // æå–å¯¹å­
                for (let rank in rankGroups) {
                    const group = rankGroups[rank];
                    if (group.length >= 2) {
                        const pair = [group[0], group[1]];
                        const validation = this.rules.validatePlay(pair, lastPlay, handCards);
                        if (validation.valid) {
                            possiblePlays.push({
                                cards: pair,
                                type: validation.type
                            });
                        }
                    }
                }

                // å°è¯•ä¸‰å¼  - è‡ªå·±æŸ¥æ‰¾
                for (let rank in rankGroups) {
                    const group = rankGroups[rank];
                    if (group.length >= 3) {
                        const triple = [group[0], group[1], group[2]];
                        const validation = this.rules.validatePlay(triple, lastPlay, handCards);
                        if (validation.valid) {
                            possiblePlays.push({
                                cards: triple,
                                type: validation.type
                            });
                        }
                    }
                }

                // å°è¯•ä¸‰å¸¦äºŒ - è‡ªå·±æŸ¥æ‰¾
                for (let tripleRank in rankGroups) {
                    const tripleGroup = rankGroups[tripleRank];
                    if (tripleGroup.length >= 3) {
                        const triple = [tripleGroup[0], tripleGroup[1], tripleGroup[2]];

                        // æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„å¯¹å­
                        for (let pairRank in rankGroups) {
                            if (pairRank !== tripleRank && rankGroups[pairRank].length >= 2) {
                                const pairGroup = rankGroups[pairRank];
                                const pair = [pairGroup[0], pairGroup[1]];

                                // ç»„åˆæˆä¸‰å¸¦äºŒ
                                const tripleWithPair = [...triple, ...pair];
                                const validation = this.rules.validatePlay(tripleWithPair, lastPlay, handCards);
                                if (validation.valid) {
                                    possiblePlays.push({
                                        cards: tripleWithPair,
                                        type: validation.type
                                    });
                                }
                            }
                        }
                    }
                }

                // å°è¯•é¡ºå­ - è‡ªå·±æŸ¥æ‰¾ï¼ˆ5å¼ åŠä»¥ä¸Šè¿ç»­å•ç‰Œï¼‰
                // é¦–å…ˆæ”¶é›†æ‰€æœ‰éç‹ç‰Œå’Œé2çš„ç‰Œ
                const nonJokerCards = handCards.filter(c =>
                    c.suit !== 'joker' &&
                    c.rank !== '2' &&
                    c.rank !== 'å°ç‹' &&
                    c.rank !== 'å¤§ç‹'
                );

                // æŒ‰ç‚¹æ•°æ’åº
                nonJokerCards.sort((a, b) => this.getRankValue(a.rank) - this.getRankValue(b.rank));

                // æŸ¥æ‰¾å¯èƒ½çš„é¡ºå­
                for (let startIdx = 0; startIdx <= nonJokerCards.length - 5; startIdx++) {
                    for (let length = 5; length <= Math.min(nonJokerCards.length - startIdx, 12); length++) {
                        const straightCards = nonJokerCards.slice(startIdx, startIdx + length);

                        // æ£€æŸ¥æ˜¯å¦è¿ç»­
                        let isConsecutive = true;
                        for (let i = 1; i < straightCards.length; i++) {
                            const prevValue = this.getRankValue(straightCards[i-1].rank);
                            const currValue = this.getRankValue(straightCards[i].rank);
                            if (currValue !== prevValue + 1) {
                                isConsecutive = false;
                                break;
                            }
                        }

                        if (isConsecutive) {
                            const validation = this.rules.validatePlay(straightCards, lastPlay, handCards);
                            if (validation.valid) {
                                possiblePlays.push({
                                    cards: straightCards,
                                    type: validation.type
                                });
                            }
                        }
                    }
                }

                // å°è¯•è¿å¯¹ - è‡ªå·±æŸ¥æ‰¾ï¼ˆ3å¯¹åŠä»¥ä¸Šè¿ç»­å¯¹å­ï¼‰
                // é¦–å…ˆæ”¶é›†æ‰€æœ‰å¯ç”¨çš„å¯¹å­
                const availablePairs = [];
                for (let rank in rankGroups) {
                    if (rankGroups[rank].length >= 2) {
                        availablePairs.push({
                            rank: rank,
                            value: this.getRankValue(rank),
                            cards: [rankGroups[rank][0], rankGroups[rank][1]]
                        });
                    }
                }

                // æŒ‰ç‚¹æ•°æ’åº
                availablePairs.sort((a, b) => a.value - b.value);

                // æŸ¥æ‰¾è¿ç»­çš„å¯¹å­ç»„åˆ
                for (let startIdx = 0; startIdx <= availablePairs.length - 3; startIdx++) {
                    for (let length = 3; length <= availablePairs.length - startIdx; length++) {
                        const selectedPairs = availablePairs.slice(startIdx, startIdx + length);

                        // æ£€æŸ¥æ˜¯å¦è¿ç»­
                        let isConsecutive = true;
                        for (let i = 1; i < selectedPairs.length; i++) {
                            if (selectedPairs[i].value !== selectedPairs[i-1].value + 1) {
                                isConsecutive = false;
                                break;
                            }
                        }

                        if (isConsecutive) {
                            // ç»„åˆæ‰€æœ‰å¯¹å­çš„ç‰Œ
                            const pairStraightCards = [];
                            selectedPairs.forEach(pair => {
                                pairStraightCards.push(...pair.cards);
                            });

                            const validation = this.rules.validatePlay(pairStraightCards, lastPlay, handCards);
                            if (validation.valid) {
                                possiblePlays.push({
                                    cards: pairStraightCards,
                                    type: validation.type
                                });
                            }
                        }
                    }
                }

                // å°è¯•é’¢æ¿ - è‡ªå·±æŸ¥æ‰¾ï¼ˆ2ä¸ªåŠä»¥ä¸Šè¿ç»­ä¸‰å¼ ï¼‰
                // é¦–å…ˆæ”¶é›†æ‰€æœ‰å¯ç”¨çš„ä¸‰å¼ 
                const availableTriples = [];
                for (let rank in rankGroups) {
                    if (rankGroups[rank].length >= 3) {
                        availableTriples.push({
                            rank: rank,
                            value: this.getRankValue(rank),
                            cards: [rankGroups[rank][0], rankGroups[rank][1], rankGroups[rank][2]]
                        });
                    }
                }

                // æŒ‰ç‚¹æ•°æ’åº
                availableTriples.sort((a, b) => a.value - b.value);

                // æŸ¥æ‰¾è¿ç»­çš„ä¸‰å¼ ç»„åˆ
                for (let startIdx = 0; startIdx <= availableTriples.length - 2; startIdx++) {
                    for (let length = 2; length <= availableTriples.length - startIdx; length++) {
                        const selectedTriples = availableTriples.slice(startIdx, startIdx + length);

                        // æ£€æŸ¥æ˜¯å¦è¿ç»­
                        let isConsecutive = true;
                        for (let i = 1; i < selectedTriples.length; i++) {
                            if (selectedTriples[i].value !== selectedTriples[i-1].value + 1) {
                                isConsecutive = false;
                                break;
                            }
                        }

                        if (isConsecutive) {
                            // ç»„åˆæ‰€æœ‰ä¸‰å¼ çš„ç‰Œ
                            const tripleStraightCards = [];
                            selectedTriples.forEach(triple => {
                                tripleStraightCards.push(...triple.cards);
                            });

                            const validation = this.rules.validatePlay(tripleStraightCards, lastPlay, handCards);
                            if (validation.valid) {
                                possiblePlays.push({
                                    cards: tripleStraightCards,
                                    type: validation.type
                                });
                            }
                        }
                    }
                }

                // å°è¯•ç‚¸å¼¹ - è‡ªå·±æŸ¥æ‰¾
                for (let rank in rankGroups) {
                    const group = rankGroups[rank];
                    // å°è¯•4å¼ åˆ°8å¼ ç‚¸å¼¹
                    for (let bombCount = 4; bombCount <= Math.min(group.length, 8); bombCount++) {
                        const bomb = group.slice(0, bombCount);
                        console.log(`[findAllPossiblePlays] å°è¯•${bombCount}å¼ ${rank}: ${bomb.map(c => c.rank + c.suit).join(', ')}`);
                        const validation = this.rules.validatePlay(bomb, lastPlay, handCards);
                        console.log(`[findAllPossiblePlays] éªŒè¯ç»“æœ:`, validation);
                        if (validation.valid) {
                            possiblePlays.push({
                                cards: bomb,
                                type: validation.type
                            });
                            console.log(`[findAllPossiblePlays] âœ“ ${bombCount}å¼ ${rank}å¯ä»¥å‡º`);
                        } else {
                            console.log(`[findAllPossiblePlays] âœ— ${bombCount}å¼ ${rank}ä¸èƒ½å‡º: ${validation.message}`);
                        }
                    }
                }

                // å°è¯•åŒèŠ±é¡º - è‡ªå·±æŸ¥æ‰¾ï¼ˆ5å¼ ä»¥ä¸ŠåŒèŠ±è‰²è¿ç»­ç‰Œï¼‰
                // æŒ‰èŠ±è‰²åˆ†ç»„
                const suitGroups = {};
                handCards.forEach(card => {
                    if (card.suit !== 'joker' && card.rank !== '2' &&
                        card.rank !== 'å°ç‹' && card.rank !== 'å¤§ç‹') {
                        if (!suitGroups[card.suit]) {
                            suitGroups[card.suit] = [];
                        }
                        suitGroups[card.suit].push(card);
                    }
                });

                // æ¯ä¸ªèŠ±è‰²æŸ¥æ‰¾åŒèŠ±é¡º
                for (let suit in suitGroups) {
                    const suitCards = suitGroups[suit];
                    // æŒ‰ç‚¹æ•°æ’åº
                    suitCards.sort((a, b) => this.getRankValue(a.rank) - this.getRankValue(b.rank));

                    // æŸ¥æ‰¾å¯èƒ½çš„åŒèŠ±é¡º
                    for (let startIdx = 0; startIdx <= suitCards.length - 5; startIdx++) {
                        for (let length = 5; length <= Math.min(suitCards.length - startIdx, 12); length++) {
                            const straightFlushCards = suitCards.slice(startIdx, startIdx + length);

                            // æ£€æŸ¥æ˜¯å¦è¿ç»­
                            let isConsecutive = true;
                            for (let i = 1; i < straightFlushCards.length; i++) {
                                const prevValue = this.getRankValue(straightFlushCards[i-1].rank);
                                const currValue = this.getRankValue(straightFlushCards[i].rank);
                                if (currValue !== prevValue + 1) {
                                    isConsecutive = false;
                                    break;
                                }
                            }

                            if (isConsecutive) {
                                const validation = this.rules.validatePlay(straightFlushCards, lastPlay, handCards);
                                if (validation.valid) {
                                    possiblePlays.push({
                                        cards: straightFlushCards,
                                        type: validation.type
                                    });
                                }
                            }
                        }
                    }
                }

                // æ£€æŸ¥å¤©ç‹ç‚¸å¼¹
                const jokers = handCards.filter(c => c.suit === 'joker');
                if (jokers.length === 4) {
                    const validation = this.rules.validatePlay(jokers, lastPlay, handCards);
                    if (validation.valid) {
                        possiblePlays.push({
                            cards: jokers,
                            type: validation.type
                        });
                    }
                }

                // è¿‡æ»¤ï¼šåªä¿ç•™èƒ½æ‰“è¿‡ä¸Šå®¶çš„ç‰Œ
                const filteredPlays = possiblePlays.filter(play => {
                    // ç¡®ä¿typeå­˜åœ¨
                    if (!play || !play.type) {
                        return false;
                    }
                    const playType = play.type;

                    // ä½¿ç”¨è§„åˆ™å¼•æ“ç›´æ¥éªŒè¯
                    const validation = this.rules.validatePlay(play.cards, lastPlay, handCards);
                    return validation.valid;
                });

                // æ’åºï¼šä¼˜å…ˆçº§å°çš„åœ¨å‰ï¼ˆç‚¸å¼¹ä¼˜å…ˆçº§é«˜ä½†æœ€åç”¨ï¼‰
                const sortedPlays = filteredPlays.sort((a, b) => {
                    // ç¡®ä¿aå’Œbå­˜åœ¨
                    if (!a || !b) return 0;

                    // ç¡®ä¿typeå­˜åœ¨
                    const aType = a.type || {};
                    const bType = b.type || {};

                    // ç‚¸å¼¹ä¼˜å…ˆçº§ä½ï¼ˆå°½é‡ä¸ç”¨ï¼‰
                    if (aType.type === 'bomb' && bType.type !== 'bomb') return 1;
                    if (bType.type === 'bomb' && aType.type !== 'bomb') return -1;

                    // æ™®é€šç‰Œå‹æŒ‰å¤§å°æ’åº
                    return this.comparePlayValues(a, b);
                });

                // å¦‚æœæ˜¯é¦–å‡ºï¼Œè¿”å›æ‰€æœ‰å¯èƒ½ï¼›å¦‚æœæœ‰ä¸Šå®¶ä¸”filteredPlaysä¸ºç©ºï¼Œè¯´æ˜è¿‡ç‰Œ
                return sortedPlays;
            }

            // å°è¯•ç‚¸å¼¹
            tryBombs(handCards, possiblePlays, lastType, lastPlay) {
                const rankGroups = this.groupCardsByRank(handCards);

                // æ£€æŸ¥4å¼ ç‚¸å¼¹
                for (let [rank, cards] of Object.entries(rankGroups)) {
                    if (cards.length >= 4) {
                        const bombCards = cards.slice(0, 4);
                        // ä½¿ç”¨è§„åˆ™å¼•æ“è¯†åˆ«ç‚¸å¼¹
                        let bombType = null;
                        if (this.useAdvancedEngine && this.ruleEngine) {
                            bombType = this.ruleEngine.getCardType(bombCards);
                        } else {
                            bombType = this.getCardType(bombCards);
                        }

                        if (bombType && bombType.type === 'bomb') {
                            // å¦‚æœä¸Šå®¶ä¸æ˜¯ç‚¸å¼¹ï¼Œç‚¸å¼¹å¯ä»¥æ‰“ä»»ä½•ç‰Œ
                            if (lastType.type !== 'bomb') {
                                possiblePlays.push({
                                    cards: bombCards,
                                    type: bombType
                                });
                            } else {
                                // å¦‚æœä¸Šå®¶ä¹Ÿæ˜¯ç‚¸å¼¹ï¼Œæ¯”è¾ƒå¤§å°
                                let canBeat = false;
                                if (this.ruleEngine) {
                                    canBeat = this.ruleEngine.compareCardTypes(bombType, lastType) > 0;
                                } else {
                                    // ç®€å•æ¯”è¾ƒï¼šæ¯”è¾ƒç‚¸å¼¹çš„ä¸»ç‰Œå€¼
                                    canBeat = this.getRankValue(bombCards[0].rank) > this.getRankValue(lastPlay.cards[0].rank);
                                }

                                if (canBeat) {
                                    possiblePlays.push({
                                        cards: bombCards,
                                        type: bombType
                                    });
                                }
                            }
                        }
                    }
                }

                // æ£€æŸ¥ç«ç®­ï¼ˆå¤§å°ç‹ï¼‰
                const jokers = handCards.filter(card => card.suit === 'joker');
                if (jokers.length >= 2) {
                    const hasBig = jokers.some(j => j.rank === 'big');
                    const hasSmall = jokers.some(j => j.rank === 'small');
                    if (hasBig && hasSmall) {
                        const rocketCards = jokers.filter(j => j.rank === 'big' || j.rank === 'small').slice(0, 2);
                        possiblePlays.push({
                            cards: rocketCards,
                            type: { type: 'rocket', subtype: 'kingRocket' }
                        });
                    }
                }
            }

            // æ‰¾å•ç‰Œ
            findSingles(handCards, possiblePlays, lastType, lastPlay) {
                // å¦‚æœä¸Šå®¶å‡ºçš„æ˜¯ç‚¸å¼¹æˆ–ç«ç®­ï¼Œä¸èƒ½ç”¨å•ç‰Œæ‰“
                if (lastType.type === 'bomb' || lastType.type === 'rocket') {
                    return;
                }

                const lastCards = lastType.cards || [];
                const lastValue = lastCards.length > 0 ? this.getRankValue(lastCards[0].rank) : (lastType.rank || lastType.highCard || 0);

                for (let card of handCards) {
                    const cardValue = this.getRankValue(card.rank);
                    if (cardValue > lastValue) {
                        const lastPlayForValidation = {
                            cards: lastCards,
                            type: lastType
                        };
                        const validation = this.rules.validatePlay([card], lastPlayForValidation, handCards);
                        if (validation.valid) {
                            possiblePlays.push({
                                cards: [card],
                                type: validation.type
                            });
                        }
                    }
                }
            }

            // æ‰¾å¯¹å­
            findPairs(handCards, possiblePlays, lastType) {
                // å¦‚æœä¸Šå®¶å‡ºçš„æ˜¯ç‚¸å¼¹æˆ–ç«ç®­ï¼Œä¸èƒ½ç”¨å¯¹å­æ‰“
                if (lastType.type === 'bomb' || lastType.type === 'rocket') {
                    return;
                }

                const rankGroups = this.groupCardsByRank(handCards);
                // ä»lastTypeä¸­è·å–ä¸Šå®¶ç‰Œçš„ä¿¡æ¯
                const lastRank = lastType.rank || lastType.highPair || 0;
                const lastCards = lastType.cards || [];

                for (let [rank, cards] of Object.entries(rankGroups)) {
                    if (cards.length >= 2) {
                        const rankValue = this.getRankValue(rank);
                        if (rankValue > lastRank) {
                            const pairCards = cards.slice(0, 2);
                            // æ„é€ lastPlayå¯¹è±¡è¿›è¡ŒéªŒè¯
                            const lastPlayForValidation = {
                                cards: lastCards,
                                type: lastType
                            };
                            const validation = this.rules.validatePlay(pairCards, lastPlayForValidation, handCards);
                            if (validation.valid) {
                                possiblePlays.push({
                                    cards: pairCards,
                                    type: validation.type
                                });
                            }
                        }
                    }
                }
            }

            // æ‰¾ä¸‰å¼ 
            findTriples(handCards, possiblePlays, lastType) {
                // å¦‚æœä¸Šå®¶å‡ºçš„æ˜¯ç‚¸å¼¹æˆ–ç«ç®­ï¼Œä¸èƒ½ç”¨ä¸‰å¼ æ‰“
                if (lastType.type === 'bomb' || lastType.type === 'rocket') {
                    return;
                }

                const rankGroups = this.groupCardsByRank(handCards);
                // ä»lastTypeä¸­è·å–ä¸Šå®¶ç‰Œçš„ä¿¡æ¯
                const lastRank = lastType.rank || lastType.highTriple || 0;
                const lastCards = lastType.cards || [];

                for (let [rank, cards] of Object.entries(rankGroups)) {
                    if (cards.length >= 3) {
                        const rankValue = this.getRankValue(rank);
                        if (rankValue > lastRank) {
                            const tripleCards = cards.slice(0, 3);
                            // æ„é€ lastPlayå¯¹è±¡è¿›è¡ŒéªŒè¯
                            const lastPlayForValidation = {
                                cards: lastCards,
                                type: lastType
                            };
                            const validation = this.rules.validatePlay(tripleCards, lastPlayForValidation, handCards);
                            if (validation.valid) {
                                possiblePlays.push({
                                    cards: tripleCards,
                                    type: validation.type
                                });
                            }
                        }
                    }
                }
            }

            // æ¯”è¾ƒå‡ºç‰Œå¤§å°
            comparePlayValues(play1, play2) {
                if (!play1 || !play2 || !play1.type || !play2.type) return 0;

                // ç›´æ¥æ¯”è¾ƒæƒé‡
                const weight1 = play1.type.weight || 0;
                const weight2 = play2.type.weight || 0;

                return weight1 - weight2;
            }

            // æ˜¾ç¤ºæ¸¸æˆå†…æ¶ˆæ¯
            showMessage(message, type = 'info') {
                const messageBubble = document.getElementById('messageBubble');
                if (messageBubble) {
                    messageBubble.textContent = message;
                    messageBubble.className = 'message-bubble';
                    messageBubble.style.display = 'block';

                    // æ ¹æ®æ¶ˆæ¯ç±»å‹æ·»åŠ æ ·å¼
                    if (type === 'error') {
                        messageBubble.style.background = '#ff4444';
                        messageBubble.style.animation = 'shake 0.5s';
                    } else if (type === 'success') {
                        messageBubble.style.background = '#4CAF50';
                    } else {
                        messageBubble.style.background = '#2196F3';
                    }

                    // 3ç§’åéšè—
                    setTimeout(() => {
                        messageBubble.style.display = 'none';
                        messageBubble.style.animation = '';
                    }, 3000);
                }
            }

            // å†³å®šé¦–å±€é¦–å‡ºç©å®¶ï¼ˆéšæœºå†³å®šï¼‰
            determineFirstPlayer() {
                // éé¦–å±€ï¼Œç”±ä¸Šå±€æœ«æ¸¸å…ˆå‡º
                if (!this.isFirstGame && this.lastGameLoser) {
                    this.showMessage(`${this.players[this.lastGameLoser].name}æ˜¯ä¸Šå±€æœ«æ¸¸ï¼Œä¼˜å…ˆå‡ºç‰Œ`, 'info');
                    return this.lastGameLoser;
                }

                // é¦–å±€éšæœºå†³å®šé¦–å‡ºç©å®¶
                const order = ['south', 'west', 'north', 'east'];
                const firstPlayer = order[Math.floor(Math.random() * 4)];

                this.showMessage(`${this.players[firstPlayer].name}éšæœºè·å¾—é¦–å‡ºæƒ`, 'info');
                return firstPlayer;
            }

            // è·å–æ‰€æœ‰ç‰Œ
            getAllCards() {
                const allCards = [];
                const suits = ['â™ ', 'â™¥', 'â™£', 'â™¦'];
                const ranks = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A', '2'];

                // æ¯ç§ç‰Œå‹4å¼ 
                for (let suit of suits) {
                    for (let rank of ranks) {
                        for (let i = 0; i < 4; i++) {
                            allCards.push({ suit, rank });
                        }
                    }
                }

                // å¤§å°ç‹
                allCards.push({ suit: 'joker', rank: 'small' });
                allCards.push({ suit: 'joker', rank: 'big' });

                return allCards;
            }

  
            showRecords() {
                this.showMessage('æˆ˜ç»©åŠŸèƒ½å¼€å‘ä¸­...', 'info');
            }

            restartGame() {
                if (confirm('ç¡®å®šè¦é‡æ–°å¼€å§‹æ¸¸æˆå—ï¼Ÿ')) {
                    // æ¸…ç©ºæ‰€æœ‰çŠ¶æ€
                    this.currentRoundCards = [];
                    this.lastPlayer = null;
                    this.selectedCards = [];
                    this.gameState = 'waiting';
                    this.roundPlayers.clear();
                    this.roundPassedPlayers.clear();

                    // æ¸…ç©ºç©å®¶æ‰‹ç‰Œ
                    for (let pos in this.players) {
                        this.players[pos].cards = [];
                    }

                    // é‡æ–°å‘ç‰Œ
                    this.dealCards();

                    // å†³å®šé¦–å‡ºç©å®¶
                    this.currentPlayer = this.determineFirstPlayer();
                    console.log(`æ¸¸æˆé‡æ–°å¼€å§‹ï¼Œé¦–å‡ºç©å®¶ï¼š${this.currentPlayer}`);

                    // æ›´æ–°UI
                    this.updateUI();
                    this.gameState = 'playing';

                    // å¦‚æœé¦–å‡ºç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨å‡ºç‰Œ
                    if (this.players[this.currentPlayer].isAI) {
                        setTimeout(() => this.aiAutoPlay(), 1500);
                    }
                }
            }

            showSettings() {
                alert('è®¾ç½®åŠŸèƒ½å¼€å‘ä¸­...');
            }

            getCardType(cards) {
                if (!cards || cards.length === 0) return null;

                // æ£€æŸ¥å¤§å°ç‹ï¼ˆç‚¸å¼¹ï¼‰
                if (cards.length === 1) {
                    if (cards[0].suit === 'joker') {
                        return { type: 'bomb', subtype: 'singleJoker' };
                    }
                    return { type: 'single' };
                } else if (cards.length === 2) {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç«ç®­ï¼ˆå¤§å°ç‹ï¼‰
                    if (cards[0].suit === 'joker' && cards[1].suit === 'joker') {
                        return { type: 'rocket', subtype: 'kingRocket' };
                    }
                    // æ£€æŸ¥æ˜¯å¦æ˜¯å¯¹å­
                    if (cards[0].rank === cards[1].rank) {
                        return { type: 'pair' };
                    }
                    return { type: 'invalid' };
                } else if (cards.length === 3) {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ä¸‰å¼ 
                    if (cards[0].rank === cards[1].rank && cards[1].rank === cards[2].rank) {
                        return { type: 'triple' };
                    }
                    return { type: 'invalid' };
                } else if (cards.length === 4) {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç‚¸å¼¹ï¼ˆ4å¼ åŒç‚¹æ•°ï¼‰
                    const firstRank = cards[0].rank;
                    if (cards.every(card => card.rank === firstRank)) {
                        return { type: 'bomb', subtype: '4bomb' };
                    }
                    // æ£€æŸ¥ä¸‰å¸¦ä¸€
                    const rankCounts = {};
                    cards.forEach(card => {
                        rankCounts[card.rank] = (rankCounts[card.rank] || 0) + 1;
                    });
                    const counts = Object.values(rankCounts);
                    if (counts.includes(3) && counts.includes(1)) {
                        const mainRank = Object.keys(rankCounts).find(rank => rankCounts[rank] === 3);
                        return { type: 'tripleWithOne', mainRank: this.getRankValue(mainRank) };
                    }
                    return { type: 'invalid' };
                } else if (cards.length === 5) {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç‚¸å¼¹ï¼ˆ5å¼ åŒç‚¹æ•°ï¼‰
                    const firstRank = cards[0].rank;
                    if (cards.every(card => card.rank === firstRank)) {
                        return { type: 'bomb', subtype: '5bomb' };
                    }
                    // æ£€æŸ¥ä¸‰å¸¦äºŒ
                    const rankCounts = {};
                    cards.forEach(card => {
                        rankCounts[card.rank] = (rankCounts[card.rank] || 0) + 1;
                    });
                    const counts = Object.values(rankCounts);
                    if (counts.includes(3) && counts.includes(2)) {
                        const mainRank = Object.keys(rankCounts).find(rank => rankCounts[rank] === 3);
                        return { type: 'tripleWithPair', mainRank: this.getRankValue(mainRank) };
                    }
                    return { type: 'invalid' };
                } else if (cards.length >= 6) {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç‚¸å¼¹ï¼ˆ6å¼ æˆ–æ›´å¤šåŒç‚¹æ•°ï¼‰
                    const firstRank = cards[0].rank;
                    if (cards.every(card => card.rank === firstRank)) {
                        return { type: 'bomb', subtype: `${cards.length}bomb` };
                    }
                }

                return { type: 'basic' };
            }

            // éªŒè¯ç‰Œå‹æ˜¯å¦æœ‰æ•ˆ
            isValidPlayType(cardType, expectedCount) {
                if (!cardType || expectedCount <= 0) return false;

                switch (expectedCount) {
                    case 1:
                        return cardType.type === 'single';
                    case 2:
                        return cardType.type === 'pair';
                    case 3:
                        return cardType.type === 'triple';
                    default:
                        // å¯¹äºæ›´å¤šå¼ çš„ç‰Œï¼Œè¿™é‡Œå¯ä»¥æ‰©å±•è§„åˆ™ï¼ˆå¦‚é¡ºå­ã€è¿å¯¹ç­‰ï¼‰
                        return cardType.type !== 'invalid';
                }
            }
        }

        // æ¼è›‹è§„åˆ™å¼•æ“
        class GuandanRules {
            constructor() {
                this.cardOrder = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A', '2', 'å°ç‹', 'å¤§ç‹'];
                this.currentLevel = 2;
                this.jokerCard = null;
                this.initializeLevel();

                // ä½¿ç”¨æ–°å®Œå–„çš„è§„åˆ™å¼•æ“
                try {
                    if (typeof RuleEngine !== 'undefined') {
                        this.ruleEngine = new RuleEngine(null);
                        this.ruleEngine.setLevel(this.currentLevel);
                        this.useAdvancedEngine = true;
                        console.log('[è§„åˆ™å¼•æ“] å·²å¯ç”¨é«˜çº§è§„åˆ™å¼•æ“');
                    }
                } catch (error) {
                    console.warn('[è§„åˆ™å¼•æ“] é«˜çº§å¼•æ“åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨åŸºç¡€å¼•æ“');
                }
            }

            initializeLevel() {
                this.jokerCard = this.currentLevel === 14 ? 'A' : this.currentLevel.toString();
            }

            getCardValue(rank) {
                return this.cardOrder.indexOf(rank);
            }

            validatePlay(cards, lastPlay, playerHand) {
                try {
                    // è°ƒè¯•è¾“å‡º
                    console.log('[validatePlay] å‡ºç‰Œ:', cards.map(c => c.rank + (c.suit === 'joker' ? '' : c.suit)).join(', '));
                    if (lastPlay) {
                        console.log('[validatePlay] ä¸Šå®¶ç‰Œ:', lastPlay.cards ? lastPlay.cards.map(c => c.rank + (c.suit === 'joker' ? '' : c.suit)).join(', ') : 'æœªçŸ¥');
                    }

                    // ä½¿ç”¨æ–°çš„å®˜æ–¹è§„åˆ™å¼•æ“
                    if (this.ruleEngine) {
                        let lastPlayCards = null;
                        if (lastPlay && lastPlay.cards) {
                            lastPlayCards = lastPlay.cards;
                        } else if (lastPlay && Array.isArray(lastPlay)) {
                            lastPlayCards = lastPlay;
                        }

                        const result = this.ruleEngine.validatePlay(cards, lastPlayCards, playerHand);
                        console.log('[validatePlay] è§„åˆ™å¼•æ“ç»“æœ:', result);

                        return result;
                    }
                } catch (error) {
                    console.error('[å‡ºç‰ŒéªŒè¯é”™è¯¯]', error);
                }

                // ç®€å•éªŒè¯
                if (cards.length === 0) {
                    return { valid: false, message: 'æ²¡æœ‰é€‰æ‹©ç‰Œ' };
                }

                return { valid: true, message: 'å‡ºç‰Œåˆæ³•', cardType: { type: 'basic' } };
            }

            getCardType(cards) {
                if (!cards || cards.length === 0) {
                    console.log('[getCardType] æ— ç‰Œæˆ–ç©ºæ•°ç»„');
                    return null;
                }

                console.log('[getCardType] è¯†åˆ«ç‰Œå‹:', cards.map(c => `${c.rank}${c.suit}`).join(','));

                // ä½¿ç”¨æ–°çš„å®˜æ–¹è§„åˆ™å¼•æ“
                if (this.ruleEngine) {
                    try {
                        const result = this.ruleEngine.getCardType(cards);
                        console.log('[getCardType] è§„åˆ™å¼•æ“è¿”å›:', result);
                        if (result && result.type) {
                            return result;
                        }
                    } catch (error) {
                        console.warn('[è§„åˆ™å¼•æ“] ç‰Œå‹è¯†åˆ«å¤±è´¥:', error);
                    }
                } else {
                    console.log('[getCardType] è§„åˆ™å¼•æ“æœªåˆå§‹åŒ–ï¼Œä½¿ç”¨fallbacké€»è¾‘');
                }

                // åŸºç¡€ç‰Œå‹è¯†åˆ«ï¼ˆfallbackï¼‰
                const len = cards.length;
                if (len === 1) {
                    return { type: 'single' };
                } else if (len >= 5) {
                    // æ£€æŸ¥æ˜¯å¦ä¸ºåŒèŠ±é¡º
                    console.log(`[getCardType] æ£€æŸ¥åŒèŠ±é¡ºï¼Œé•¿åº¦: ${len}`);
                    if (this.isStraightFlush(cards)) {
                        console.log('[getCardType] åŒèŠ±é¡ºæ£€æµ‹é€šè¿‡ï¼');
                        return { type: 'straight_flush', weight: 50 + len }; // åŸºç¡€æƒé‡50 + é•¿åº¦
                    }
                    console.log('[getCardType] ä¸æ˜¯åŒèŠ±é¡º');
                } else if (len === 4) {
                    // æ£€æŸ¥æ˜¯å¦ä¸ºå¤©ç‹ç‚¸ï¼ˆ4å¼ ç‹ç‰Œï¼‰
                    const jokerCount = cards.filter(c => c.suit === 'joker').length;
                    if (jokerCount === 4) {
                        return { type: 'king_bomb', weight: 1000 };
                    }
                    // æ£€æŸ¥æ˜¯å¦ä¸ºç‚¸å¼¹ï¼ˆ4å¼ åŒç‚¹æ•°ï¼‰
                    if (cards[0].rank === cards[1].rank &&
                        cards[1].rank === cards[2].rank &&
                        cards[2].rank === cards[3].rank) {
                        return { type: 'bomb', weight: 100 };
                    }
                } else if (len === 2) {
                    // æ£€æŸ¥æ˜¯å¦ä¸ºå¯¹å­
                    if (cards[0].rank === cards[1].rank) {
                        return { type: 'pair' };
                    }
                } else if (len === 3) {
                    // æ£€æŸ¥æ˜¯å¦ä¸ºä¸‰å¼ 
                    if (cards[0].rank === cards[1].rank && cards[1].rank === cards[2].rank) {
                        return { type: 'triple' };
                    }
                }

                // é»˜è®¤è¿”å›æ— æ•ˆç‰Œå‹
                console.log('[getCardType] æ— æ³•è¯†åˆ«çš„ç‰Œå‹ï¼Œè¿”å›invalid');
                return { type: 'invalid' };
            }

            /**
             * æ£€æŸ¥æ˜¯å¦ä¸ºåŒèŠ±é¡º
             */
            isStraightFlush(cards) {
                if (cards.length < 5) return false;

                // æ£€æŸ¥æ˜¯å¦éƒ½æ˜¯åŒèŠ±è‰²
                const firstSuit = cards[0].suit;
                if (cards.some(c => c.suit !== firstSuit)) return false;
                if (firstSuit === 'joker') return false; // ç‹ç‰Œä¸èƒ½ç»„æˆåŒèŠ±é¡º

                // æ£€æŸ¥æ˜¯å¦æ˜¯è¿ç»­çš„
                const values = cards.map(c => {
                    if (c.rank === 'A') return 14;
                    if (c.rank === 'K') return 13;
                    if (c.rank === 'Q') return 12;
                    if (c.rank === 'J') return 11;
                    if (c.rank === '10') return 10;
                    return parseInt(c.rank);
                });

                // æ’åºå¹¶æ£€æŸ¥è¿ç»­æ€§
                values.sort((a, b) => a - b);

                for (let i = 1; i < values.length; i++) {
                    if (values[i] - values[i-1] !== 1) {
                        return false;
                    }
                }

                console.log(`[åŒèŠ±é¡º] æ£€æµ‹é€šè¿‡: ${values.join(', ')}`);
                return true;
            }
        }

        // å…¨å±€æ¸¸æˆå®ä¾‹
        let game;

        // å…¨å±€å‡½æ•°
        function playCards() {
            if (game) game.playCards();
        }

        function passTurn() {
            if (game) game.passTurn();
        }

        function showHint() {
            if (game) game.showHint();
        }

        function reportCards() {
            if (game) game.reportCards();
        }

        function showRecords() {
            if (game) game.showRecords();
        }

        function restartGame() {
            if (game) game.restartGame();
        }

        function showSettings() {
            if (game) game.showSettings();
        }

        function toggleSortMode() {
            console.log('[toggleSortMode] æŒ‰é’®è¢«ç‚¹å‡»');

            // æµ‹è¯•æŒ‰é’®æ˜¯å¦èƒ½è¢«è·å–
            const sortBtn = document.getElementById('sortBtn');
            console.log('[toggleSortMode] sortBtnå…ƒç´ :', sortBtn);

            if (game) {
                console.log('[toggleSortMode] gameå¯¹è±¡å­˜åœ¨ï¼Œè°ƒç”¨toggleSortModeæ–¹æ³•');
                game.toggleSortMode();
            } else {
                console.error('[toggleSortMode] gameå¯¹è±¡ä¸å­˜åœ¨');
            }
        }

        // æ¨¡å—åŒ–åŠ è½½ç®¡ç†å™¨
        class ModuleLoader {
            constructor() {
                this.modules = new Map();
                this.loadProgress = 0;
                this.totalModules = 3;
            }

            updateProgress(moduleName, status, progress = null) {
                this.loadProgress = Math.min(100, this.loadProgress + (100 / this.totalModules));

                document.getElementById('loadingProgress').style.width = this.loadProgress + '%';
                document.getElementById('loadingStatus').textContent = `æ­£åœ¨åŠ è½½ ${moduleName}...`;

                this.log(`[æ¨¡å—åŠ è½½] ${moduleName}: ${status}`);
            }

            log(message) {
                console.log(message);
            }

            handleError(error, moduleName) {
                this.log(`[é”™è¯¯] ${moduleName}: ${error.message}`);
                document.getElementById('errorText').textContent = `${moduleName} åŠ è½½å¤±è´¥: ${error.message}`;
                document.getElementById('errorMessage').classList.add('show');
            }

            async loadAllModules() {
                try {
                    // æ¨¡æ‹ŸåŠ è½½æ¨¡å—
                    this.updateProgress('æ¸¸æˆå¼•æ“', 'loading');
                    await new Promise(resolve => setTimeout(resolve, 500));

                    this.updateProgress('ç•Œé¢ç»„ä»¶', 'loading');
                    await new Promise(resolve => setTimeout(resolve, 500));

                    // åˆå§‹åŒ–æ¸¸æˆ
                    await this.initializeGame();

                    // éšè—åŠ è½½ç”»é¢ï¼Œæ˜¾ç¤ºæ¸¸æˆ
                    setTimeout(() => {
                        document.getElementById('loadingScreen').style.display = 'none';
                        document.getElementById('gameContainer').classList.add('loaded');
                    }, 500);

                    this.log('[ç³»ç»Ÿ] æ‰€æœ‰æ¨¡å—åŠ è½½å®Œæˆï¼Œæ¸¸æˆåˆå§‹åŒ–æˆåŠŸ');

                } catch (error) {
                    this.handleError(error, 'æ¨¡å—åŠ è½½å™¨');
                }
            }

            async initializeGame() {
                try {
                    // åˆ›å»ºæ¸¸æˆå®ä¾‹
                    game = new GuandanGame();
                    this.log('[æ¸¸æˆå¼•æ“] åˆå§‹åŒ–å®Œæˆ');

                    // æµ‹è¯•æŒ‰é’®æ˜¯å¦å­˜åœ¨
                    const sortBtn = document.getElementById('sortBtn');
                    console.log('[åˆå§‹åŒ–] sortBtnæŒ‰é’®:', sortBtn);
                    console.log('[åˆå§‹åŒ–] sortBtn onclick:', sortBtn ? sortBtn.onclick : 'undefined');

                    // æ·»åŠ ç©ºç™½åŒºåŸŸç‚¹å‡»äº‹ä»¶ - æ¸…ç©ºé€‰ä¸­çš„æ‰‹ç‰Œ
                    document.getElementById('gameContainer').addEventListener('click', (e) => {
                        // æ£€æŸ¥ç‚¹å‡»çš„æ˜¯å¦ä¸ºç©ºç™½åŒºåŸŸï¼ˆä¸æ˜¯æ‰‹ç‰Œæˆ–å…¶ä»–æŒ‰é’®ï¼‰
                        const isCard = e.target.classList.contains('player-card') ||
                                      e.target.closest('.player-card');
                        const isButton = e.target.tagName === 'BUTTON' || e.target.closest('button');
                        const isControl = e.target.closest('.control-buttons') ||
                                         e.target.closest('.player-info') ||
                                         e.target.closest('.opponent-area') ||
                                         e.target.closest('#southCards');

                        // å¦‚æœç‚¹å‡»çš„ä¸æ˜¯ç‰Œã€æŒ‰é’®æˆ–æ§åˆ¶åŒºåŸŸï¼Œä¸”å½“å‰æœ‰é€‰ä¸­çš„ç‰Œ
                        if (!isCard && !isButton && !isControl && game && game.selectedCards.length > 0) {
                            // å»¶è¿Ÿæ¸…ç©ºï¼Œé¿å…ä¸å¡ç‰‡ç‚¹å‡»å†²çª
                            setTimeout(() => {
                                if (game.selectedCards.length > 0) {
                                    game.clearSelection();
                                }
                            }, 100);
                        }
                    });

                } catch (error) {
                    this.handleError(error, 'æ¸¸æˆåˆå§‹åŒ–');
                    throw error;
                }
            }
        }

        // æµ‹è¯•è¿è¡Œå™¨
        let testRunner = null;

        // è¿è¡Œæ‰€æœ‰æµ‹è¯•
        async function runTests() {
            if (!testRunner) {
                testRunner = new TestRunner();

                // åˆ›å»ºè§„åˆ™å¼•æ“å®ä¾‹ç”¨äºæµ‹è¯•
                const testRuleEngine = new RuleEngine(null);

                // æ·»åŠ æ‰€æœ‰æµ‹è¯•å¥—ä»¶
                testRunner.addSuite(createCardTypeTests(testRuleEngine));
                testRunner.addSuite(createComparisonTests(testRuleEngine));
                testRunner.addSuite(createRoundTests());
                testRunner.addSuite(createAITests(testRuleEngine));
            }

            // è¿è¡Œæµ‹è¯•
            console.log('\nğŸ§ª å¼€å§‹è¿è¡Œæ¼è›‹æ¸¸æˆæµ‹è¯•å¥—ä»¶...');
            const results = await testRunner.runAllTests();

            // æ˜¾ç¤ºæµ‹è¯•ç»“æœ
            const summary = testRunner.getResultsSummary();
            if (summary.allPassed) {
                console.log('âœ… æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼');
                showTestNotification('æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼', 'success');
            } else {
                console.log('âŒ å­˜åœ¨æµ‹è¯•å¤±è´¥');
                showTestNotification(`æµ‹è¯•å¤±è´¥ï¼š${summary.totalFailed}/${summary.totalTests}`, 'error');
            }

            return results;
        }

        // è¿è¡Œç‰¹å®šæµ‹è¯•å¥—ä»¶
        async function runSpecificSuite(suiteName) {
            if (!testRunner) {
                await runTests();  // å…ˆåˆå§‹åŒ–
                return;
            }

            try {
                const results = await testRunner.runSpecificSuite(suiteName);
                return results;
            } catch (error) {
                console.error(`è¿è¡Œæµ‹è¯•å¥—ä»¶ "${suiteName}" å¤±è´¥:`, error);
                showTestNotification(`è¿è¡Œæµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æ˜¾ç¤ºæµ‹è¯•é€šçŸ¥
        function showTestNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `test-notification ${type}`;
            notification.innerHTML = `
                <span class="test-icon">${type === 'success' ? 'âœ…' : type === 'error' ? 'âŒ' : 'â„¹ï¸'}</span>
                <span class="test-message">${message}</span>
                <button class="test-close" onclick="this.parentElement.remove()">Ã—</button>
            `;

            // æ·»åŠ æ ·å¼
            if (!document.querySelector('#test-notification-style')) {
                const style = document.createElement('style');
                style.id = 'test-notification-style';
                style.textContent = `
                    .test-notification {
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: white;
                        padding: 15px 20px;
                        border-radius: 8px;
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                        display: flex;
                        align-items: center;
                        gap: 10px;
                        z-index: 10000;
                        max-width: 400px;
                        animation: slideIn 0.3s ease;
                    }
                    .test-notification.success {
                        border-left: 4px solid #4CAF50;
                    }
                    .test-notification.error {
                        border-left: 4px solid #f44336;
                    }
                    .test-notification.info {
                        border-left: 4px solid #2196F3;
                    }
                    .test-icon {
                        font-size: 20px;
                    }
                    .test-message {
                        flex: 1;
                        font-family: monospace;
                    }
                    .test-close {
                        background: none;
                        border: none;
                        font-size: 20px;
                        cursor: pointer;
                        color: #999;
                    }
                    .test-close:hover {
                        color: #333;
                    }
                    @keyframes slideIn {
                        from {
                            transform: translateX(100%);
                            opacity: 0;
                        }
                        to {
                            transform: translateX(0);
                            opacity: 1;
                        }
                    }
                `;
                document.head.appendChild(style);
            }

            document.body.appendChild(notification);

            // è‡ªåŠ¨ç§»é™¤é€šçŸ¥
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 5000);
        }

        // ä¿å­˜æµ‹è¯•æŠ¥å‘Š
        function saveTestReport() {
            if (testRunner) {
                testRunner.saveHTMLReport('guandan-test-report.html');
                showTestNotification('æµ‹è¯•æŠ¥å‘Šå·²ä¿å­˜', 'success');
            } else {
                showTestNotification('è¯·å…ˆè¿è¡Œæµ‹è¯•', 'error');
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆåå¼€å§‹åŠ è½½æ¨¡å—
        document.addEventListener('DOMContentLoaded', () => {
            console.log('é¡µé¢åŠ è½½å®Œæˆï¼Œå¼€å§‹æ¨¡å—åŠ è½½æµç¨‹');
            const loader = new ModuleLoader();

            setTimeout(() => {
                loader.loadAllModules();
            }, 100);

            // æ·»åŠ æµ‹è¯•å¿«æ·é”®æ”¯æŒ
            document.addEventListener('keydown', (e) => {
                // Ctrl+T: è¿è¡Œæ‰€æœ‰æµ‹è¯•
                if (e.ctrlKey && e.key === 't') {
                    e.preventDefault();
                    runTests();
                }
                // Ctrl+Shift+T: è¿è¡Œç‰¹å®šæµ‹è¯•
                else if (e.ctrlKey && e.shiftKey && e.key === 'T') {
                    e.preventDefault();
                    const suiteNames = ['ç‰Œå‹è¯†åˆ«æµ‹è¯•', 'æ¯”å¤§å°è§„åˆ™æµ‹è¯•', 'è½®æ¬¡ç®¡ç†æµ‹è¯•', 'AIå‡ºç‰Œé€»è¾‘æµ‹è¯•'];
                    const suiteName = prompt(`è¯·é€‰æ‹©æµ‹è¯•å¥—ä»¶:\n${suiteNames.map((n, i) => `${i + 1}. ${n}`).join('\n')}\n\nè¾“å…¥æ•°å­— (1-${suiteNames.length})`);
                    if (suiteName && !isNaN(suiteName)) {
                        const index = parseInt(suiteName) - 1;
                        if (index >= 0 && index < suiteNames.length) {
                            runSpecificSuite(suiteNames[index]);
                        }
                    }
                }
                // Ctrl+S: ä¿å­˜æµ‹è¯•æŠ¥å‘Š
                else if (e.ctrlKey && e.key === 's' && !e.shiftKey) {
                    e.preventDefault();
                    saveTestReport();
                }
            });

            // å°†æµ‹è¯•å‡½æ•°æ·»åŠ åˆ°å…¨å±€ä½œç”¨åŸŸï¼Œæ–¹ä¾¿è°ƒè¯•
            window.runTests = runTests;
            window.runSpecificSuite = runSpecificSuite;
            window.saveTestReport = saveTestReport;
            window.testRunner = testRunner;

            console.log('\nğŸ® æ¼è›‹æ¸¸æˆæµ‹è¯•æ¡†æ¶å·²åŠ è½½');
            console.log('å¿«æ·é”®:');
            console.log('  Ctrl+T    - è¿è¡Œæ‰€æœ‰æµ‹è¯•');
            console.log('  Ctrl+Shift+T - é€‰æ‹©è¿è¡Œç‰¹å®šæµ‹è¯•å¥—ä»¶');
            console.log('  Ctrl+S    - ä¿å­˜æµ‹è¯•æŠ¥å‘Š');
            console.log('  runTests() - åœ¨æ§åˆ¶å°è¿è¡Œæµ‹è¯•');
        });

        // å…¨å±€é”™è¯¯å¤„ç†
        window.addEventListener('error', (event) => {
            console.error('[å…¨å±€é”™è¯¯]', event.error);
        });
    </script>
</body>
</html>